# ============================================ #
# Georgian disambiguator                       #
# This file combines rules for OG, MG and NG.  #
# Rules that are only valid for a subset of    #
# varieties should be prepended by the variety #
# name(s): o, m, n, plus hyphen.               #
# E.g., om-SELECT …			       #
# ============================================ #

# tavisupleba/content/article/1538021
# ალექსანდრე ქუთათელი: პირისპირ

# run like:
# cat test.vrt | vislcg3 --grammar geo-ng-dis.cg3 --trace > test.dis

# OBS: do not use [0], [1] etc. as tags since they are used internally in the Lisp interface

STRICT-TAGS += 1 2 3 A Abbrev Abs Act Adv Advb Alpha Anim Anthr Aor
	    Approx Area Att Ben Bracket Card Caus Causal Cause Cj Colon
	    Comm Comma Compar Compl Cond Conj-I Conj-II Conj-III ConjFut
	    ConjPerf ConjPres Converb Coord DAdvb DDAdvb DDDat DDErg DDGen
	    DDInst DDL DDNewPl DDNom DDOldPl DDPl DDSg DDVoc DDat DErg DGen
	    DInst DL DNewPl DNom DO:1 DO:1Pl DO:1Sg DO:2 DO:2Pl DO:2Sg DO:3
	    DO:3Pl DO:3Sg DOldPl DPl DSg DTrunc DVoc Dash Dat Deg DegNum Dem
	    Dialect Digits Dir Disc Dist Distr Dot Elat Ellipsis Encl Encl:Aux
	    Encl:IndSp1 Encl:IndSp2 Encl:IndSp3 Encl:Q Encl:ვე Encl:კი
	    Encl:მდა Encl:მე Encl:მც Encl:მცა Encl:რა Encl:რე Encl:ღა Encl:ც
	    Encl:ცა Encl:ძი Erg ExclPoint Ext Final FirstName Foc Foreign
	    Frac Freq Fut FutPart Gen Hum Hydr Hyphen IO:1 IO:1Pl IO:1Sg
	    IO:2 IO:2Pl IO:2Sg IO:3 IO:3Pl Imp Imperfective Impf Impv Impv-I
	    Impv-II Indef Inst Int IntMark Interj Inv Iter Iter-II Iter-III
	    IterImpf IterPerf IterPres L LV LastName Letter Loc Mann Meas Med
	    MedAct MedPass Modal N NMod Neg NegPart NewPl Nom NonStand Nonhum
	    Num OV Old OldPl Opt Ord Org PP PP:გან PP:და PP:დამ PP:დამი PP:დან
	    PP:დმი PP:ებრ PP:ებრივ PP:ვით PP:ზე PP:ზედ PP:თან PP:თვის PP:კე
	    PP:კენ PP:მდე PP:მდი PP:მდინ PP:მდის PP:მებრ PP:მი PP:მო PP:ურთ
	    PP:ქვეშ PP:ში PP:შუა PP:წინ Paren Part Pass PassState PastPart
	    PastPart:ნა Perf Period Pers Pfx:მი Pfx:მო Pl Place PluPerf Poss
	    Poss1Pl Poss1Sg Poss2Pl Poss2Sg Poss3Pl Poss3Sg Pot Pp PrePv Pres
	    PresPart Pron Prop Prox Punct Pv Qual Quant Quote Range Rare Recip
	    Refl Rel Rel:ც Rel:ცა RelDist RelMed RelProx Repet Roman Root
	    S:1 S:1Pl S:1Sg S:2 S:2Pl S:2Sg S:3 S:3Pl S:3Sg SIndef SV Semicolon
	    Sent Sg Star Sub Symbol Temp Time Title Tm:ვე Tm:მე Tm:მცა Tm:რე
	    Tm:ღა Tm:ცა Tm:ძი Top Trunc V VComp VN Voc [Excl] [Incl] [OV]
	    <Advb> <AuxIntr> <AuxTrans> <AuxTransHum> <DO:Dat> <DO:Nom>
	    <Dat/Gen> <Dat> <Der:ებრ> <Der:ელ> <Der:ეულ> <Der:იან> <Der:მაგვარ>
	    <Der:ნაირ> <Der:ობრივ> <Der:სა-ო> <Der:უ-ო> <Der:ურ> <Der:ფერ>
	    <Gen> <IO:Dat> <IO:Gen> <Inst> <Null> <OldPl> <PP:გან> <PP:თან>
	    <S-DO-IO> <S-DO> <S-IO> <S-OTh-Pred> <S:Dat> <S:Erg> <S:Nom> <S> 
	    Unrecognized Guess @NC @CLB @ADDED [0] MWE <MWE> Coll
	    # dependency relations
	    >SUBJ >DO >IO >XOBJ >PRL
	    >COMP >ATR >NUM >POSS >GEN >OBJ >OBL >AG
	    >OBL-COMPAR >APOS >??
     	    >DET >QUAL >NEG >MODAL >REL >NAMEMOD >PRED >P >ADV >AUX >MWE >QUOTE >VOC
	    >INTERJ ;


# ========== #
# Delimiters #
# ========== #

DELIMITERS = "<.>" "<!>" "<?>" "<…>" "<;>" "<–>" ;

PARENTHESES = ("<(>" "<)>") ("<[>" "<]>") ;

# ============= #
# Tags and sets #
# ============= #

# ========
   SETS
# ========

SET BOS = (>>>) | (Colon) ;
SET BOP = (>>>) | (Comma) | (Semicolon) ;

SET NOM = N | A | Part | Card | SIndef ;
SET NA = N | A ;
SET NADem = N | A | Dem ;
SET NAProp = N | A | Prop ;
SET NAPropPart = N | VN | A | Prop | Part ;
SET NADemProp = N | A | Dem | Prop ;
SET NProp = N | Prop ;
SET NACProp = N | VN | A | Card | Prop ;
SET NACDemProp = N | A | VN | Card | Dem | Prop | Part | SIndef ;
SET NACDemPropPron = N | A | Card | Dem | Prop | (Pron Pers) | Part | SIndef ;
SET ADJ = A | Num ;
SET ADemNum = A | Dem | Num ;
SET APart = A | Part ;
SET NAPart = N | A | Part ;
SET INDEF = (Pron SIndef) | (Pron Indef) ;

SET PREP = ("<წინაშე>" Pp) | ("<შორის>" Pp) | ("<შემდგომად>" Pp)
       	    | ("<ვიდრე>" Pp) | ("<მიერ>" Pp <Inst>) | ("<შემდგომად>" Pp)
	    | ("<ნაცვლად>" Pp) ;


SET POSTP = Pp - PREP ;


SET PERSON = Hum | Anthr | Org ;

LIST Money = "ლარ·ი" "დოლარ·ი" "ევრო" "მანეთ·ი" ;

LIST CASE = Nom Erg Dat Gen Advb Inst Voc Abs Ben Dir ;
LIST CASEnoAdvb = Nom Erg Dat Gen Inst Voc Abs Ben Dir ;
LIST DatAdv = Dat Advb ;
LIST DatGen = Dat Gen ;
LIST NomGenInst = Nom Gen Inst ;

SET NUMBER = Sg | OldPl | NewPl ;

LIST Aux = Encl:Aux ;

LIST IMPV = Impv Impv-I Impv-II ;

LIST PRES = Pres Impf ConjPres ;
LIST FUT = Fut Cond ConjFut ;

SET  PRFUT = PRES | FUT ;

LIST AOR = Aor Opt Conj-II Iter-II Impv ;
LIST PERF = Perf PluPerf ConjPerf ;

LIST OPT = Opt ConjPres PluPerf ;


LIST TENSE = Pres Impf Conj-I Conj-II Conj-III Aor Impv-I Impv-II PluPerf
	       	IterPres IterImpf IterPerf Iter-II Iter-III ;

# Unrecognized is a reading that is added on the fly for tokens without morphology.
LIST Guess = Guess Unrecognized ;

SET S:1 = S:1Sg | S:1Pl ;
SET S:2 = S:2Sg | S:2Pl ;
SET S:3 = S:3Sg | S:3Pl ;

LIST S:12 = S:1Sg S:2Sg S:1Pl S:2Pl ;

LIST DO:3   = DO:3 DO:3Sg DO:3Pl ;
LIST DO:12  = DO:1Sg DO:2Sg DO:1Pl DO:2Pl ;

LIST IO:12  = IO:1Sg IO:2Sg IO:1Pl IO:2Pl ;
LIST Incl = [Incl] ;

SET NomSg = (Nom Sg) ;
SET NomPl = (Nom Pl) ;
SET ErgSg = (Erg Sg) ;
SET ErgPl = (Erg Pl) ;
SET DatSg = (Dat Sg) ;
SET DatPl = (Dat Pl) ;

SET AUX = (<AuxTrans>) | (<AuxTransHum>) | (<AuxIntr>) ;

# verbs (optionally) taking a Hum IO
LIST IOHumV = "და-ბარებ[ა]/ბარ" ;

# verbs that can have a PRL
LIST PREDVerb = "ყოფნ\\[ა\\]/.*"r
     	        # Encl:Aux
		"ქონ[ა]/ქონ"
		"ქონ[ა]/ქნ"
     	      	"და·რჩენ[ა]/რჩ"
		"რქმევ[ა]/რქვ"
		"აღმო·ჩენ[ა]/ჩნ"
		"წარმო·დგენ\\[ა\\]/.*"r
		"*·რჩენ[ა]/რჩ"
		"ჯდომ[ა]/ჯდ" # ერთი ლარი უჯდება
		"ღირებ[ა]/ღირ"
		"*·ხდომ[ა]/ხდ"
		"ძახებ[ა]/ძახ"
		"გონებ[ა]/გონ"
		"ჩვენებ[ა]/ჩვენ"
		("ხლებ[ა]/ახლ" MedPass)
		;

# verbs that can have a PRED-ADJUNCT, e.g., ცარიელი დატოვა, ღია დამხვდა
LIST PREDADJVerb = "და·ტოვებ[ა]/ტოვ"
     		   "და·რჩენ[ა]/რჩ"
		   "და·ხვდომ[ა]/ხვდ" ;

# TODO: "და" should only be CLB if it conjoins clauses ;-)
LIST CLBwords = "<:>" "<;>" "<.>" "<?>" "<…>" "რომ[ე]ლ·ი" "როგორც" "მაგრამ" Dash ;
SET CLB1 = ("<,>") | ("<:>") | ("–") | ("<…>") | ("რომ") | ("თუ" Cj Sub) | ("რომ[ე]ლ·ი") ;
LIST EOS = "<.>" "<?>" "<!>" ;

# those starting in @ are added by an ADD rule
LIST @NC = @NC ; # nominal coordination
LIST @CLB = @CLB ; # clause coordination

# how to allow adverbs surrounded by commas (…, მაგალითად, …)? (removed Comma)
SET CLB = CLBwords | (Cj Sub) | @CLB ; # not რომ Compl

SET CLBarg = ("და") | (Cj Sub) | @CLB ; # not რომ Compl

SET CLBsub = CLB1 | Cj ;

# replace by Coord!
LIST COORD = "<და>" "<ან>" "<ანუ>" "<თუ>" "," ;

LIST FUT-ADV = "ხვალ" "ზეგ" "აწ" ;

SET ErgArg3 =    <S:Erg> + S:3 ;
SET ErgArg3Sg =  <S:Erg> + S:3Sg ;


SET NomArg3 =   <S:Nom> + S:3 | <DO:Nom> + DO:3 ;

SET DatArg3 =   <S:Dat> + S:3
              | <DO:Dat> + DO:3
              | <IO:Dat> + IO:3 ;

SET GenArg  =   (<IO:Gen>) ;

LIST S:Erg = <S:Erg> ;
LIST S:Nom = <S:Nom> ;
LIST S:Dat = <S:Dat> ;
LIST DO:Erg = <DO:Erg> ;
LIST DO:Nom = <DO:Nom> ;
LIST DO:Dat = <DO:Dat> ;
LIST IO:Nom = <IO:Nom> ;
LIST IO:Dat = <IO:Dat> ;

SET DoubleDatArg3 = <S-DO-IO> + DO:Dat + DO:3 + IO:Dat + IO:3 ;

# Verbs having Advb arguments
# these and more
LIST AdvbVerb = "თვლ\\[.*"r
     	      "\\*·თვლ\\[.*"r
     	      "ჩა·თვლ\\[.*"r
	      "მი·ჩნევ\\[.*"r
	      "მი·ჩენ[ა]/ჩნ"
	      <AuxIntr>
	      Encl:Aux ;

# defines COMPVerb; list has to be edited more! These are only DO-Comps
INCLUDE comp-verb.cg3 ;

# Sets
# ====

# Noun sets


SET QUAL = N + (Qual) ;

SET Head = NAProp - Att - PP
    	 | Pron + Pers + 3 - PP
    	 | Pron + Rel - PP
	 | Pron + Refl - PP
	 | Pron + Int - PP
	 | Pron + Recip - PP
	 | Pron + Neg - PP
	 | Pron + Indef - PP
	 | Pron + SIndef - PP
	 | Cj + Coord ;

SET NomHead = Head + Nom ;
SET DatHead = Head + Dat ;
SET ErgHead = Head + Erg ;

# ======== #
  SECTION  #
# ======== #

# split off enclitic copula verb
ADDCOHORT ("<_ა>" "ყოფნ[ა]/არ" [0] V MedPass Pres <S> <S:Nom> S:3Sg Encl)
	  AFTER Aux IF (0C Aux) (NOT 1 (Encl)) ;

ADD (@ADDED) (*) IF (NOT 0 (@ADDED)) (1 (Encl)) ;

# MWEs
# … are now treated in the morphology

# LIST MWE = 2:Cj 2:Sub 2:Adv ;

# SELECT MWE ;

# REMCOHORT Adv IF (-1 MWE) ;

# TODO: these readings should be removed in the morphology
REMOVE <S> - (<AuxIntr>) IF (0 (<AuxIntr>)) ;
REMOVE <S-DO> - (<AuxTrans>) IF (0 (<AuxTrans>)) ;
REMOVE <S-DO> - (<AuxTransHum>) IF (0 (<AuxTransHum>)) ;

# Tmesis
# ======

LIST TmesisEncl = Tm:მე Tm:ცა Tm:ღა Tm:ვე Tm:მცა Tm:ძი Tm:რე ; 

REMOVE TmesisEncl IF (NOT 0 (<TmInfix>)) ;

# select name type coming from name@type
SELECT (<Name>) IF (NOT 0 Punct) ;

# test
# REMOVE Nom - Att ;

# remove derivations if they are in the main lexicon

REMOVE (<Der:ულ>) ;
REMOVE (<Der:ელ>) ;
REMOVE (<Der:მაგვარ>) ;
REMOVE (<Der:ებრ>) ;
REMOVE (<Der:ეულ>) ;
REMOVE (<Der:ფერ>) ;
REMOVE (<Der:ნაირ>) ;
REMOVE (<Der:ობრივ>) ;
REMOVE (<Der:სა-ო>) IF (0 A - <Der:სა-ო>) ; # but keep if no A reading in lexicon

# Errors or very rare ones, absolute selects/removes





# n-REMOVE (IterAor) ;
# n-REMOVE (ImpvAor) ;

REMOVE (Rel Encl:მე) ;

select ("სულ") IF (0 (Adv));

SELECT V | Encl:Aux IF (1 ("ხოლმე")) ;

REMOVE ("კურდღ[ე]ლ·ი" Prop) ;

# ხოლო
REMOVE ("<ხოლო>" N) ;
SELECT ("სამყარო" N) ;
remove ("სული/ს" Part) ;
remove ("ბუზ·ი" Prop) ;
REMOVE ("<არა>" N) ;

REMOVE ("<ხართ>" "ხარ·ი") ;
REMOVE ("<ვართ>" "ვარ·ი") ;
REMOVE ("<ერთ>" "ერ·ი") ;
SELECT ("<ერი>" N) ;
SELECT ("<მისა>" "ის") ;
SELECT ("<დავარდა>" V) ;
remove ("<დათა>" "დ[ა]") ;
remove ("<დადო>" "დ[ა]") ;
REMOVE ("პურ[ა]·ჲ") ;
SELECT ("იქ" Adv) ;
SELECT ("ოდენ" Adv) ;
SELECT ("მერმე" Adv) ;
SELECT ("ქვემოთ" Adv) ;
SELECT ("შორს" Adv) ;
REMOVE ("მერმე" V) ;



SELECT ("<გარს>" Adv) ;
# remove ("<ვის>" "ვა") ;
SELECT ("<კიდევ>" Adv) ;
SELECT ("<ისევ>" Adv) ;
SELECT ("<აქა>" Adv) ;
SELECT ("<სავსებით>" Adv) ;
SELECT ("განსაკუთრებით" Adv) ;
SELECT ("საგ[ა]ნ·ი") IF (0 ("საგ[ა]")) ;
REMOVE ("ეს[ე]" N) ;
# SELECT ("ესე" Pron) ;
REMOVE ("<ესე>" V) ;
SELECT ("<ესე>" Adv) IF (1 ("<იგი>")) ;
# om-REMOVE ("<ესე>" Adv) ;
SELECT ("უცებ" Adv) ;
REMOVE ("მი") ;
REMOVE ("ნ[ა]") ;
SELECT ("<ლამის>" Adv) ;
# SELECT ("ყოვ[ე]ლ·ი") ; # ??
SELECT ("ანდა" Cj) ;
REMOVE ("დრო" Old) ;
REMOVE ("იყო" N) ;
REMOVE ("იყო·ჲ" N) ;

REMOVE ("იყ·ი" N) ;
REMOVE ("მი·მართულ·ი/მართ" A Part Pl) ; 
REMOVE ("<დიდი>" V) ;
REMOVE ("<ვ·ი>") ; # ვით
REMOVE ("<მუნ>" N) ;
SELECT ("<თქუენ>" Pron) ; # not V (??)
REMOVE Att + (Encl:IndSp3) ;
REMOVE (Qual) + (Encl:IndSp3) ;
SELECT ("<მეც>" Pron) ;
SELECT ("<ვინ>" Pron) ;
SELECT ("<ესმა>" V) ;
SELECT ("<უკუე>" Adv) ;
SELECT ("შედარებით" Adv) ;
SELECT ("მად[ა]" N) ;
SELECT ("წიგნ·ი") ; # not: წიგნა·ჲ
SELECT ("<ამდენად>" Adv) ;
SELECT ("მაშინვე" Adv) ;
SELECT ("დროებით" Adv) ;
SELECT ("<იმაზე>" Pron) ;
REMOVE ("ბუნ·ი" Pl) ;
SELECT ("მართლაც") ;
SELECT ("<ესე>" Pron) ;



REMOVE ("ვის·ი") ;

SELECT ("ზოგ·ი" A) ;

REMOVE ("საქართველო" <Der:სა-ო>) ;

REMOVE ("ხევ·ი" Prop) ;

SELECT ("წარმო·დგენ[ა]/დგენ" Pres) ; # not Fut

SELECT ("მოედ[ა]ნ·ი") ;
REMOVE ("რამ·ი") ; # = ramie (Bœhmeria nivea)
REMOVE ("რამ[ა]") ; # = med † conjunctivitis
REMOVE ("მეფ[ე]" Prop) ; # King Tamar only
REMOVE ("ხალხ[ა]") ; # stick for harvesting walnuts
REMOVE ("წყლისა") ; # mastitis
REMOVE ("წყლისა·ჲ") ; # mastitis
REMOVE ("<მყავს>" N) ; # მყავი forest dormouse


# o-REMOVE ("მეფის[ა]·ჲ") ; # prelim
REMOVE ("<არს>" Abs) ;
REMOVE ("ამა·ჲ" N) ;
REMOVE ("<შენ>" N) ;
REMOVE ("<შენი>" N) ;
REMOVE ("<დიდის>" V) ;
REMOVE ("<ვიცი>" Iter-II) ;
REMOVE ("სულ·ი/ს" Part) ;
REMOVE ("სობ[ა]/ს" PassState) ; # ესე
REMOVE ("ესე" N) ; # ესე
REMOVE ("ვ[ა]" N) ; # ვითა
# SELECT ("ვის·ი" Pron) ; # but: ვის
REMOVE ("კან·ი" A) ; # Kk a pl “good men”
REMOVE ("როგორ" Rel) ; # remove from morphology!
REMOVE (Int Rel:ც) ; # რომელსაც why is this Int in the first place??
SELECT ("<რათა>" Cj) ;
REMOVE ("რომლ·ი") ;
SELECT ("მუნ") ;
REMOVE ("<გინა>" N) ;
REMOVE ("ვეღარ[ა]" A) ;
REMOVE ("თავ[ა]") ;
REMOVE ("ვითარ·ი") ;
REMOVE ("ერთობ" Adv L);
SELECT ("ვითარცა") ; 
SELECT ("<სადაც>" Rel) ;
SELECT ("ახ[ა]ლ·ი" A) ;
SELECT ("<ამაო>" A) ;
SELECT ("<ასევე>" "ასევე") ;
REMOVE ("<ვერა>" N) ;
REMOVE ("<იყოს>" N) ;
REMOVE ("კაც·ი" A) ;
REMOVE ("<თანა>" L) ;
REMOVE ("<თანა>" N) ;
REMOVE ("ნელ-ნელ" L) ;
REMOVE ("ხელ·ი" A) ;
REMOVE ("ამბავი" Adv) ;
REMOVE ("<ამას>" N) ;
SELECT ("მარტო" Adv) ;
SELECT (".+ისას"r Adv) ; # prefer Adv reading to full analysis
SELECT ("განა" Adv) ;
SELECT ("მალე" Adv) ;
SELECT ("ბოლოს" Adv) ;
SELECT ("არადა" Cj) ;
SELECT ("ეგრევე" Adv) ;
SELECT ("კიდეც" Adv) ;
SELECT ("<ესეც>" Pron) ;
REMOVE ("მართლ" L) ;
SELECT ("<ხელის>" N) ;
SELECT ("ბავშვ·ი" N) ;
SELECT ("გია" Prop) ;
REMOVE ("ისა" N) ;
REMOVE ("ის[ა]" N) ;
SELECT ("<მიდის>" "მი·სვლ[ა]/დი") ;
SELECT ("<მოდის>" "მო·სვლ[ა]/დი") ;
SELECT ("<რომე>" "რომე") ;
SELECT ("<რასაც>" "რ[ა]") ;
SELECT ("<თუმცა>" "თუმცა") ;
SELECT ("<მან>" Pron) ;
REMOVE ("აღდგომ[ა]" Prop) ;
SELECT ("თაობაზე" Pp) IF (-1 Gen) ;
SELECT ("შესახებ" Pp) IF (-1 Gen) ;
SELECT ("თაობ[ა]") ; # not თავობა
SELECT ("კაი") ;
SELECT ("რუს·ი") ;
REMOVE ("წეს[ა]") ;
REMOVE ("მამა" Gen) ;

REMOVE ("წყლ[ა]·ჲ") ;
REMOVE ("<ცა>" V) ;
SELECT ("<ვაშლი>" N) ;
SELECT ("<იგინი>" Pron) ;
SELECT ("<ამის>" "ეს") ;
SELECT ("დაკავშირებით" Pp) IF (-1 PP:თან) ;
SELECT ("ერთად" Pp) IF (-1 PP:თან) ;
SELECT ("განსხვავებით" Pp) IF (-1 PP:გან) ;
# SELECT ("გარეთ" Adv) ;
SELECT ("სწორედ" Adv) ;
REMOVE ("კან·ი" Prop) ;
REMOVE ("ველ·ი" Prop) ;
REMOVE ("ხეობა" Prop) ;
REMOVE ("ხეობ[ა]" Prop) ;
REMOVE ("პირველ·ი" LastName) ;
SELECT ("ერთგან" Adv) ;
SELECT ("როდესაც" Cj) ;
REMOVE ("რაღ[ა]" Rel) ;
REMOVE ("პატ[ა]რ[ა]") ;

SELECT ("ზღვ[ა]" N) ;
REMOVE ("ავლ·ი" Advb) ; # გვერდის ავლად
REMOVE ("ავლ·ი" Inst) ; # გვერდის ავლად

SELECT ("საქმ[ე]·ჲ" N) ;
SELECT ("ესერა" Adv) ;
SELECT ("გორ·ი") ;

SELECT ("მო·კლებულ·ი/კლ") ; # and not მოკლებულ·ი/მოკლ

SELECT ("და·ღლ[ა]/ღალ" Pass) ; # and not და·ღალვ[ა]/ღალ

SELECT ("<ხან>" "ხან") ;
SELECT ("ევროპ[ა]") ;
SELECT ("<უნდოდა>" V) ;
SELECT ("<დღესა>" N) ;
SELECT ("ცხად·ი" A) ;
SELECT ("ადამიან·ი" N) ;
SELECT ("ღმ[ე]რთ·ი" N) ;
SELECT ("დონ[ე]" N) ;
SELECT ("მამ[ა]" N) ; # prefer over მამა
SELECT ("დედ[ა]" N) ;
SELECT ("დიდედ[ა]" N) ;
SELECT ("დედ[ა]·ჲ" N) ;
SELECT ("მამ[ა]·ჲ" N) ;
SELECT ("დიდედ[ა]·ჲ" N) ;
REMOVE ("აქვ·ი" N) ;
SELECT ("<აქა>" "აქა") ;
SELECT ("<ოდეს>" Adv) ;
SELECT ("გენაცვალე" Interj) ;
SELECT ("ვენაცვალე" Interj) ;
SELECT ("ორ·ი" Num) ; # ორად
SELECT ("კაც·ი") ; # კაცო
SELECT ("ზემოთ") ; # ზემოდ
SELECT ("თუნდა") ;
SELECT ("თანაც") ;
SELECT ("ბოლო") ;
# SELECT ("<მერმე>" Adv) ;
SELECT ("ახლოს" Adv) ; # should remove Pp reading altogether: ჩემთან ძალიან ახლოს
#SELECT ("ახლოს" Adv) IF (NOT -1 PP:თან) ;
#SELECT ("ახლოს" <PP:თან>) IF (-1 PP:თან) ;
SELECT ("<უნდოდა>" V) ;
SELECT ("კიდევაც") ;
SELECT ("გაცილებით" Adv) ;
SELECT ("<მეტიც>" Adv) ;

SELECT ("ამასთანავე") ;

SELECT (Pron Pers PP) ; # შვენში etc.
SELECT ("თბილის·ი" Prop) ;
SELECT ("ერთ-ერთ·ი" A) ;
SELECT ("ერთხელ" Adv) ; # not ერთხელ·ი
SELECT ("ერთად" Adv) ; # not ერ·ი
SELECT ("წყალქვეშა" A) ;
SELECT ("ნაპირ·ი" N) ; # not *ნაპირ·ი
SELECT ("საყუარ[ე]ლ·ი") ;
REMOVE ("ი·ი") ; # not sure where these come fromბ
REMOVE ("ო·ი") ;
SELECT ("<იამა>" V) ;
REMOVE ("მისგან·ი" A) ;
REMOVE ("აღორძინებ[ა]" Prop) ; # but not in სამუსლიმო ს.!
REMOVE ("შემო·სავლებ·ი/ვლ" Part) ;

REMOVE ("ერ[ა]·ჲ") ;
SELECT ("ნაშუაღამევს" Adv) IF (NOT -1 A + Dat + Att) ;
SELECT ("არყ·ი") IF (1 ("ხ[ე]")) ; # not არაყი
SELECT ("ლარ·ი") ;
SELECT ("მკვეთრ·ი") ; # remove this!

SELECT ("მისტერი[ა]") ; # not მისტერ-ი

REMOVE ("ბუ") IF (0 ("ბუღ[ა]")) ;

SELECT ("გამო·წვდ[ა]/წოდ") IF (0* ("ხელ·ი") BARRIER CLB) ;
SELECT ("გა·წვდ[ა]/წოდ") IF (0* ("ხელ·ი") BARRIER CLB) ;

# შეუწყოს ხელი
SELECT ("შე·წყობ[ა]/წყ") IF (0* ("ხელ·ი") BARRIER CLB) ;

SELECT ("გა·სმ[ა]/სვ" Act) IF (0* ("ხაზ·ი") BARRIER CLB) ;



REMOVE ("ბებია" LastName) ;
REMOVE ("ბაბუა" LastName) ;
REMOVE ("ბაბუ[ა]" Prop) ;

REMOVE ("გალი[ა]" Prop) ;

# could precede A, but have to avoid შემდეგ_A ოდნავ_A განე გადგა
REMOVE ("შემდეგ·ი" A) IF (NOT 1 N) ;

REMOVE ("აღ·ელვებ\\[ა\\].*"r) ; # ა·ღელვება; difficult to remove from morphology





REMOVE ("ნათელ·ი/თელ" Part) ; # ნათელი

REMOVE ("შიშ·ი" Prop) ;

SELECT Gen + (PP:ვით) ; # not Dat

SELECT Gen + (PP:დმი) ;

SELECT Dat + (PP:თვის) ; # not Gen if Dat available (ვისთვისაც) 

SELECT ("ვიდრე" Pp) IF (1 PP:მდე) ;

REMOVE ("თვალებ[ა]/თვალ") + N IF (0 ("თვალ·ი")) ;

REMOVE ("ქალ[ა]") ; # ქალის

REMOVE ("გაზ[ა]") ; # გაზის

SELECT ("მორფინ·ი") ; # and not მორფი

SELECT ("ცემ[ა]/ცემ") IF (-1 ("პატივ·ი")) ;

SELECT ("ბალ·ი") IF (-1 Num + Card) ;

SELECT ("<ესმოდა>" "სმენ[ა]/სმ") ; # not "*·სმ[ა]/ს"

SELECT ("აღიარებ[ა]/ღიარ") ; # not აღვლა

SELECT ("რთულ·ი" A) ; # not Part

SELECT ("იესუ" Abs) IF (1 ("ქრისტე")) ;

REMOVE ("მათგან·ი" Abs) ;



# იყო-მცა. Exceptions?
REMOVE ("<.*-მცა>"r VComp) ;

# რქმა is rare
SELECT ("რქმევ[ა]/რქვ") ;

SELECT ("სმენ[ა]/სმ" Inv) ; # მესმის etc.

# ?


SELECT ("შენ" Pron Pers) IF (-1 Pp) ;

SELECT ("შალვა" Anthr) ;

SELECT ("<უფალო>" N) ;

SELECT ("<ჩვენთან>" "ჩვენ") ;

SELECT ("<მისმა>" Pron) IF (1 Erg) ;

REMOVE ("ძველ·ი" Prop) ;

REMOVE ("მთელ·ი" N) IF (NOT -1 Num + Card) ;

SELECT ("თვით" Adv) IF (NOT -1 Num) (1 NA) ;

SELECT ("პროვოცირებ[ა]/პროვოცირ" VN) ;

SELECT ("მეტ·ი" A) ;

#SELECT ("მეტ·ი" A) IF (-1 ("უფრო")) ;
#SELECT ("მეტ·ი" A) IF (1 ("ვიდრე")) ;

SELECT ("ნაკლებ·ი") ; # refine!

SELECT ("აქ") IF (1 ("და")) ;

SELECT ("ხევ·ი") IF (-1 Prop + Gen) ;

SELECT ("მისიან·ი") ;

# more such?
SELECT ("მდგარ·ი/დგ" A) IF (-1 PP:ზე) ; # not N

SELECT ("ბოლო" N)
    IF (-1 Gen)
       (NOT 1 N) ;

# m-REMOVE Att ;



REMOVE ("<მათ>" Abs) ;

REMOVE (Encl:ც) ;

SET NegPlain = ("არ") | ("ვერ") | ("ნუ") ;

REMOVE ("რა" Interj)
        IF (1 V | NegPlain | CASE) ;

# should better be Adv Disc or Sent?
SELECT ("რა" Interj)
       IF (-1 Comma)
       	  (1 Comma) ;

# არა იცის რა




# not sure about OG
REMOVE ("რა" SIndef) ;

SELECT Elat IF (-1 ("<მით>")) ;

SELECT ("ცოტა" A)
    IF (1 ("არ"))
       (2 ("<იყოს>")) ;

# Adv/Part disambiguation
# ------------------------











# Adv/A/Pron/N disambiguation
# ------------------------

SELECT Adv + DegNum
    IF (1 Num) ;
REMOVE Adv + DegNum
    IF (NOT 1 Num) ;

# შედარებით დაბალი
SELECT Adv + Deg
    IF (1 A) ;

REMOVE ("ერთმანეთზე") IF (NOT -1 Temp) ;

SELECT ("დღ[ე]") + N + $$CASE
    IF (-1 ADemNum + $$CASE) ;

# -ად Adv vs. A Dat Att
#n-REMOVE ("<.*ად>"r) + A + Att + $$CASE
#    IF (0 Adv)
#       (NOT 1 $$CASE) ;









# too general?
SELECT ("მის·ი" Pron Poss) - Abs IF (-1 N) ;

# focus adverb
SELECT ("<თვით>" Adv) IF (1 CASE) ;

SELECT Adv + Sent IF (1 Comma) (-1 BOS) ; 
REMOVE Adv + Sent IF (NOT 1 Comma) ; 

SELECT ("თუნდა" Cj) IF (1 Opt) ;
SELECT ("თუნდა" Cj) IF (1 Neg) (2 Opt) ;
SELECT ("თუნდ" Cj) IF (1 Opt) ;
SELECT ("თუნდ" Cj) IF (1 Neg) (2 Opt) ;

# expand
REMOVE ("ძველ" Adv) IF (1 DatAdv) ;
REMOVE ("ერთ" Adv) IF (1 DatAdv) ;
REMOVE ("პირველი" Adv) IF (1 NomGenInst) ;

REMOVE ("ერთი" Adv) IF (1 NomGenInst) ;

# ეს can be Adv in ეს არის
REMOVE ("<ეს>" Adv) IF (NOT 1 ("<არის>")) ;

REMOVE ("ერთ-ერთ·ი" Num Card) ;

SELECT ("დღემდე" Adv)
    IF (NOT -1 Advb) ;

# suppress 175 -> 1-75 etc.
REMOVE (Range) ;

# Adv/Advb disambiguation
# ------------------------

REMOVE Advb
    IF (NOT 0 Trunc)
       (NOT -1 Advb + Att)
       (NOT 1 Advb)
       (0 Adv) ;

REMOVE N + Advb
    IF (0 A + Advb - Old)
       (NOT -1 PREP + <Advb>)
       (NOT 1 POSTP + <Advb>)
       (NEGATE 0* AdvbVerb BARRIER CLB) ;

REMOVE A + Advb + Old
    IF (0 N + Advb - Old) ;

# Pron/Dem disambiguation
# ------------------------

REMOVE Dem + $$CASE
       IF (NOT -1 $$CASE)
	  (NOT 1 $$CASE) ;

SELECT Dem + $$CASE + $$NUMBER
       IF (-1 $$CASE + $$NUMBER) ;

# Reflexives

SELECT ("თავ·ი" Pron) + $$CASE IF (1 ("თჳს·ი" Refl) + $$CASE) ; 
SELECT ("თჳს·ი" Refl) + $$CASE IF (-1 ("თავ·ი" Pron) + $$CASE) ; 

SELECT ("თავის·ი" Refl) + $$CASE IF (1C $$CASE) ; 
SELECT ("თავის·ი" Refl) + $$CASE IF (1 Quote LINK 1C $$CASE) ; # თავისი „სტილით”




SELECT ("თავ·ი") + N + $$CASE
    IF (-1 ADemNum + $$CASE) ;

SELECT ("თავ·ი") + N + $$CASE
    IF (1C ADemNum + $$CASE) ;

# დამიდგა თავზე
SELECT ("თავ·ი") + N + PP:ზე
    IF (0* ("და·დგომ[ა]/დგ") BARRIER CLB) ;

SET TaviNVerb = ("და·ნებებ[ა]/ნებ") | ("გა·ქნევ[ა]/ქნ[ევ]") ;







# Names
# ------------------------

# აფხაზები
REMOVE (LastName Pl) ;

# ქართველი





LIST TOWN = "ქალაქ·ი" "სოფ[ე]ლ·ი" ;

SELECT Place IF (-1 TOWN) ;
SELECT ("<ქ.>" "ქალაქ·ი") IF (1 (Place)) ;
SELECT ("<წ.>" "წელთაღრიცხვ[ა]") IF (-1 ("<ძვ.>") ) ;
SELECT ("<წ.>" "წელთაღრიცხვ[ა]") IF (-1 ("<ჩვ.>") ) ;
SELECT ("<წ.>" "წელთაღრიცხვ[ა]") IF (-1 ("<ახ.>") ) ;
SELECT ("<ქ.>" Anthr) IF (1 Anthr) ;
SELECT ("<წ.>" Anthr) IF (NOT -1 (Card Digits)) ;

INCLUDE place-head.cg3 ;

SELECT Place + Gen IF (1 PlaceHead) ;

SELECT ("<იესუ>" Abs) IF (1 ("ქრისტჱ")) ;





REMOVE ("სულ·ი" A) ;
SELECT ("სულ·ი" N) ;
REMOVE ("გულ·ი" A) ;
REMOVE ("ენ·ი") ;

REMOVE ("ცოტა" A) ; # ცოტა is Quant

REMOVE ("<ხარ>" "ხარ·ი") ;
REMOVE ("განა" Prop) ;
# remove ("მთელ·ი" A) ; # should only be ALLQ

# REMOVE (AInt C) ;
# REMOVE ("იქნებ" L) ;

select ("სახელ·ი" N) ;

# SELECT ("ყოფნა") ;

REMOVE ("ს·ი") ;
REMOVE ("<ზოგი>" Adv) ;
SELECT ("<არის>" V) ;
SELECT ("<უფრო>" Adv) ;
SELECT ("<გამო>" "გამო") ;
SELECT ("<თავიანთ>" "თავიანთ·ი") ;
REMOVE ("მ·ი") ;
REMOVE ("მა") ;
REMOVE ("<კაცი>" Inst) ;
REMOVE ("ზედ" Mann) ;
REMOVE ("<ზედ>" A) ;
SELECT ("<გაათავე>" V) ;
REMOVE ("<იქნება>" Adv) ;
REMOVE ("პირველი" Adv) IF (NOT 1 Comma) ;
REMOVE ("პირველი" Adv) IF (NOT -1 BOS) ;

SELECT ("ქონებ[ა]") ;

# should this be a MWE?
SELECT ("უპირველეს" Adv)
    IF (1 ("<ყოვლისა>")) ;

SELECT ("სანამ" Cj) ;
SELECT ("<რომ>" Cj)
    IF (-1 Comma) ;

REMOVE (Rare) ;

REMOVE (Imperfective) ;

SELECT ("დღეს" Adv)
    IF (NEGATE 0* DatArg3 BARRIER CLB) ;
SELECT ("დღეს" Adv)
    IF (0* NACDemPropPron + Dat BARRIER CLB) ;

SELECT ("დაახლოებით" Adv)
    IF (1 Num) ;

# შვიდი დღე
SELECT ("<დღე>" N) + $$CASE
    IF (-1 Num + Card + $$CASE) ;

# prelim.
#n-SELECT (Gen L) ;

SELECT (Gen L)
       IF (1C Gen) ;

# წმიდისა იოვანე ოქროპირისაჲ
SELECT (Gen L)
       IF (1 Anthr + Abs)
       	  (2 Gen) ;

# კარგად
SELECT ("კარგ·ი" A Advb Sg) ;
SELECT ("ცუდ·ი" A Advb Sg) ;

SELECT ("ერთ·ი" A Gen) if (1 ("მხრივ" Pp)) ;

SELECT (N Temp)
    IF (-1 (Card Digits)); 

REMOVE (V Encl:რა) ;
REMOVE (V Encl:მდა) ;

# Early and popular rules

# არ, ნუ, ვერ, etc., but not არც, ...





SELECT V if (-1 Neg) (NOT -1 (Encl:ცა)) ;

# necessary?
SELECT Neg if (1 V) ;

SELECT Neg if (-1 ("თუ")) ;

SELECT ("ოღონდ" Coord) ; # prelim

SELECT ("<არა>") + Adv + Neg IF (-1 ("ოღონდ")) ;

# ვერც ერთი
SELECT (Neg Encl:ც) IF (1 ("ერთ·ი")) ;
SELECT ("ერთ·ი") IF (-1 (Neg Encl:ც)) ;

# , თუ ვინ/ვისი/სად…
#n-SELECT ("თუ") + Cj + Sub
#    IF (-1 BOP)
#       (1 Int);

# refine this!




# არც თუ ისე




# missing: conditions for თუ adv













# და, თუ…







# … თუ არა
































# V თუ არა; is MWE now (no longer!)
#SELECT ("თუ" Cj)
#    IF (-1 V)
#       (1 ("<არა>"));

# old
#SELECT ("<არა>" Neg)
#    IF (-2 V)
#       (-1 ("თუ")) ;

# only works with keep-non-mwe-readings = T
SELECT ("თუ") + Cj + Sub
    IF (-1 BOP)
       (1 ("<არა>")) ;

SELECT ("<არა>" Adv Neg)
    IF (-2 BOP)
       (-1 ("თუ")) ;

SELECT (Adv Neg)
    IF (1 V) ;





SELECT ("ის" Pron)
    IF (1 Comma)
       (2 ("რომ")) ;

# very heuristic condition
SELECT ("თითქოს" Cj) IF (-1 Comma) ;

REMOVE ("თითქოს" Cj) ;









# მე და ჩემს დას
























# corrdinate equal POS








TEMPLATE NPDat = ? Dat - Att - PP - Cj LINK NOT 1 Pp ;
TEMPLATE NPDatHum = ? Dat + Hum - Att - PP - Cj LINK NOT 1 Pp ;

REMOVE Dat
    IF (0 Gen - <OldPl>)
       (1 N)
       (NOT 1 Dat)
       (NEGATE -1* V BARRIER CLB)
       (1C* T:NPDat BARRIER CLB OR V) ;

REMOVE NA + Dat - Att - Temp
    IF (0 Gen - <OldPl> - L)
       (1 N)
       (NEGATE 0* V + DatArg3 BARRIER CLB) ;

# select MWEs elsewhere

SELECT (MWE) ;
SELECT (<MWE>) ;

# არა V რა
#…

# mn-SELECT ("<რა>" Adv)
#      IF (-1 V) (-2 ("<არა>")) ;

REMOVE Meas
    IF (NOT 1 NA) ;

SELECT Meas
    IF (1 Money) ;

REMOVE Meas
    IF (1 Anthr) ;

REMOVE Neg
       IF (NOT 1 V)
       	  (NOT 1 Neg) # Neg chain
       	  (NOT 0 Aux)
	  (NOT 0 Pron) ; # მეტი არაფერი

SELECT Adv + Neg IF (1C V) ;





REMOVE (V) if (1C Neg) ;

REMOVE ("არა" N Nom Sg) ;

REMOVE ("კაი" Prop) ;

REMOVE ("<კარი>" "კვრა" V) ;

# სხვა ვინმე/რამე
SELECT ("სხვ[ა]" Att) IF (1 Pron + SIndef) ;

# check this. what is Compl exactly?
SELECT Compl ; # IF (NOT -1 BOP);
REMOVE Compl IF (-1 BOP) (1 V);
REMOVE Compl IF (-1 BOP) (1 Neg) (2 V);

# First/Last name
















SELECT Anthr + Abs
    IF (1 LastName) ;

SELECT Anthr + Abs
    IF (1 ("ოქროპირ·ი")) ;

REMOVE Dem + Att IF (NOT 1 NOM) ;

REMOVE Dem IF (1 NegPart + Nom OR PastPart + Nom LINK 1 PREDVerb) ;

REMOVE ("პატარა" Adv) IF (NOT 1 V) ;

SET CommaDot = Comma | (".") ;
SET CommaDa = Comma | ("<და>") ;

# SELECT ("კი" Adv) IF (1 CommaDot) ;
SELECT ("კი" Disc) IF (1 ("არა")) ;
SELECT ("კი" Disc) IF (-1 N) ;
SELECT ("კი" Disc) IF (NOT 1 CommaDot) ;
SELECT ("კი" Disc) IF (1 CommaDot) ;

SELECT ("<ძალიან>" Adv) ;
SELECT ("<ისე>" Adv) ;




SELECT ("რომ[ე]ლ·ი" Pron Rel) IF (NEGATE 1* IntMark BARRIER CLB) ;

# but: რომელ სკოლაშიც…!
# SELECT ("რომ[ე]ლ·ი" Pron Rel) ;
#SELECT ("რომ[ე]ლ·ი" Pron Rel Gen) IF (1 (Encl:ც)) ;



REMOVE ("რ[ა]" Att) IF (1 V OR Neg) ;


SELECT ("რ[ა]" Int) IF (1 V OR Neg) ;
SELECT ("რა" SIndef) IF (-1 V) ;

# not int
SELECT Pron + Poss + Rel + Att + $$CASE
    IF (1 $$CASE + Encl:ც) ;

# რა თქმა უნდა
SELECT ("უნდა")
    IF (-2 ("რა"))
       (-1 ("<თქმა>")) ;

SELECT ("რ[ა]" Int)
    IF (1 ("<თქმა>"))
       (2 ("უნდა")) ;

SELECT ("რ[ა]" Int Nom)
    IF (-1 ("<მერე>"))
       (1 Comma OR IntMark) ;

SELECT Rel IF (0 SIndef) ;

# ის, რაც








SELECT Int IF (-1 ("<თუ>")) ;
SELECT Int
    IF (-1 Coord)
       (-2 Int) ;

SELECT Voc
    IF (-1 Comma OR Dash OR BOS) (1 ExclPoint) ;

#SELECT Voc
#    IF (-1 BOS) (1 ExclPoint) ;


# remove Voc homonymous with Nom

REMOVE Voc
    IF (0 Nom)
       (NOT 0 (Encl:IndSp3))
       (NOT 1 (ExclPoint))
       (NOT 1 Voc)
       (NOT -1 Voc)
       (NEGATE -1 Comma LINK 2 IntMark) # რაო, გოგო? Find way to remove Nom in this context! (See next)
       (NEGATE -1 Comma LINK -1 Voc) ;

SELECT Voc
    IF (-1 Comma OR Dash OR BOS) (1 IntMark) ;

# ბატონო თავმჯდომარევ
SELECT Voc + Att
    IF (1 Hum + Voc) ;

SELECT (Hum) IF (0C Voc) ;





# იმ შემთხვევაში თუ
















SELECT ("<იქნებოდა>" "ყოფნა") ;

SELECT ("<ხანია>" Temp)
       IF (-1 ("<კარგა>") OR ("<დიდი>")) ;

# ხან … ხანაც
SELECT ("ხან" Adv) IF (1* ("ხანაც")) ;
SELECT ("ხან" Foc) IF (-1* ("ხან")) ;

# არც კი
SELECT ("კი" Adv) IF (-1 ("არც")) ;

# რაც გინდ(ა)
SELECT ("რაც" Cj)
    IF (1 ("გინდ")) ;

# should be Cj Compar, and Adv Deg
SELECT ("როგორც" Cj) IF (-*1 ("ისევე")) (-1 Comma) ;

# როგორც წესი
SELECT ("როგორც" Adv) IF (1 N) (2 Comma) ;

# როგორც … ისე
SELECT ("<როგორც>" Adv) - Rel
    IF (1* Comma LINK 1 ("ისე" Adv)) ;

SELECT ("<როგორც>" Cj Sub)
    IF (1 V) ;

SELECT ("<ერთი>" Nom) IF (-1 ("<ჯერ>")) ; # should be MWE?

# barrier?
SELECT ("<ვიდრე>" Compar) IF (-1* (Adv Deg)) ;
# SELECT ("<ვიდრე>" Compar) IF (-1* ("<უფრო>")) ;

SELECT ("<ვიდრე>" Compar) IF (NEGATE 1* V BARRIER CLB) ;

SELECT ("მეტ·ი") + Att + $$CASE
    IF (1 NA + $$CASE) ;

# move to later
# REMOVE (VPart);
# REMOVE (Old);
REMOVE (ConjPerf) ;
# REMOVE (Cond) ;
# REMOVE (Dialect) ;
# REMOVE (NonStand) ;






# nominal coordinations
SELECT ("და" Cj)
      IF (-1 Gen + OldPl)
	 (1 Gen + OldPl) ;

ADD @NC ("და" Cj) - @NC
      IF (-1 Gen + OldPl)
	 (1 Gen + OldPl) ;

SELECT ("და" Cj)
      IF (-1 Gen + L)
	 (1 Gen) ;

ADD @NC ("და" Cj) - @NC
      IF (-1 Gen + L)
	 (1 Gen) ;

ADD @NC ("და" Cj) - @NC
      IF (-1 Dat + L)
	 (1 Dat) ;

# this is a bit dangerous
ADD @NC ("და" Cj) - @NC
      IF (-1 Nom)
	 (1 Nom) ;

SELECT ("და" Cj) IF (NOT 1 (Poss Nom));

ADD @CLB ("ოღონდ")
    IF (NEGATE 0 @CLB) ;

# add more!
ADD @CLB Cj + Coord - @CLB - @NC
    IF (NEGATE 0 @CLB)
       (-1C Dat)
       (1C Nom) ;

ADD @CLB Cj + Coord - @CLB - @NC
    IF (-1*C V BARRIER CLB)
       (1*C V BARRIER CLB)
       (NEGATE -1 V LINK 1 ("თუ") LINK 1 Neg) # თუ არა
        ;

# might be comma before Cj
ADD @CLB Cj + Coord - @CLB - @NC
    IF (-2*C V BARRIER CLB)
       (1*C V BARRIER CLB) ;

ADD @CLB Comma - @CLB - @NC
    IF (1 ("რომ")) ;

ADD @CLB Comma - @CLB - @NC
    IF (-1 V) ;

ADD @CLB Colon - @CLB - @NC
    IF (-1 V) ;

SELECT ("რა" A) IF (NOT 1 V);

REMOVE ("დროს" Pp) ;
REMOVE ("მის·ი" Prop) ;
# REMOVE ("ერთ·ი") ;

REMOVE ("შენ" Poss Dat)
    IF (NOT 1 Dat);
REMOVE ("ჩვენ" Poss Dat)
    IF (NOT 1 Dat);
REMOVE ("თქვენ" Poss Dat)
    IF (NOT 1 Dat);

SET Dat2SgArg = DO:Dat + DO:2Sg | IO:Dat + IO:2Sg ;
SET Dat1PlArg = DO:Dat + DO:1Pl | IO:Dat + IO:1Pl ;
SET Dat2PlArg = DO:Dat + DO:2Pl | IO:Dat + IO:2Pl ;

REMOVE ("შენ" Pron Dat)
    IF (1 Dat)
       (NEGATE 0* Dat2SgArg) ;

REMOVE ("ჩვენ" Pron Dat)
    IF (1C Dat)
       (NEGATE 0* Dat1PlArg) ;

REMOVE ("თქვენ" Pron Dat)
    IF (1 Dat)
       (NEGATE 0* Dat2PlArg) ;

# შე სასიკვდილე
SELECT Voc
    IF (-1 ("შენ") + Pron + Voc) ;

# elaborate! შორის and not შორი

REMOVE ("შორის" Pp) IF (NOT -1 Dat) (NOT 1 Dat);
REMOVE ("<შორის>" "შორის·ი") ;









REMOVE Interj if (NEGATE 1* ExclPoint BARRIER CLB) ;

# Postposition case agreement

SELECT ("<ზედა>" Pp)
      IF (-1 Gen OR Dat) ;

SELECT Gen IF (1 POSTP + <Gen>) (0C N) ;
SELECT Dat IF (1 POSTP + <Dat>) ;
SELECT DatGen IF (1 POSTP + <Dat/Gen>) ;
SELECT Inst IF (1 POSTP + <Inst>) ;
SELECT Advb IF (1 POSTP + <Advb>) ;

SELECT POSTP + <Gen> IF (-1C Gen) ;
SELECT POSTP + <Dat> IF (-1C Dat) ;

SELECT POSTP + <Dat/Gen> IF (-1C DatGen) ;
SELECT POSTP + <Inst> IF (-1C Inst) ;
SELECT POSTP + <Advb> IF (-1C Advb) ;



# test
#SELECT POSTP + <Gen>
#    IF (-1 Gen)
#       (-1 Dat)
#       (NOT -1 V) ;

SELECT PREP + <Gen> IF (1 Gen) ;
SELECT PREP + <Dat> IF (1 Pron + Dat) ; # first try prep wanting Dat
SELECT PREP + <Gen> IF (1 Pron + Dat) ; # but pronouns may be in Dat for Gen-selecting preps
SELECT PREP + <Advb> IF (0C PREP) (1 Advb) ;
SELECT PREP + <Inst> IF (1 Inst) ;

# real postpositions
REMOVE  POSTP IF (NOT -1 CASE) ;

REMOVE  POSTP + <Gen> IF (NOT -1 Gen | Pron + Pers + Dat) ;
REMOVE  POSTP + <Dat> IF (NOT -1 Dat) ;
REMOVE  POSTP + <Dat/Gen> IF (NOT -1 Dat) (NOT -1 Gen) ;
REMOVE  POSTP + <Inst> IF (NOT -1 Inst) ;
REMOVE  POSTP + <Advb> IF (NOT -1 Advb) ;





SELECT ("უფრო" Adv) IF (1 A | Adv) ;

# o-SELECT ("ვიწრე" Cj) IF (1 (PP:მდე)) ;

# Modal უნდა : select უნდა before Opt/ConjPres/PluPerf
# ------------------------

# but not: გახდა შესაძლებელი
SET MODAL = Modal
    	    | ("შე·საძლო/ძლ") + Aux
    	    | ("შე·საძლებ[ე]ლ·ი/ძლ") + Aux
    	    | ("შე·უძლებ[ე]ლ·ი/ძლ") + Aux
    	    | ("შე·ძლებ[ა]/ძლ") + Aux
	    | ("შეუძლო") + Aux ;

SELECT Modal IF (1* OPT BARRIER CLB) ;
SELECT Modal IF (1 Neg) (2 OPT) ;
SELECT Modal IF (-1 OPT) ;

SELECT OPT IF (-1* MODAL BARRIER CLB) ;
# SELECT OPT IF (-1* Modal BARRIER CLB) ;
# select OPT IF (-1 Modal) ;
SELECT VN IF (1 Modal) ;

SELECT OPT IF (-1* ("რომ") BARRIER CLB LINK -1 ("ნდომ[ა]/ნდ")) ;
SELECT OPT IF (-1* ("რომ") BARRIER CLB LINK -1 Comma LINK -1 ("ნდომ[ა]/ნდ")) ;

LIST SUBJ = S:1 S:1Pl S:1Sg S:2 S:2Pl S:2Sg S:3 S:3Pl S:3Sg ;

# შეგიძლიათ დაჭრათ
SELECT ("შე·ძლებ[ა]/ძლ") + $$SUBJ
    IF (1* OPT + $$SUBJ BARRIER CLB) ;

SELECT OPT + $$SUBJ
    IF (-1* ("შე·ძლებ[ა]/ძლ") + $$SUBJ BARRIER CLB) ;

# უნდა, რომ
SELECT ("<უნდა>" V)
    IF (1 Comma)
       (2 ("რომ")) ;

# unpersonal უნდა
SELECT Modal
    IF (NEGATE 0* Dat BARRIER CLB)
       (NEGATE 1 Comma LINK 1 ("რომ")) ;

# but: ამის მიზეზი etc.
# only before PPs?
#n-REMOVE (Pron Pers Gen)
#       IF (NOT 1 POSTP) ;

# more with OPT?
SELECT OPT
       IF (-1* ("<რათა>") BARRIER Comma) ;

SELECT ("გონებ[ა]/გონ") + DO:3
    IF (1 Comma)
       (2 ("თითქოს")) ;

SELECT ("სმენ[ა]/სმ")
    IF (1 Comma)
       (2 ("რომ")) ;

# N/A disambiguation
# ------------------------

SELECT A + $$CASE + Sg
    IF (1 COORD)
       (2C A + $$CASE + Sg) ;

SELECT A + $$CASE + Att
    IF (0C A)
       (1 COORD)
       (2C $$CASE + Att) ;

SELECT A + $$CASE + Att
    IF (0C A)
       (1 Comma)
       (2 ("არამედ"))
       (3C $$CASE + Att) ;

# add more conditions for removal of Att reading






















      # (NEGATE 1 Comma LINK 1 A + Nom) ; # COORD contains Comma







# N/VN disambiguation: always select VN
# ------------------------

# valid only if both have same lemma, wich is difficult to check
# REMOVE (N) IF (0 (VN));
# Adjective/Noun disambiguation
# ------------------------

# SELECT N IF (0 A) (NOT 1 NOM);

# prefer N in Pl
SELECT N + Pl - VN IF (0C N OR VN) (0C Pl) ;

# choose N/Prop between N/Prop Full and A Full, not Advb
#remove A - Att if (NOT 0 Att | (Advb));

REMOVE Prop + $$CASE
    IF (-1 INDEF + $$CASE) ;

# თევდორაანთ მელანო
SELECT FirstName
    IF (-1 (Coll) + Gen) ;

# proper nouns normally have no genitive attribute
# refine!
REMOVE Prop
    IF (-1C Gen) ;

# more local PPs?
REMOVE N + Anthr OR Hum + (PP:ში)
    IF (0 Prop + Top + (PP:ში)) ;

SELECT ("ხელა" A) IF (-1 Gen) ;

# Att disambiguation
# ------------------------

TEMPLATE NPGen = (? NA + Gen) OR (? NA + Gen + Att LINK 1 T:NPGen) ;

# missing: intervening PP or ADV
REMOVE Att
    IF (NOT 1 NACDemProp)
       (NOT 1 T:NPGen)
       (NOT 0 Anthr LINK 1 (Ord Roman))
       (NOT 1 ("და" Cj) | (",")) ;

SELECT Att + Erg
    IF (1C Erg) ;

SELECT Att + Gen
    IF (1C Gen)
       (0C A) ;

SELECT Att + Gen
    IF (NOT 1 ("და" Cj))
       (1 Advb)
       (2C Gen) ;

# can go wrong if 0 is Adv?
SELECT Att + Nom
    IF (1C Nom - Pron)
       (NOT 0 Cj)
       (NOT 1 Aux)
       (NOT 2 AUX) ;

# ვახტანგ IV
SELECT Att + $$CASE
    IF (0 Anthr)
       (1 Ord + Roman + $$CASE) ;

# REMOVE (ALLQ) + Att + $$CASE
#    IF (NOT 1 NADemProp + $$CASE) ;

# მთებ შუა; are there other possibilities?
remove (Dat Pl) + Att IF (NOT 1 ("<შუა>"));

# Attributive Genitive

REMOVE V
    IF (0 VN)
       (-1C Gen - (L)) ;

# Adv vs. N + Pp etc.




# Case congruence rules
# ------------------------

SELECT (A Advb) IF (-1 (N Advb)) ;

SELECT ("თჳს·ი" Poss) + $$CASE
       IF (-1 N + $$CASE) ;

SELECT (Pron Poss) + $$CASE - Abs
       IF (1 N + $$CASE) ;

SELECT (Pron Poss Advb Trunc)
       IF (1 (N Advb)) ;

REMOVE (Encl:IndSp3) IF (0 Voc) (1 Voc) ;

SELECT Pron + Dem + $$CASE - Nom
    IF (1C $$CASE) ;

REMOVE Pron + Dem + $$CASE
    IF (1 PP)
       (NOT 1 $$CASE) ;

# change to Adv NMod
SELECT Pron + Dem + $$CASE
    IF (1 ("ვითომდა"))
       (2C $$CASE) ;









#n-SELECT Pron + Att + Nom OR Pron + Dem + Nom OR Pron + Pers
#    IF (1C Nom) ;

# ისეთმა ხალხმა
# ამის მეტს
# aber: ეს კაცი!!
#n-SELECT Pron + Att + $$CASE OR Pron + Dem + $$CASE OR Pron + Pers
#    IF (1C $$CASE) ;

# Prop, or better Anthr?
SELECT QUAL + $$CASE
    IF (1 Anthr + $$CASE)
       (NOT 0 ("<და>"))
       (1C N) ;

REMOVE ("ქართველ·ი" Prop) ;

SELECT Anthr + $$CASE
    IF (-1 QUAL + $$CASE) ;

REMOVE QUAL
    IF (1 Comma) ;

SELECT Qual + $$CASE
    IF (1 Quote)
       (2 Prop + $$CASE)
       (3 Quote) ;

SELECT DDat IF (-1C Dat) ;

# correct? სახარებასა სასუფეველისა ღმრთისასა
SELECT DDat IF (-1C Gen) (-2C Dat) ;

REMOVE (DDVoc) ;

### guessing rules for qualified unrecognized words (ბატონი XYZ)

SET PlaceQual = ("<ქალაქ>") | ("<ქ.>") | ("<სოფელ>") ;

SET HydrQual = ("<მდინარე>") | ("<ტბა>") ;

SET TitleQual = ("ბატონ·ი") | ("ქალბატონ·ი") | ("ამხანაგ·ი") | ("მინისტრ·ი")
    	      | ("ცოლ·ი") | ("ქმ[ა]რ·ი") | ("მეუღლ[ე]")
    	      | ("წმიდ[ა]") | ("<წმ.>") | ("ნეტარ·ი") | ("მამ[ა]") | ("მოწამ[ე]")
	      | ("მცველ·ი")
	      | ("<.*ისტ>"r)
	      | ("<მაესტრო>") ;

SET OrgQual   = ("კლუბ·ი") | ("კომპანი[ა]") ;

SET LastNameRus = (".*სკი"r) | (".*იჩ·ი"r) | (".*ოვ·ი"r) | (".*ევ·ი"r) ;
SET LastNameGeo = (".*(ა|ი)ძ\[ე\]"r) | (".*შვილ·ი"r) ;

SET NounSFX = (".*ება"r) | (".*ობა"r) | (".*იზმ·ი"r) | (".*აცია"r)  | (".*ისტ·ი"r) ;



























SELECT N + Guess
    IF (0 NounSFX) ;

SELECT Anthr + Abbrev
    IF (1 LastName) ;

# -ის looks like gen
SELECT QUAL + Gen
    IF (1 Guess + ("<.*ის>"r)) ;
# if not, guess Nom or Dat
SELECT QUAL + Nom
    IF (1 Guess) ;
SELECT QUAL + Dat
    IF (1 Guess) ;
#SELECT QUAL
#    IF (1 Guess) ;










# guessed words


#n-SELECT Prop IF (-1 Quote) (2 Quote) ;
#n-SELECT Prop IF (-2 Quote) (1 Quote) ;




# remove Att readings if there is no congruent case in next pos.
# BUT: ხელით დაწერილი სამად სამი სიტყვა

#REMOVE $$CASE + Att
#    IF (NOT 1 $$CASE) ;

# remove reduced case if there is no following possible head
REMOVE $$CASE + Att
    IF (NOT 1 $$CASE)
       (NOT 1 Comma)
       (NEGATE 1 Coord | Adv LINK 1 $$CASE)
       # (NEGATE 1 T:NPGen LINK 1 $$CASE) ; # doesn't work
       (NEGATE 1 NA + Gen LINK 1 $$CASE)
       (NEGATE 1 Num + Advb LINK 1 $$CASE)
       (NEGATE 1 NA + Gen + Att LINK 1 NA + Gen LINK 1 $$CASE) ;

# Because of prev. rule we know that the reduced reading has a head.
# Should add condition on temporal expressions?






# but: სილიბისტრო და მისი და
REMOVE $$CASE + Nom - Att
    IF (0 Att)
       (NEGATE 0* NomArg3 BARRIER CLB)
       (NOT 1 Cj)
       (1 $$CASE - Pron) ;

REMOVE Dat - Att
    IF (0 Att)
       (NEGATE 0* DatArg3 BARRIER CLB) ;

REMOVE Dat - Att
    IF (0 V)
       (NEGATE -1* DatArg3 BARRIER CLB) ;

# add case/person constraints

















# შენი და ჩემი
SELECT Coord
    IF (-1 Pron + Poss + $$CASE)
       (1 Pron + Poss + $$CASE) ;

REMOVE Voc
    IF (-1 APart + Nom) ;

# chained Adjs
#SELECT $$CASE + Att
#    IF (1 (Comma))
#       (2C $$CASE + Att) ;

# წერილ არს
SELECT PastPart + Abs
     IF (1 AUX) ;

# არც … არც

REMOVE V
    IF (-1 Neg + Encl:ც)
       (-2 Comma)
       (-3* Neg + Encl:ც) ;

# Verb if no other verb in clause

# TEMPLATE NPDat = (? Dat - Att - PP LINK NOT 1 Pp ) ;

# TEMPLATE AP = (A OR (Adv LINK 1 A) OR (PP LINK 1 Part)) ;

# TEMPLATE NP = (N OR (T:AP LINK 1 N) OR …

SELECT V
    IF (NEGATE 0* V OR Aux); # BARRIER CLBsub) ;

SELECT N
    IF (1C V)
       (NOT 1 PREDADJVerb)
       (NOT 1 AUX)
       (NOT 1 ("ყოფნ[ა]/არ"))
       (NOT 0 Pron)
       (NOT 0 Advb)
       (NOT 0 Adv)
       (NOT 0 Part)
       (NOT 0 Unrecognized) ;

SELECT A + Nom
    IF (1 PREDADJVerb) ;

SELECT A
    IF (-1 ("უფრო")) ;

REMOVE V
    IF (0C* V BARRIER CLBsub )
       (NEGATE 0* Aux BARRIER CLBsub) ;

# needs refinement!
REMOVE V IF (1C V) ;

# V / VN disambiguation
REMOVE V
    IF (0 VN)
       (0* V BARRIER CLB OR Coord OR Compl) ;

# ??
# SELECT (A Advb) ;

# Case disambiguation
# ------------------------

# დედაჲ მისი მარიამ
SELECT Prop + Anthr + Abs
    IF (-1 Pron + Poss)
       (-2 N + Hum + Qual) ; # Qual needed?

# remove Erg if there is no verb licensing it

# elaborate!
REMOVE Erg
    IF (NOT 1C Erg)
       (NOT -1C Erg)
       (NEGATE 0* V + S:Erg BARRIER CLB) ;









# Have to split this in two because Erg on person names is unmarked
# Default is SOV or SVO
# e.g. აბრაჰამ.Erg შვა ისაკ.Nom
SELECT PERSON + Erg
    IF (1*C V + S:Erg + S:3Sg BARRIER CLB)
       (NOT 0 OldPl) ;

SELECT PERSON + Erg
    IF (0*C V + S:Erg + S:3Sg BARRIER CLB)
       (NEGATE -1* Erg BARRIER CLB)
       (NOT 0 OldPl) ;

SELECT PERSON + Nom
    IF (0*C V - <S-DO-IO> + DO:Nom + DO:3Sg BARRIER CLB)
       (0C N)
       (NOT 0 OldPl) ;

# გაქცეულთ გასძახა
REMOVE Erg + OldPl
    IF (0 Dat + OldPl)
       (1* (<S:Erg> S:3Sg IO:3) BARRIER CLB)
       (NEGATE 1* T:NPDat BARRIER CLB) ;

REMOVE Dat + OldPl
    IF (0 Gen + OldPl)
       (1 Coord)
       (2C Gen + OldPl) ;

LIST PseudoPostpGen = "მეშვეობ[ა]" "წყალობ[ა]" "საშუალებ[ა]" "თანხლებ[ა]" ; # etc.

SELECT Gen IF (1 PseudoPostpGen + Inst) ;
SELECT Gen IF (1 VN + Inst) ;

# no two datives if verb doesn't license them
# but allow two dative attributes
REMOVE NAProp + Dat - Att
    IF (0 Gen)
       (1C Dat - PP)
       (NEGATE 0* DO:Dat + IO:Dat)
       (NEGATE 1* <Dat>)
       (NEGATE 1* <Dat/Gen>) ;

# Problem: სახელმძღვანელო სახელწოდებით

SELECT (Prop Abs) IF (-1 ("<სახელით>")) ;

SELECT Prop + $$CASE IF (NOT 0 N) (-1 A + $$CASE) ;

SELECT N + $$CASE IF (-1C Dem + $$CASE) ;

SELECT (Pron Poss) + $$CASE IF (-1 NOM + $$CASE) ;

# select reduced congruent case if there is no N Full reading ...
#SELECT ADJ + $$CASE + Att 
#    IF (NOT 0 N - Att)
#       (1C NAProp + $$CASE - (Poss))
#       (NEGATE 1 T:NPGen LINK 1 $$CASE) ;

# not sure how to keep this:
# ... or none in Nom that may be verb arg
#SELECT ADJ + $$CASE + Att 
#    IF (1C NAProp + $$CASE - (Poss))
#       (NEGATE 0 (N Nom Full) LINK 0* V + NomArg3 BARRIER CLB) ;

# exclusion of Inst Att on -ის (Ext)















# could go wrong when Gen modifies a Nom. Elaborate!



# rationale: allow two arguments with equal case if the verb licenses them, e.g. S:Nom + NomPrl
# SELECT ??

SELECT ADJ + Erg + Att
    IF (1C NProp + Erg) ;

REMOVE Anthr + Att
    IF (1C Top) ;

#SELECT ADJ + $$CASE + Att
#    IF (1C NProp + $$CASE) ;
# This should be added when we have prls in the morphology
#      (NEGATE 0 (N Nom Full) LINK 0* V + NomArg3 + NomPrl BARRIER CLB) ;

#SELECT (Ord) + $$CASE + Att IF (1C N + $$CASE);
#SELECT (Q) + $$CASE + Att IF (1C N + $$CASE);

# TODO: treat in the same way as Att/Full
SELECT Dem + $$CASE - Nom
    IF (1 NA + $$CASE) (1C NA) ;

#SELECT Dem + Nom
#    IF (1C NA + Nom - Aux) ;

SELECT Pers + Nom
    IF (1C NA + Aux) ;

SELECT Dem + $$CASE IF (1 Prop + $$CASE) (1C Prop) ;

#SELECT Dem + $$CASE
#    IF (1C A + $$CASE) ; # ?? ის პირველი

# what is Q?
# SELECT Dem + $$CASE IF (1C Q + $$CASE) ;

SELECT Dem + $$CASE IF (-1 NAPart + $$CASE) (-1C NAPart) ;

# წმიდანი იგი წიგნნი
SELECT A + $$CASE + $$NUMBER
       IF (1 Dem + $$CASE)
       	  (2 N + $$CASE + $$NUMBER) ;

SELECT (Pron Refl) + $$CASE
       IF (1 Dem + $$CASE)
       	  (2 N + $$CASE) ;

REMOVE QUAL IF (NOT -1 (Anthr)) ;

SELECT QUAL + $$CASE
       IF (-1 Anthr + $$CASE) ;

REMOVE QUAL + $$CASE
       IF (-1 Anthr)
       	  (NOT -1 $$CASE) ;

SELECT $$CASE
       IF (0 Anthr + $$CASE)
       	  (1 QUAL + $$CASE) ;

SELECT N + $$CASE
       IF (-1C Num + Card + $$CASE) ;

# but: ფრაქცია მოქალაქეთა კავშირმა




# too simple




SET OLDPL = OldPl | (<OldPl>) ;

# refine!
REMOVE (<OldPl>) + $$CASE
    IF (NOT 1 OLDPL + $$CASE)
       (NOT 1 A + $$CASE LINK 1 OLDPL + $$CASE)
       (NEGATE 1 COORD LINK 1 OLDPL + $$CASE) ;

SELECT (<OldPl>) + $$CASE
    IF (1C OLDPL + $$CASE) ;

SELECT (<OldPl>) + $$CASE
    IF (1 COORD LINK 1C OLDPL + $$CASE) ;

# Double case
# ------------------------




REMOVE (DVoc) IF (0 L) (1 Coord) ;

REMOVE DNom
    IF (0 (Gen L) - Att)
       (1 COORD)
       (2 Gen);

REMOVE DNom
    IF (0 (Gen L) - Att)
       (1 COORD)
       (2 (Card Digits))
       (3 Gen);

SELECT (Nom OldPl) IF (1 (DNom DOldPl)) ; # etc.

# Coordination
# ------------------------

# Adjective coordination

# SELECT ADJ + $$CASE + Att IF (NOT 0 (V)) (1 ("და" Cj)) (2C NAProp + $$CASE);

SELECT ADJ + $$CASE + Att IF (NOT 0 (V)) (1 ("და" Cj)) (2 (Adv)) (3C NAProp + $$CASE);

# SELECT ADJ + $$CASE + Att IF (NOT 0 (V)) (1 (",")) (2C NA + $$CASE);

SELECT ADJ + $$CASE + Att
    IF (0C $$CASE)
       (NOT 0 N + $$CASE)
       (1 COORD)
       (2C ADJ + Att + $$CASE);

# SELECT ADJ + $$CASE + Att IF (NOT 0 (V)) (1 (",")) (2 (Adv)) (3C NA + $$CASE);

# Verb coordination: used for Aor/Opt disambiguation
# todo: add material in between
SELECT $$AOR IF (0C V) (1* ("და" Cj) BARRIER CLB LINK 1C* $$AOR BARRIER CLB) ;
SELECT $$AOR IF (0C V) (-1* ("და" Cj) BARRIER CLB LINK -1C* $$AOR BARRIER CLB) ;
       
# ღმერთო ჩვენო
SELECT (Poss Voc) IF (-1C Voc) ;


# Adjective/PART disambiguation
# ------------------------

SELECT ("მასწავლებ[ე]ლ·ი" N) ; # not Part

# SELECT Part IF (-1C Gen) ;



SELECT Part + $$CASE + Att
    IF (1 NA + $$CASE) ;

SELECT Part
    IF (0 Advb + Sg) # purposive
       (NOT 0 Adv) ;

SELECT Part
    IF (0 FutPart OR NegPart)
       (0C A)
       (NOT 0 Pl) ;

SELECT Part
    IF (0 Part + Pv - Pl)
       (0C Part OR NA) ;

SELECT N IF (0 Part) ;

# REMOVE Part IF (0 (A));

# მოკლულ იქნა



# Agreement, Argument case selection
# ------------------------




SELECT ("<იყო>" Pass) IF (NOT 0* Erg BARRIER CLB) ;

# Pron Pers

SELECT (Pron Pers Erg 1 Sg) if (0C* S:Erg + S:1Sg BARRIER CLB | V) ;
SELECT (Pron Pers Nom 1 Sg) if (0C* S:Nom + S:1Sg BARRIER CLB | V) ;
SELECT (Pron Pers Dat 1 Sg) if (0C* S:Dat + S:1Sg BARRIER CLB | V) ;

SELECT (Pron Pers Erg 2 Sg) IF (0C* S:Erg + S:2Sg BARRIER CLB | V) ;
SELECT (Pron Pers Nom 2 Sg) IF (0C* S:Nom + S:2Sg BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Sg) IF (0C* S:Dat + S:2Sg BARRIER CLB | V) ;

SELECT (Pron Pers Erg 1 Pl) IF (0C* S:Erg + S:1Pl BARRIER CLB | V) ;
SELECT (Pron Pers Nom 1 Pl) IF (0C* S:Nom + S:1Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 1 Pl) IF (0C* S:Dat + S:1Pl BARRIER CLB | V) ;

SELECT (Pron Pers Erg 2 Pl) IF (0C* S:Erg + S:2Pl BARRIER CLB | V) ;
SELECT (Pron Pers Nom 2 Pl) IF (0C* S:Nom + S:2Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Pl) IF (0C* S:Dat + S:2Pl BARRIER CLB | V) ;

SELECT (Pron Pers Erg 3 Pl) IF (0C* S:Erg + S:3Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 3 Pl) IF (0C* S:Dat + S:3Pl BARRIER CLB | V) ;

SELECT (Pron Pers Erg 1 Sg) if (0C* DO:Erg + DO:1Sg BARRIER CLB | V) ;
SELECT (Pron Pers Nom 1 Sg) if (0C* DO:Nom + DO:1Sg BARRIER CLB | V) ;
SELECT (Pron Pers Dat 1 Sg) if (0C* DO:Dat + DO:1Sg BARRIER CLB | V) ;

SELECT (Pron Pers Erg 2 Sg) IF (0C* DO:Erg + DO:2Sg BARRIER CLB | V) ;
SELECT (Pron Pers Nom 2 Sg) IF (0C* DO:Nom + DO:2Sg BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Sg) IF (0C* DO:Dat + DO:2Sg BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Sg) IF (0C* DO:Dat + DO:2Sg OR DO:Dat + DO:2 BARRIER CLB | V) ;
SELECT (Pron Pers Nom 2 Sg) IF (0C* DO:Nom + DO:2Sg OR DO:Nom + DO:2 BARRIER CLB | V) ;

SELECT (Pron Pers Erg 1 Pl) IF (0C* DO:Erg + DO:1Pl BARRIER CLB | V) ;
SELECT (Pron Pers Nom 1 Pl) IF (0C* DO:Nom + DO:1Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 1 Pl) IF (0C* DO:Dat + DO:1Pl BARRIER CLB | V) ;

SELECT (Pron Pers Erg 2 Pl) IF (0C* DO:Erg + DO:2Pl BARRIER CLB | V) ;
SELECT (Pron Pers Nom 2 Pl) IF (0C* DO:Nom + DO:2Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Pl) IF (0C* DO:Dat + DO:2Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Pl) IF (0C* IO:Dat + IO:2Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Pl) IF (0C* IO:Dat + IO:2 BARRIER CLB | V) ;

SELECT (Pron Pers Dat 1 Pl) IF (0C* IO:Dat + IO:1Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 1 Pl) IF (0C* IO:Dat + IO:1 + Incl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Pl) IF (0C* IO:Dat + IO:2Pl BARRIER CLB | V) ;
SELECT (Pron Pers Dat 1 Sg) IF (0C* IO:Dat + IO:1Sg BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Sg) IF (0C* IO:Dat + IO:2Sg BARRIER CLB | V) ;
SELECT (Pron Pers Dat 2 Sg) IF (0C* IO:Dat + IO:2Sg OR IO:Dat + IO:2 BARRIER CLB | V) ;
SELECT (Pron Pers Dat 3 Pl) IF (0C* IO:Dat + IO:3 BARRIER CLB | V) ;

SELECT NOM + Pl
       IF (0C Nom)
       	  (0* DO:Nom + DO:3Pl BARRIER CLB | V) ;

SELECT Dat + OldPl
      IF (0 Hum)
      	 (-1 IO:Dat + IO:3)
	 (NEGATE -2* Dat BARRIER CLB | V) ;

# Erg must be licensed by verb
SELECT S:Erg + S:3 IF (0C* Erg - Att BARRIER CLB) ;

#@@@ select subj marker from Pron Pers

SELECT (V S:1Sg) IF (0C S:Erg) (0* (Pron Pers Erg 1 Sg) BARRIER CLB | V) ;

SELECT (V S:1Sg) IF (0C S:Nom) (0* (Pron Pers Nom 1 Sg) BARRIER CLB | V) ;
SELECT (V S:1Sg) IF (0C S:Dat) (0* (Pron Pers Dat 1 Sg) BARRIER CLB | V) ;

SELECT (V S:2Sg) IF (0C S:Erg) (0* (Pron Pers Erg 2 Sg) BARRIER CLB | V) ;
SELECT (V S:2Sg) IF (0C S:Nom) (0* (Pron Pers Nom 2 Sg) BARRIER CLB | V) ;
SELECT (V S:2Sg) IF (0C S:Dat) (0* (Pron Pers Dat 2 Sg) BARRIER CLB | V) ;

SELECT (V S:1Pl) IF (0C S:Erg) (0* (Pron Pers Erg 1 Pl) BARRIER CLB | V) ;
SELECT (V S:1Pl) IF (0C S:Nom) (0* (Pron Pers Nom 1 Pl) BARRIER CLB | V) ;
SELECT (V S:1Pl) IF (0C S:Dat) (0* (Pron Pers Dat 1 Pl) BARRIER CLB | V) ;

SELECT (V S:2Pl) IF (0C S:Erg) (0* (Pron Pers Erg 2 Pl) BARRIER CLB | V) ;
SELECT (V S:2Pl) IF (0C S:Nom) (0* (Pron Pers Nom 2 Pl) BARRIER CLB | V) ;
SELECT (V S:2Pl) IF (0C S:Dat) (0* (Pron Pers Dat 2 Pl) BARRIER CLB | V) ;

# replace previous ones by this and the like
SELECT (V S:2Pl) IF (0 S:Erg) (NOT 0 DO:2Pl) (NOT 0 IO:2Pl) (0* (Pron Pers Erg 2 Pl) BARRIER CLB | V) ;


SET NomArg1Sg = (<S:Nom> S:1Sg) | DO:Nom + DO:1Sg ;
SET NomArg2Sg = (<S:Nom> S:2Sg) | DO:Nom + DO:2Sg ;
SET NomArg3Sg = (<S:Nom> S:3Sg) | DO:Nom + DO:3Sg ;
SET NomArg3Pl = (<S:Nom> S:3Pl) | DO:Nom + DO:3Pl ;

SET DatArg1Sg = (<S:Dat> S:1Sg) | (<DO:Dat> DO:1Sg) | (<IO:Dat> IO:1Sg) ;
SET DatArg2Sg = (<S:Dat> S:2Sg) | (<DO:Dat> DO:2Sg) | (<IO:Dat> IO:2Sg) ;
SET DatArg3Sg = (<S:Dat> S:3Sg) | (<DO:Dat> DO:3Sg) | (<IO:Dat> IO:3) ; # | (<IO:Dat> IO:3Sg) ;
SET DatArg3Pl = (<S:Dat> S:3Pl) | (<DO:Dat> DO:3Pl) | (<IO:Dat> IO:3) ;

SELECT NomArg1Sg IF (0*C (Pron Pers Nom 1 Sg) BARRIER CLB | V) ;
SELECT NomArg2Sg IF (0*C (Pron Pers Nom 2 Sg) BARRIER CLB | V) ;
SELECT NomArg3Pl IF (0*C NOM + Pl BARRIER CLB | V) ;

SELECT DatArg1Sg IF (0*C (Pron Pers Dat 1 Sg) BARRIER CLB | V) ;
SELECT DatArg2Sg IF (0*C (Pron Pers Dat 2 Sg) BARRIER CLB | V) ;
SELECT DatArg3Sg IF (0*C (Pron Pers Dat 3 Sg) BARRIER CLB | V) ;

SELECT (V S:2Sg) IF (0C S:Erg) (0* (Pron Pers Erg 2 Sg) BARRIER CLB | V) ;
SELECT (V S:2Sg) IF (0C S:Nom) (0* (Pron Pers Nom 2 Sg) BARRIER CLB | V) ;
SELECT (V S:2Sg) IF (0C S:Dat) (0* (Pron Pers Dat 2 Sg) BARRIER CLB | V) ;

SELECT (V S:3Sg) IF (0C S:Erg) (0* ErgSg - Att BARRIER CLB | V) ;
SELECT (V S:3Sg) IF (0C S:Nom) (0* NomSg - Att BARRIER CLB | V) ;
SELECT (V S:3Sg) IF (0C S:Dat) (0* DatSg - Att BARRIER CLB | V) ; # FIXME: only S:3 for Inv OG

SELECT (V S:3Pl) IF (0C S:Erg) (0* ErgPl - Att BARRIER CLB | V) ;
SELECT (V S:3Pl) IF (0C S:Nom) (0* NomPl - Att BARRIER CLB | V) ;
SELECT (V S:3Pl) IF (0C S:Dat) (0* DatPl - Att BARRIER CLB | V) ; # FIXME: only S:3 for Inv OG

SELECT (V S:1Pl) IF (0C S:Erg) (0* (Pron Pers Erg 1 Pl) BARRIER CLB | V) ;
SELECT (V S:1Pl) IF (0C S:Nom) (0* (Pron Pers Nom 1 Pl) BARRIER CLB | V) ;
SELECT (V S:1Pl) IF (0C S:Dat) (0* (Pron Pers Dat 1 Pl) BARRIER CLB | V) ;

SELECT (V S:2Pl) IF (0C S:Erg) (0* (Pron Pers Erg 2 Pl) BARRIER CLB | V) ;
SELECT (V S:2Pl) IF (0C S:Nom) (0* (Pron Pers Nom 2 Pl) BARRIER CLB | V) ;
SELECT (V S:2Pl) IF (0C S:Dat) (0* (Pron Pers Dat 2 Pl) BARRIER CLB | V) ;

SELECT (V IO:2Pl) IF (0C IO:Dat) (0* (Pron Pers Dat 2 Pl) BARRIER CLB | V) ;
SELECT (V IO:2) IF (0C IO:Dat) (0* (Pron Pers Dat 2 Pl) BARRIER CLB | V) ;

REMOVE (V [Excl]) IF (0* (Pron Pers 1 Sg) BARRIER CLB | V) ;
SELECT (V [Excl]) IF (0* (Pron Pers 1 Pl) BARRIER CLB | V) ;

SELECT (V S:3Sg) IF (0C S:Nom) (0* Anthr BARRIER CLB | V) ;

SELECT DO:2Pl IF (0C DO:Dat) (0* (Pron Pers Dat 2 Pl) BARRIER CLB | V) ;

# არავინ არ…; ვინმე
SELECT (V S:3Sg) IF (0C S:Nom) (-1* Pron + Hum + Nom BARRIER CLB | V) ;

# ახლავს, გახლავთ…













SELECT PassState ;

SELECT <S-DO> OR <S-DO-IO>
    IF (0 <S-DO> + DO:Nom + DO:3)
       (NOT 0 <S>)
       (0* Nom - Att BARRIER CLB) ;

SELECT <S-DO>
    IF (0 <S>)
       (0 <S-DO> + DO:Dat + DO:3)
       (0* Dat - Att BARRIER CLB) ;

# იდო almost always passive
SELECT <S> + ("დებ[ა]/დ")
    IF (NEGATE 0* Erg BARRIER CLB) ;

# გაუწევია წინააღმდეგობა
SELECT <S-DO>
    IF (0 <S>)
       (0 <S-DO> + DO:Nom + DO:3)
       (0* Nom - Att BARRIER CLB) ;

SELECT <S-DO>
    IF (0C V)
       (NOT 0 <S>)
       (NOT 0 <S-IO>)
       (0 <S-DO-IO> + S:Erg + IO:Dat + IO:3)
       (NEGATE 0* T:NPDat BARRIER CLB) ;

# two dative objects
SELECT <S-DO-IO> + DO:Dat + DO:3 + IO:Dat + IO:3
    IF (0C V)
       (NOT 0 <S>)
       # (0 <S-DO> + S:Nom + IO:Dat + IO:3)
       (-1* T:NPDat BARRIER CLB)
       (1* T:NPDat BARRIER CLB) ;

SELECT <S-DO>
    IF (0C V)
       (NOT 0 <S>)
       (0 <S-DO-IO> + S:Nom + IO:Dat + IO:3)
       (NEGATE 0* T:NPDatHum BARRIER CLB) ;

# დამიბარა
SELECT <S-DO> + IOHumV
    IF (0C V + AOR)
       (NOT 0 <S>)
       (0 <S-DO-IO> + IO:12)
       (NEGATE 0* Nom BARRIER CLB) ;

SELECT ("გა·კვირვებ[ა]/კვირვ") + <S-DO> + DO:12 ;

SELECT ("შე·ხედვ[ა]/ხედ") + <S-IO>
    IF (0* T:NPDat BARRIER CLB) ;

SELECT ("ქცევ[ა]/ქც[ევ]")
    IF (0* Advb BARRIER CLB) ;

# … contradicts this:
# გიშოვნით
SELECT <S-DO-IO> + IO:12
    IF (0 <S-DO> + DO:12) ;

# ხალხს მიმართა
SELECT <S-IO> + Pass + IO:Dat + IO:3
    IF (0C V + AOR)
       (0 <S-DO-IO> + DO:Nom + DO:3)
       (NEGATE 0* Erg BARRIER CLB)
       (0* T:NPDat BARRIER CLB) ;

#  check this one
SELECT <S-IO> + IO:Dat + IO:3
    IF (0C V + AOR)
       (0 <S-DO-IO> + DO:Nom + DO:3)
       (NEGATE 0* Nom BARRIER CLB)
       (0* T:NPDat BARRIER CLB) ;

SELECT <S-DO-IO>
    IF (0C V + AOR)
       (0 <S-DO>)
       (NOT 0 <S-IO>)
       (0 <S-DO-IO> + IO:Dat + IO:3)
       (0* T:NPDat BARRIER CLB) ;

# უნდა გითხრათ
SELECT <S-DO-IO>
    IF (0C COMPVerb + AOR)
       (NOT 0 <S-DO>)
       (0 <S-IO>)
       (1 Comma LINK 1 ("რომ")) ;

# შემჩნეული ექნება
SELECT ("ქონ[ა]/ქნ" Inv) IF (-1 PastPart) ;
SELECT ("ქონ[ა]/ქნ" Inv) IF (-1 Neg LINK -1 PastPart) ;
SELECT ("ქონ[ა]/ქნ" Inv) IF (1 PastPart) ;

SELECT <S-IO>
    IF (0C V)
       (NOT 0 <S-DO-IO>)
       (NOT 0 <S-DO>)
       (0 <S-IO> + IO:Dat + IO:3)
       (0* T:NPDat BARRIER CLB) ;

SELECT <S>
    IF (0C V)
       (NOT 0 <S-DO>)
       (0 <S-IO> + IO:Dat + IO:3)
       (NEGATE 0* T:NPDat BARRIER CLB)
       (NEGATE 1* Comma BARRIER V LINK 1 ("<რომ>" Cj)) ;

SELECT <S-IO>
    IF (0C V)
       (NOT 0 <S-DO-IO>)
       (0 <S-IO> + IO:Dat + IO:3)
       (1* Comma BARRIER V LINK 1 ("<რომ>" Cj)) ;

REMOVE DO:1Sg
    IF (0 DO:3)
       (0C DO:Nom)
       (0*C Nom)
       (NEGATE 0* Pron + Pers + (1 Sg))  ;

REMOVE Dat - Temp
    IF (0 V)
       (-1* V + DatArg3 - DoubleDatArg3 LINK -1* Dat - Temp BARRIER CLB) ; 

REMOVE Dat - Temp
    IF (1* V + DatArg3 - DoubleDatArg3 BARRIER V)
       (-1* Pron + Rel + Dat BARRIER V) ; 

SELECT NomArg3
    IF (-1* Pron + Rel + Nom BARRIER V) ;

SELECT ErgArg3
    IF (-1* Pron + Rel + Erg BARRIER V) ;

SELECT DatArg3
    IF (-1* Pron + Rel + Dat BARRIER V) ;

# sentence complements

REMOVE DO:3Pl
    IF (0 DO:3)
       (0 COMPVerb)
       (1 Comma)
       (2 ("რომ")) ;

REMOVE DO:3Pl
    IF (0 DO:3)
       (0 COMPVerb)
       (1 ("რომ")) ;

# Act/Pass disambiguation

#მივიღოთ	
#	მი-ღებ[ა]/ღ	V Pass Opt Pv <S> <S:Nom> S:1Pl	
#	მი-ღებ[ა]/ღ	V Act Opt Pv SV <S-DO> <S:Erg> <DO:Nom> S:1Pl DO:3	

# remove Passive with 1/2 pers S if there is active reading and DO available
# TODO: variants thereof
REMOVE (Pass <S>) + $$S:12
    IF (0C V)
       (0 (Act <S-DO> <DO:Nom> DO:3) + $$S:12)
       (0* NOM BARRIER CLB) ;

# should be passive if Nom arg precedes
REMOVE (Act <S-DO> <S:Erg>)
    IF (0C V)
       (0 (Pass <S> S:3Sg))
       (-1 Nom)
       (NEGATE 0* Erg BARRIER CLB) ;

# or if Nom arg has rel subclause
REMOVE (Act <S-DO> <S:Erg>)
    IF (0C V)
       (0 (Pass <S> S:3Sg))
       (1 Nom)
       (2* Comma LINK 1 Rel BARRIER CLB) # ??
       (NEGATE 0* Erg BARRIER CLB) ;

# Aor active if Nom Obj is non-Hum
#REMOVE (Pass <S> S:3Sg)
#    IF (0C V)
#       (0 (Act <S-DO> <DO:Nom> DO:3))
#       (0* Nom + Sg - Hum BARRIER CLB) ;

# გიას უნდოდა
SELECT Prop + Dat - PP
    IF (1 S:Dat + S:3Sg) ;

SELECT Dat - OldPl
    IF (0C Dat OR Gen)
       (NEGATE 0* T:NPDat BARRIER CLB)
       (0* DO:Dat + DO:3 BARRIER CLB OR V) ;

# თქვენდა etc. if IO
SELECT (Pron Pers Ben)
	   IF (0* IO:Dat + IO:3 BARRIER CLB | V)
	      (NEGATE 0* Dat BARRIER CLB | V) ;

# რომლისა ღირს ვარ
SELECT Ben # or Dir?
	 IF (0* ("ღირს·ი") LINK 1 AUX BARRIER CLB | V) ;

# remove 1/2 person arg reading if a 3rd person arg is found with appropriate case
# Dangerous! Could be apposition, or Prl
# REMOVE (V S:1Sg <S:Nom>) IF (0* Nom - Att BARRIER CLB) ;
# REMOVE (V S:2Sg <S:Nom>) IF (0* Nom - Att BARRIER CLB) ;
# REMOVE (V S:1Pl <S:Nom>) IF (0* Nom - Att BARRIER CLB) ;
# REMOVE (V S:2Pl <S:Nom>) IF (0* Nom - Att BARRIER CLB) ;

# conjunct S agreement
SELECT $$S:12 IF (-1* Cj LINK -1*C $$S:12 BARRIER CLB1) ;

# wrong: could be A before N
#SELECT (N Nom) - Att IF (0C* (V <S:Nom> S:3Sg) BARRIER CLB) ;
# what about Pron etc.?
SELECT (N Nom Pl) - Att IF (0C* (V <S:Nom> S:3Pl) BARRIER CLB) ;

# remove Nom Full if it is not a verb argument and there is a verb
REMOVE Nom - Att # + $$CASE
       IF (NEGATE 0* NomArg3 BARRIER CLB)
	  (NEGATE 0* (<AuxIntr>) BARRIER CLB)
	  (NOT -1 (Pron Poss)) # + $$CASE)
	  (0* V BARRIER CLB) ;

# disambiguate Gen and Dat
SELECT NProp + Gen - Att
    IF (0 NProp + Dat - Att - Temp)
       (0C NProp)
       (1 NACProp)
       (NEGATE 0* DatArg3 BARRIER CLB) ;

# remove Gen if not attributive or licensed by PP or V

















# improve! remove Dat if there is a Dat nearer to a verb wanting Dat







# remove Dat if there is a relative in Dat






REMOVE Gen - L - PP
    IF (NOT 1 POSTP + <Gen>)
       (NOT 1 POSTP + <Dat/Gen>)
       (NOT -1 PREP + <Gen>)
       (NOT -1 PREP + <Dat/Gen>)
       (NOT 1 Gen)
       (NOT -1 Gen) # OG
       (NOT 1 NACProp)
       (NEGATE 1 ("და" Cj) | (",") | (Adv) LINK 1 Gen)
       (NEGATE 1 T:NPGen LINK 1 Gen)
       (NEGATE -1 T:NPGen LINK -1 N) # ??
       (NEGATE -1 T:NPGen LINK -1 PREP + <Gen>)
       (NEGATE 0* GenArg BARRIER CLB) ;

SELECT Dat + OldPl
     IF (0C Dat OR Dir OR Ben)
     	(0* IO:Dat + IO:3 BARRIER CLB) ;

# OG attributive Gen
SELECT Gen + L
     IF (-1 N - Prop) ;

# Gen after VN in Advb
SELECT N + Gen + OldPl
	IF (-1 VN + Advb + Sg) ;


SELECT N + Temp + Nom
    IF (0* DO:Nom + DO:3 BARRIER CLB) ;

REMOVE S:Nom + S:12
    IF (0 DO:Nom + DO:3)
       (0* Nom BARRIER CLB)
       (NEGATE 0* (<AuxIntr>) BARRIER CLB) ;


# Post/prepositions ; fixme: see also below
# ------------------------

SELECT ("შემდეგ") + Pp IF (-1 Gen) ;
SELECT ("მიუხედავად") + Pp IF (-1 Gen) ;
SELECT ("მიუხედავად") + Pp IF (1 Gen) ; # add: head should be L
SELECT ("მახლობლად") + Adv IF (-1 Gen) ; # should be Pp?

SELECT ("<ერთად>") + Pp IF (-1 PP:თან) ;
REMOVE ("<ერთად>") + Pp IF (NOT -1 PP:თან) ;

SELECT (Pp <Gen>) - PREP IF (-1C N + Gen OR Pron + Pers + Dat) ;
SELECT PREP + <Gen> IF (1 T:NPGen LINK 1 (N Gen)) ;
SELECT PREP + <Gen> IF (1 (N Gen)) ;
SELECT Gen IF (-1 PREP + <Gen>) ;
SELECT N + Gen IF (-1 T:NPGen LINK -1 PREP + <Gen>) ;

SELECT (Pp <Dat>) - PREP IF (-1 (N Dat)) ;
SELECT PREP + <Dat> IF (1 T:NPGen LINK 1 (N Dat)) ;
SELECT PREP + <Dat> IF (1 N + Dat) ;
SELECT PREP + <Dat> IF (1 Pron + Dat) ;
SELECT N + Dat IF (-1 T:NPGen LINK -1 PREP + <Dat>) ;

SELECT (Pp <Gen>) - PREP IF (-1 Pron + Pers + Dat) ;

# მის წინაშე
SELECT Pron + Pers + Gen
    IF (1 Pp + <Gen>) ;
SELECT Pron + Pers + Gen
    IF (1 Pp + <Dat/Gen>) ;

# ამის მეტს



SELECT N + Gen
    IF (1C POSTP + <Gen>) ;

SELECT ("მეტ·ი")
    IF (-1 N + Gen) ;

SELECT A + Gen - Att
    IF (1C POSTP + <Gen>) ;

# wrong
#SELECT S:Nom + (S:3Sg) IF (0* (Full Nom) BARRIER CLB) ;

#remove ("<S-DO-R-Padv>")
#    if (not 0* Advb BARRIER CLB) ;

REMOVE Att + $$CASE
    IF (NOT 1 NOM)
       (NOT 1 Pron + Dem + $$CASE) # მთელი ეს ფიქრი
       (NOT 1 Pron + Poss + $$CASE) # დღევანდელი ჩვენი მწერლობის
       (NEGATE 1 COORD LINK 1 Att + $$CASE)
       (NEGATE 1 Comma LINK 1 ("მაგრამ") LINK 1 Att + $$CASE) ;

REMOVE (Pron Int Erg) IF (1 V + S:12);

SELECT (Pron Int Erg) IF (1 V + ("ცოდნა" Pres S:3Sg));

# Disambiguation of ჩემ(ს)

SELECT ("მე") IF (1 POSTP);

SELECT ("ჩემ-ი") IF (NOT 1 POSTP);
SELECT ("ჩემ·ი") IF (NOT 1 POSTP);

# Abs and ყოფა

SELECT (N Abs)
       IF (0* ("ყოფ[ა]/არ" MedPass) BARRIER CLB) ;

# PP disambiguation
# =================

# Aux vs. long -ა

REMOVE Aux IF (0* V BARRIER CLB) ;

# Card/Ord disambiguation

LIST MONTH = "იანვ[ა]რ·ი" "თებერვ[ა]ლ·ი" "მარტ·ი"
     	     "აპრილ·ი" "მაის·ი" "ივნის·ი"
	     "ივლის·ი" "აგვისტო" "სექტემბ[ე]რ·ი"
	     "ოქტომბ[ე]რ·ი" "ნოემბ[ე]რ·ი" "დექემბ[ე]რ·ი" ;

# IV საუკუნე
SELECT Ord
    IF (1 MONTH OR ("საუკუნ[ე]")) ;

SELECT Ord + Roman
    IF (-1 ("წელთაღრიცხვ[ა]")) ;

# add: თავი 1

SELECT Card ;

# A/N disambiguation
# ==================

# doesn't work well
# but: ძველს დროს (ჭავჭავაძე)
#REMOVE A + $$CASE - Att
#    IF (0 N + $$CASE - Att) ;

# predicative adjective




# remove A reading if N reading present and no following head








# ?? og has no Att?
REMOVE A + $$CASEnoAdvb - Att - Quant
      IF (0 N + $$CASEnoAdvb - Att)
      	 (NOT -1 NA + $$CASEnoAdvb)
      	 (NOT 1 NA + $$CASEnoAdvb)
	 (NOT -1 Pron + Poss + $$CASEnoAdvb) ;

# remove A if full case and N present



REMOVE A + NewPl + $$CASE
    IF (0 N + $$CASE) ;







# DNom





# Adverb

# MWEs

# LIST MWE = 2:Cj 2:Sub 2:Adv ;

#REPLACE ([0] 2:Cj 2:Sub) ("<როგორც>" "როგორც" Adv) (1 ("<კი>")) ;
#REPLACE ([0] 2:Adv) ("<ესე>" Adv) (1 ("<იგი>")) ;

# Crashes cg3 without next line
# APPEND ("2:ესე იგი" 2:Adv) ("<ესე>" Adv) (1 ("<იგი>")) ;
# SELECT MWE ;
# Doesnt work
# SELECT (/2.*/r) ;

# რაც

# მას შემდეგ, რაც
SELECT ("რაც") + Cj # only temporal ones?
    IF (-1* ("ის") + Pron + Pers LINK 1 Pp) ;

# ერთი თვეა, რაც



# რაც cannot be Nom arg:
# either the following verb doesn’t govern a Nom




# or there is already a Nom head




# else, choose რაც as being the Nom head










# NP internal constraints
# =======================

# Determiner disambiguation

# Case disambiguation

# Number disambiguation

# Noun disambiguation
# -------------------

# Poss disambiguation

# NP head disambiguation
# ======================

# Inversion


# A or N
# ======

# P chains or not

# Coordination
# Substituting tags

# SUBSTITUTE:sumPr (CS) (Pr) TARGET ("sum") (NOT -1 BOS OR COMMA);


# ======== #
  SECTION  #
# ======== #

# final disambiguation

REMOVE (NewPl) ;

REMOVE (Bracket) ;
# REMOVE (Subnorm) ;
# move to later
# REMOVE (VPart);
# REMOVE (Old);
REMOVE (ConjPerf) ;
REMOVE (Cond) ;
REMOVE (Dialect) ;
# REMOVE (NonStand) ;
REMOVE ("არ[ა]" N) ;

REMOVE ("ის") + Gen - PP ;
REMOVE ("შენ") + Gen - PP ;
REMOVE ("ჩვენ") + Gen - PP ;
REMOVE ("თქვენ") + Gen - PP ;

LIST GeoMod = "სამხრეთ·ი" "აღმოსავლეთ·ი" "ჩრდილოეთ·ი" "დასავლეთ·ი" ;

# but: აღმოსავლეთი რომის…
REMOVE Prop
    IF (-1 A)
       (NOT -1 GeoMod) ;

SELECT Top + Area
    IF (-1 GeoMod) ;



SELECT Gen + OldPl
    IF (1 NA)
       (NEGATE 0 Dat LINK 0* DatArg3 BARRIER CLB) ;

# remove plain A reading of ordinals (TODO: remove from lexicon)
SELECT (Ord Alpha) ;

REMOVE IMPV
    IF (1* IntMark) ;

REMOVE IMPV
    IF (-1 Int) ;

SELECT IMPV
    IF (0C V)
       (1* ExclPoint) ;

SELECT IMPV
    IF (-1* Voc) ;

REMOVE IMPV
    IF (-1* Cj + Sub BARRIER CLB) ;

REMOVE Voc OR DVoc
    IF (NOT 1* ExclPoint)
       (NOT 1* IntMark)	
       (NOT -1 Voc) ;

REMOVE N + Voc OR DVoc
    IF (NOT 1 ExclPoint)
       (NOT 1 IntMark)
       (NOT 1 Comma) ;

SELECT N + Voc
    IF (0C Voc OR (Abs Encl:IndSp3))
       (1 ExclPoint OR IntMark) ;

SET NonVoc = Nom | Erg | Dat | Gen | Advb | Inst | Abs ;

REMOVE N + Voc OR DVoc
    IF (-1C* V BARRIER BOP | BOS) ;
REMOVE N + Voc OR DVoc
    IF (-1C* NonVoc BARRIER BOP | BOS) ;

# -თა is mostly attributive Gen





# preverbless transitives: წარმოადგენს, განსაზღვრავს
# SELECT (Pres Trans) IF (0 (Fut Trans)) (0C V);

SELECT ("<დროს>" Dat) ;

# SELECT ("<და>" N ) ;

# see above
# REMOVE N + Advb IF (0 A + Advb) ;

# e.g., შორის. Check if Dat is always more frequent
SELECT Dat IF (1 POSTP + <Dat/Gen>) ;

# Pres/Fut disambiguation

# TODO: check for equal person/number
# select Pres if all other verbs in the sentence are Pres
SELECT Pres
    IF (0C V)
       (0C* Pres BARRIER (Colon))
       # (NOT 0* Fut)
       ;

# a bit hazardous?
SELECT Pres
    IF (NEGATE 0* V BARRIER CLB)
       (NEGATE -1* (Cj Sub)) ;

SELECT (<Null>) IF (0C V) ; # todo: look at alternative frames

# დიდის შრომითა




# ჩვენამდე
SELECT (Pron Pers PP:მდე) ;

### Disambiguation on semantic grounds

# verbs that go with თავი N
# თავი იჩინა (??)
SELECT ("თავ·ი" N)
    IF (1 ("ჩენ[ა]/ჩინ")) ;
SELECT ("თავ·ი" N)
    IF (-1 ("ჩენ[ა]/ჩინ")) ;


# verbs that go with თავი Pron
SELECT ("თავ·ი" Pron)
    IF (1 ("ა·ცილებ[ა]/ცილ")) ;
SELECT ("თავ·ი" Pron)
    IF (-1 ("გრძნობ[ა]/გრძნ")) ;
# თავიდან აცილება
SELECT ("თავ·ი" Pron PP:დან)
    IF (1 ("ა·ცილებ[ა]/ცილ")) ;

SELECT ("წ[ე]ლ·ი") IF (-1 Num + Ord) ;
SELECT ("წ[ე]ლ·ი") IF (-1 Num + Card) ;

SELECT Fut OR Conj-II IF (0* FUT-ADV BARRIER CLB) ;





REMOVE OPT # but: სწორი გითხრათ?
    IF (NEGATE -1* V BARRIER CLB)
       (NOT -1* ("<რომ>"))
       (NOT -1* ("იქნებ"))
       (NOT -1* ("<რათა>"))
       (NEGATE 1* ExclPoint BARRIER CLB) ;

# adhortative
SELECT OPT + S:2 
    IF (-1 ("<არ>"))
       (1* ExclPoint BARRIER EOS) ;

LIST <S-DO*> = <S-DO> <S-DO-IO> ;

SELECT OPT + S:2 + <S-DO*>
    IF (-1* ("იქნებ") BARRIER CLB) ;

# მიიღე
REMOVE Pass + Impv
    IF (0 Act + Impv)
       (0C Impv) ;









# dangerous?
SELECT Aor
    IF (-1 ("<და>"))
       (-2C Aor) ;

SELECT Aor
    IF (0C Aor OR Conj-II)
       (1* Cj LINK 1*C Aor BARRIER CLB) ;

SELECT ("<იყო>") + Aor ;

# removes Abs
SELECT Anthr + Erg
    IF (0* ErgArg3Sg) ;
SELECT Anthr + Nom
    IF (0* NomArg3) ;

REMOVE A + Abs
    IF (0 Adv)
       (NOT -1 NA + Abs)
       (NOT 1 NA + Abs) ;

REMOVE Int
    IF (0 (Rel Rel:ც))
       (NOT 1* IntMark)
       (NOT -1* ("<თუ>")) ;

# add more verbs with Int complement
SELECT Int - Att
    IF (-1* ("და·დგენ[ა]/დგინ") + OPT)
       (1 V) ;

# to make this work msa-set-disambiguation() in gnc/cg3-disambiguate.lisp would have to be changed
# ADD (Rel:ც) (Encl:ც) IF (-1 Rel) ;

# რომლის შესახებაც, რომლის მიზანიც







# generalize! (NP)






















# ებათა
REMOVE Advb + Pl + NewPl + L + NonStand ;

# forms in -და
REMOVE Advb + Sg + L IF (0 V) ;

REMOVE (Encl:Q) IF (NEGATE 1* IntMark BARRIER CLB) ;

# REMOVE (Der:იანი) ;

REMOVE (/<Der.*/r) ;

# prelim.


# remove the more specific one if it cannot be selected unambiguously


# Lexical disambiguation

# default reading
SELECT ("ა·დგომ[ა]/დგ") ;

SELECT ("ყოვ[ე]ლ·ი" Gen L)
    IF (-1 ("უპირველეს") OR ("უწინარეს") OR ("პირველ") OR ("უპირველესად")) ;

# საღამოს 7 საათზე
SELECT ("საღამო") + Gen
    IF (1 Num)
       (2 ("საათ·ი")) ;

SELECT ("გარეთა" A)
    IF (1 NA) ;

REMOVE ("<ეცვა>" PassState) IF (-1 ("<ჯვარს>")) ;
SELECT ("<ეცვა>" PassState) IF (NOT -1 ("<ჯვარს>")) ;

SELECT ("ფიქრ·ი/ფიქრ" <S-DO>)
       IF (1 Comma)
       	  (2 ("რომ")) ;

SELECT ("ფიქრ·ი/ფიქრ" <S-DO>)
       IF (-1 Comma)
       	  (-2 Encl:IndSp3) ;

SELECT ("ფიქრ·ი/ფიქრ" <S-DO>)
       IF (1 Comma LINK 1* Encl:IndSp3 BARRIER CLB) ;

# ველი(თ)
SELECT ("ლოდინ·ი/ლ")
       IF (1 Comma)
       	  (2 ("რომ")) ;

SELECT ("თავ·ი" N) IF (1 ("საყრ[ე]ლ·ი/ყრ")) ;

REMOVE ("თათ·ი" Hum) IF (-1 ("წინა") OR ("უკანა")) ; # წინა თათი

# remove დაწყობა
SELECT ("და·წყებ[ა]/წყ" <DO:Nom> DO:3)
    IF (0* VN + Nom BARRIER CLB1) ;
#SELECT ("და·წყებ[ა]/წყ" <DO:Nom> DO:3)
#    IF (-1 VN + Nom) ;
SELECT ("*·წყებ[ა]/წყ" <DO:Nom> Imperfective DO:3)
    IF (1 VN + Nom) ;
SELECT ("*·წყებ[ა]/წყ" <DO:Nom> Imperfective DO:3)
    IF (-1 VN + Nom) ;

SELECT ("და·წყებ[ა]/წყ" Pass)
    IF (1 ("ის" Inst))
       (2 Comma)
       (3 ("რომ")) ;

#SELECT ("და·წყებ[ა]/წყ" Act)
#    IF (0 "და·წყობ[ა]/წყ" Act)
#       (

SELECT ("და·წყებ[ა]/წყ" Pass S:3Sg)
    IF (NEGATE 0* Erg) ;

# და-ბარვ[ა]/ბარ¦და-ბარებ[ა]/ბარ
# condition motivated by corpus search

SELECT ("და·ბარვ[ა]/ბარ") IF (-1 ("ბოსტ[ა]ნ·ი")) ;
SELECT ("და·ბარებ[ა]/ბარ") ;


# suppress დაძახვა (zwirnen)
SELECT ("და·ძახებ[ა]/ძახ") ;

REMOVE ("მი·ნდობ[ა]/ნდვ") IF (0 ("ნდომ[ა]/ნდ")) ; # მინდოდა

SELECT ("და·ხევ[ა]/ხ[ევ]") IF (-1 ("უკან")) ;

SELECT ("თვალ·ი") IF (2 ("*·შორებ[ა]/შორ")) ;

SELECT ("<ველით>" V) ;

# გახდა vs. გახდომა
SELECT ("გა·ხდომ[ა]/ხდ")
    IF (-1 Advb) ;

SELECT ("გა·ხდომ[ა]/ხდ")
    IF (1 Advb) ;

SELECT ("თქმ[ა]/თხ[ა]რ" Aor) IF (-1 Dash) ;
SELECT ("თქმ[ა]/თხ[ა]რ" Aor) IF (1 Colon) ;

SELECT ("სმენ[ა]/სმ")
    IF (0* ("ხმ[ა]")) ;

REMOVE ("გა·რბენ[ა]/რბ" MedAct <S-DO>)
    IF (NEGATE 1* T:NPDat BARRIER CLB) ;

# ხალხს მიმართა
#REMOVE ("მართვ[ა]/მართ" IO:1Sg)
#    IF (1* T:NPDat BARRIER CLB) ;

SELECT ("ფიქრ·ი/ფიქრ" <S>)
    IF (-1 (PP:ზე)) ;
SELECT ("ფიქრ·ი/ფიქრ" <S>)
    IF (1 (PP:ზე)) ;

REMOVE ("გველ·ი" Prop) ;
REMOVE ("გალავ[ა]ნ·ი" Prop) ;
REMOVE ("უდაბნო" Prop) ;
REMOVE ("ნადირობ" Adv) ;



# გაჩერდა is mostly not <S-IO> IO:2Sg
REMOVE ("ჩერებ[ა]/ჩერ") ;

# preverb-less Fut competes with Pres
REMOVE ("კეთებ[ა]/კეთ" Fut) ;

REMOVE ("საღამო" Prop) ;
REMOVE ("წეს·ი" Prop) ;

REMOVE ("ცოტა" N) ;
SELECT ("ჯვ[ა]რ·ი" Prop Gen) IF (1 ("უღელტეხილ·ი")) ;
REMOVE ("ჯვ[ა]რ·ი" Prop) ;
REMOVE ("შემოქმედ·ი" Prop) ;
REMOVE ("გარემოს" Adv) ;
SELECT ("დაახლოებით" Adv) ;
SELECT ("ლოდინ·ი/ლოდ") ;
SELECT ("<დარგი>" N) IF (-1 (Pron Dem Nom)) ; 
SELECT ("რაჲთა" Cj) ;

REMOVE ("შიშ·ი" Prop) ;
REMOVE ("თოკ·ი" Prop) ;
REMOVE ("ქუეყან[ა]·ჲ") ;
REMOVE ("სადა·ჲ" A) ;
REMOVE ("ზედა·ჲ" N) ;
REMOVE ("წეს[ა]·ჲ" N) ;

SELECT ("<მათთან>" "ის") ;

REMOVE ("ხიდ·ი" Prop) ;

SELECT ("ნებ[ა]") IF (1 ("მი-ცემ[ა]/[ე]ც")) ;
SELECT ("ნებ[ა]") IF (1 Neg) (2 ("მი-ცემ[ა]/[ე]ც")) ;

REMOVE LastName IF (0C Anthr) ;

SELECT ("<წელს>" "წელ·ი") IF (1C Loc) ;

# not ვერა Prop


SELECT Prop IF (-1 Quote) (1 Quote) ;
REMOVE ("??" Top) ;
REMOVE ("??" Anthr) ;

# coordinated verbs have same tense
SELECT $$TENSE
    IF (0C V)
       (1 Cj)
       (2C $$TENSE) ;

SELECT $$TENSE
    IF (0C V)
       (1 Cj)
       (2 Adv)
       (3C $$TENSE) ;

SELECT $$TENSE
    IF (0C V)
       (-1 Cj)
       (-2C $$TENSE) ;

SELECT $$TENSE
    IF (0C V)
       (-1 Adv)
       (-2 Cj)
       (-3C $$TENSE) ;

# Frequency disambiguation

#n-SELECT (<lemma=MAX>)
#      IF (0C N) ;

REMOVE Pass + S:12 ;

REMOVE Prop + Advb + Att IF (NOT 1 Prop + Advb);
REMOVE Prop + Inst + Att IF (NOT 1 Prop + Inst);

REMOVE Prop + Pl ;

# REMOVE (NonStand) ;

# remove double analyses (e.g., მართლაც)


REMOVE (Encl:მე) ;

SELECT ("<და>" Cj) ;

# Heuristic syntactic disambiguation
# ========================

SELECT Dat + Temp - Pl ;





REMOVE Interj + (Encl:IndSp3) ; # ოო

# გთხოვთ etc.







REMOVE N
      IF (0 V)
      	 (NEGATE 0* V BARRIER CLBarg) ;

REMOVE (".*-.*-.*"r) ;
REMOVE (".*-.*"r) ;

REMOVE ("მი·.*"r)
    IF (0C ("მი·.*"r) OR ("მო·.*"r)) ;

REMOVE ("შე·.*"r)
    IF (0C ("შე·.*"r) OR ("შემო·.*"r)) ;

REMOVE Inv IF (0C V) ; # remove Inv if non-Inv reading is available

# test
ADD @CLB ("მაშინ") IF (-1* V LINK -1* Cj + Sub BARRIER V) ;

# Misc.

SELECT N + Sg
    IF (0 A + Sg)
       (NOT 0 Att) ;







# ==================== #
  SECTION	       #
# 	   	       #
# Dependency relations #
# ==================== #

LIST RELATION = >SUBJ >DO >IO >XOBJ >PRL >COMP >ATR >NUM >POSS >GEN >OBJ >OBL >AG
     	        >DET >QUAL >NEG >MODAL >REL >NAMEMOD >PRED >P >ADV >AUX >MWE >QUOTE >VOC
		>INTERJ
		>OBL-COMPAR >APOS ;

LIST RELS = /^>/r ;

# prelim; these have to go into the morphology
LIST AdjDegAdv = "<მეტისმეტად>" ;

LIST COMPVerbOPT = "ცდ[ა]/ცად"
     		   "ცდილობ[ა]/ცდილ"
     		   "შე·ძლებ[ა]/ძლ" ; # and more

LIST COMPVNOPT = "გადმო·ბირებ[ა]/ბირ" ; # and more

# special phrases first

# არც თუ ისე is MWE
#SETPARENT Neg + Foc
#	IF (2 ("<ისე>"))
#	TO (1 ("თუ")) ;

SETPARENT ("თუ")
	IF (-1 Neg + Foc)
	TO (1 ("<ისე>")) ;

# რა თქმა უნდა is MWE
#SETPARENT ("რ[ა]")
#	IF (2 ("უნდა"))
#	TO (1 ("<თქმა>")) ;

#SETPARENT ("<თქმა>")
#	IF (-1 ("რ[ა]"))
#	TO (1 ("<უნდა>")) ;

SETPARENT ("<უნდა>")
	IF (NEGATE p (*))
	TO (1* V) ;

# then start with deterministic attachments
#SETPARENT Adv + Deg
#	TO (1 (*)) ;

SETPARENT Adv + Deg OR AdjDegAdv
	TO (1 A) ;

SETPARENT Adv + Deg OR AdjDegAdv OR (".*ობით"r Adv)
	TO (1 N) ;

SETPARENT Iter
	TO (-1 V) ;

ADD >AUX TARGET Iter (p V) ;

SETPARENT ("მხოლოდ") + Deg
	TO (1 Pron) ;

SETPARENT Adv + DegNum
	IF (NEGATE p (*))
	TO (1 Num) ;

ADD >ADV TARGET DegNum (p Num) ;

# add ყველაზე as Adv Deg!
SETPARENT ("<ყველაზე>")
	IF (NEGATE p (*))
	TO (1 (*)) ;

ADD >ADV TARGET ("<ყველაზე>") ;

SETPARENT ("მხოლოდ")
	TO (1 Temp) ;

SETPARENT ("<ძირითადად>")
	IF (NEGATE p (*))
	TO (1* Head) ;

SETPARENT Neg
	IF (NEGATE p (*))
	TO (1 V) ;

#SETPARENT Neg
#	TO (1 Modal) ;

#SETPARENT Neg + L
#	IF (-1 ("ოღონდ"))
#	TO (1 (*) LINK pp (*) ) ;

SETPARENT Att + $$CASE - Num
	IF (NEGATE p (*))
	TO (1 (*) LINK Spp N + $$CASE) ;

SETPARENT Att + $$CASE - Num
	IF (NEGATE p (*))
	TO (1 Quote LINK 1 (*) LINK Spp N + $$CASE) ;

#n-SETPARENT Pron + Pers + Nom + (3)
#	IF (1* NomHead LINK 1 ("ყოფნ[ა]/არ"))
#	TO (1* ("ყოფნ[ა]/არ")) ;

SET NACj = N | A | Cj + Coord ;

# იმისა








SETPARENT Pron + Dem - Indef
	TO (-1 NA) ;

SETPARENT Pron + Poss
	TO (-1 NA) ;

#SETCHILD N + Dat
#	FROM (0* <S-DO> + DO:Dat + DO:3) ;

#SETCHILD <S>
#	TO (0* Nom BARRIER CLB) ;


SETPARENT (PP:ზე) TO (1 Elat) ;

SETPARENT PP:თვის
    IF (NEGATE p (*))
    TO (1 PastPart) ;

ADD >OBL TARGET PP:თვის
    IF (NEGATE 0 RELS)
       (p V | Part | VN) ;

ADD >PRL TARGET PP:ვით - RELS
    IF (p PREDVerb) ;

ADD >ADV TARGET Inst | PP | POSTP
    IF (NEGATE 0 RELS)
       (p V | Part | VN) ;

ADD >OBL-COMPAR TARGET (PP:ზე)
    IF (1 Elat) ;

SETPARENT ("უფრო") TO (1 A OR Adv) ;

SETPARENT PP:ზე TO (1 ("უფრო") LINK 1 A) ;

ADD >OBL-COMPAR TARGET (PP:ზე)
    IF (1 ("უფრო") LINK 1 A) ;

SETPARENT PP:და
    	IF (NEGATE p (*))
	TO (1 Advb + Sg) ;

ADD >OBL TARGET PP:და - RELS
    IF (p Advb) ;

SETPARENT A + Att + $$CASE
    	IF (NEGATE p (*))
	TO (1 (*) LINK Spp NA + $$CASE) ;

SETPARENT Pron + Att + <OldPl> + $$CASE
    	IF (NEGATE p (*))
	TO (1 (*) LINK Spp NA + OldPl + $$CASE) ;

SETPARENT Pron + Att + $$CASE
    	IF (NEGATE p (*))
	TO (1 (*) LINK Srrpp NA + $$CASE) ;

# adjective coordination
SETPARENT A + Att + $$CASE
	IF (NEGATE 1 @CLB)
	   (2 A + Att + $$CASE)
	TO (1 Cj + Coord) ;

SETPARENT A + Att + $$CASE
	IF (NEGATE -1 @CLB)
	   (-2 A + Att + $$CASE)
	TO (-1 Cj + Coord) ;

SETPARENT A + Att + $$CASE
	IF (1 Comma)	
	   (NEGATE 2 @CLB)
	   (3 A + Att + $$CASE)
	TO (2 Cj + Coord) ;

SETPARENT A + Att + $$CASE
	IF (NEGATE -1 @CLB)
	   (-2 Comma)
	   (-3 A + Att + $$CASE)
	TO (-1 Cj + Coord + ("მაგრამ")) ;

# noun coordination
# simple NPs should have been built
SETPARENT NA + L + $$CASE
	IF (NEGATE p (*))
	   (NEGATE 1 @CLB)
	   (2 N + $$CASE)
	TO (1 Cj + Coord) ;

SETPARENT NA + $$CASE
	IF (NEGATE p (*))
	   (NEGATE -1 @CLB)
	   (-2 NA + L + $$CASE)
	TO (-1 Cj + Coord) ;

# apposition
SETPARENT N + Erg
	IF (NEGATE p (*))
	TO (Sccll (*) LINK -1 ("–") LINK -1 Prop + Erg) ;

ADD >APOS TARGET N + Erg
    IF (NEGATE 0 RELS)
       (p Prop + Erg) ;

# propagate PP
ADD PP TARGET Cj
    IF (rrc PP) ;

ADD PP:თვის TARGET Cj
    IF (rrc PP:თვის) ;

SETPARENT NAProp + $$CASE OR Pron + $$CASE
	IF (NEGATE p (*))
	   (NEGATE 1 @CLB)
	   (2 NAProp + $$CASE OR Pron + $$CASE)
	TO (1 Cj + Coord) ;

SETPARENT NAProp + $$CASE OR Pron + $$CASE
	IF (NEGATE p (*))
	   (NEGATE -1 @CLB)
	   (-2 NAProp + $$CASE OR Pron + $$CASE)
	TO (-1 Cj + Coord) ;

SETPARENT NAProp + $$CASE OR Pron + $$CASE
	IF (NEGATE p (*))
	   (NEGATE 1 @CLB)
	 # (2 NAProp + $$CASE OR Pron + $$CASE)
	   (2 (*) LINK pp NAProp + $$CASE OR Pron + $$CASE)
	TO (1 Cj + Coord) ;

SETPARENT NAProp + $$CASE OR Pron + $$CASE
	IF (NEGATE p (*))
	   (NEGATE -1 @CLB)
	   (llcc (*) LINK -2 NAProp + $$CASE OR Pron + $$CASE)
	TO (llcc (*) LINK -1 Cj + Coord) ;

ADD $$CASE Cj + Coord
    IF (c $$CASE - PP) ;     	

#ADD Dat Cj + Coord
#    IF (c Dat) ;

#SETPARENT Pron + Rel
#	TO (-1* NAProp - Att) ;

# doesn’t work
# SETPARENT NomHead TO (0 Aux) ;

#@@@
SETPARENT ErgHead - Pl
	TO (0* S:Erg + S:3Sg BARRIER CLB) ;

SETPARENT ErgHead + Pl
	TO (0* S:Erg + S:3 BARRIER CLB) ;

SETPARENT (Pron Pers 1 Sg Nom)
	TO (0* S:Nom + S:1Sg BARRIER CLB) ;
SETPARENT (Pron Pers 2 Sg Nom)
	TO (0* S:Nom + S:2Sg BARRIER CLB) ;
SETPARENT (Pron Pers 1 Pl Nom)
	TO (0* S:Nom + S:1Pl BARRIER CLB) ;
SETPARENT (Pron Pers 2 Pl Nom)
	TO (0* S:Nom + S:2Pl BARRIER CLB) ;
SETPARENT (Pron Pers 1 Sg Erg)
	TO (0* S:Erg + S:1Sg BARRIER CLB) ;
SETPARENT (Pron Pers 2 Sg Erg)
	TO (0* S:Erg + S:2Sg BARRIER CLB) ;
SETPARENT (Pron Pers 1 Pl Erg)
	TO (0* S:Erg + S:1Pl BARRIER CLB) ;
SETPARENT (Pron Pers 2 Pl Erg)
	TO (0* S:Erg + S:2Pl BARRIER CLB) ;
SETPARENT (Pron Pers 1 Sg Dat)
	TO (0* S:Dat + S:1Sg BARRIER CLB) ;
SETPARENT (Pron Pers 2 Sg Dat)
	TO (0* S:Dat + S:2Sg BARRIER CLB) ;
SETPARENT (Pron Pers 1 Pl Dat)
	TO (0* S:Dat + S:1Pl BARRIER CLB) ;
SETPARENT (Pron Pers 2 Pl Dat)
	TO (0* S:Dat + S:2Pl BARRIER CLB) ;

SETPARENT (Pron Pers 1 Sg Dat)
	TO (0* DO:Dat + DO:1Sg BARRIER CLB) ;
SETPARENT (Pron Pers 2 Sg Dat)
	TO (0* DO:Dat + DO:2Sg BARRIER CLB) ;
SETPARENT (Pron Pers 1 Pl Dat)
	TO (0* DO:Dat + DO:1Pl BARRIER CLB) ;
SETPARENT (Pron Pers 2 Pl Dat)
	TO (0* DO:Dat + DO:2Pl BARRIER CLB) ;

SETPARENT (Pron Pers 1 Sg Dat)
	TO (0* IO:Dat + IO:1Sg BARRIER CLB) ;
SETPARENT (Pron Pers 2 Sg Dat)
	TO (0* IO:Dat + IO:2Sg BARRIER CLB) ;
SETPARENT (Pron Pers 1 Pl Dat)
	TO (0* IO:Dat + IO:1Pl BARRIER CLB) ;
SETPARENT (Pron Pers 2 Pl Dat)
	TO (0* IO:Dat + IO:2Pl BARRIER CLB) ;

SET <S-DO*> = <S-DO> OR <S-DO-IO> ;

SETPARENT Pron + Poss + Refl + $$CASE
	IF (NEGATE p (*))
	TO (1 Pron + Refl + $$CASE) ;

# Postpositions

# coordinated arguments

#SETPARENT Cj + Coord
#	IF (NEGATE p (*))
#	   (ALL c Gen)
#	TO (rrc (*) LINK 1 <Gen>) ;

#SETPARENT Cj + Coord
#	IF (NEGATE p (*))
#	   (ALL c Dat)
#	TO (rrc (*) LINK 1 <Dat>) ;

#SETPARENT Cj + Coord
#	IF (NEGATE p (*))
#	   (ALL c Dat)
#	TO (rrc (*) LINK 1 <Dat/Gen>) ;

#SETPARENT Cj + Coord
#	IF (NEGATE p (*))
#	   (ALL c Gen)
#	TO (rrc (*) LINK 1 <Dat/Gen>) ;

# მას შემდეგ
SETPARENT Pron + Pers + Dat
	IF (NEGATE p (*))
	TO (1 <Gen>) ;

SETPARENT Gen - PP
	IF (NEGATE p (*))
	TO (rrccS (*) LINK 1 <Gen>) ;

SETPARENT Gen - PP
	IF (NEGATE p (*))
	TO (rrccS (*) LINK 1 <Dat/Gen>) ;

SETPARENT Dat - PP
	IF (NEGATE p (*))
	TO (rrccS (*) LINK 1 <Dat/Gen>) ;

SETPARENT Dat - PP
	IF (NEGATE p (*))
	TO (rrccS (*) LINK 1 <Dat>) ;

SETPARENT Inst - PP
	IF (NEGATE p (*))
	TO (rrccS (*) LINK 1 <Inst>) ;

SETPARENT Advb - PP
	IF (NEGATE p (*))
	TO (rrccS (*) LINK 1 <Advb>) ;

SETPARENT (PP:თან)
	IF (NEGATE p (*))
	TO (1 (<PP:თან>)) ;

SETPARENT Gen + Prop - PP
	IF (NEGATE p (*))
	# TO (1* NA - Att - Temp)
	TO (1 (*) LINK Spp NA - Att - Temp) ;

SETPARENT PP:მდე
	IF (NEGATE p (*))
	TO (-1 ("ვიდრე" Pp)) ;

SETPARENT Num
	IF (NEGATE p (*))
	TO (1 ("უფრო")) ;

SETPARENT Num
	IF (NEGATE p (*))
	TO (1 Num) ;

SETPARENT Num
	IF (NEGATE p (*))
	# TO (1*C NA - Att) ;
	TO (1 (*) LINK ppSC NA - Att) ;

# ??
SETPARENT PP:დან
	IF (NEGATE p (*))
	TO (1*C ("შორს") OR ("ახლოს")) ;

SETPARENT PP:თან
	IF (NEGATE p (*))
	TO (0*C ("შორს") OR ("ახლოს") BARRIER CLB) ;

# ვერც ამაზე
SETPARENT Neg + Foc
	IF (NEGATE p (*))
	TO (1 (*) LINK Spprr NAProp | Pron) ;

ADD >OBL TARGET PP:დან
    IF (NEGATE 0 RELS)
       (p ("შორს") OR ("ახლოს")) ;

ADD >OBL TARGET PP:თან
    IF (NEGATE 0 RELS)
       (p ("შორს") OR ("ახლოს")) ;

SETPARENT ("სხვ[ა]" Nom)
	IF (NEGATE p (*))
	TO (1 Pron + Neg | Pron + SIndef) ;

#SETPARENT Dat - PP
#	IF (NEGATE p (*))
#	TO (1 <Dat/Gen>) ;

SETPARENT DatHead
	IF (NEGATE p (*))
	   (NOT 1 (Pp <Dat/Gen>))
	   (NOT 1 (Pp <Dat>))
	   (NOT 0 PP)
	TO (0* <S-DO*> + DO:Dat + DO:3 BARRIER CLB) ;

# todo: look at Sg/Pl
#SETPARENT DatHead
#	IF (NEGATE p (*))
#	TO (0* <S-DO> + S:Dat + S:3 BARRIER CLB) ;

SETPARENT NomHead
	IF (NEGATE p (*))
	   # Pers/Dem disambiguation, formulate differently!
	   (NEGATE 1* NomHead BARRIER V OR CLBarg OR Rel + Nom OR Comma)
	TO (0* S:Nom + S:3 OR 
	       DO:Nom + DO:3 - COMPVerbOPT
	       BARRIER CLBarg OR Rel + Nom) ;

#SETPARENT ALLOWLOOP NomHead
#	IF (NEGATE p (*))
#	TO (0 Aux) ;

# PRLs; TODO: look at case
SETPARENT NomHead - Pers
	IF (NEGATE p (*))
	TO (0* PREDVerb + V BARRIER CLB) ;

SETPARENT Pers
	IF (NEGATE p (*))
	   (NEGATE 1* NomHead BARRIER V OR CLBarg OR Rel + Nom OR Comma)
	TO (0* PREDVerb + V BARRIER CLB) ;

SETPARENT NA + Nom + OldPl - PP
	TO (0* <S-DO> + DO:Nom + DO:3Pl BARRIER CLB) ;

SETPARENT A + Nom - Att - PP
	IF (NEGATE p (*))
	TO (0* PREDADJVerb BARRIER CLB) ;

# remove reduced case if there is no following possible head
#n-REMOVE $$CASE + Att
#       IF (NEGATE 1 (*) LINK pp Head + $$CASE) ;

SETPARENT ("დრო" Dat)
	IF (-1 ("ის" Dat))
	TO (0* V) ;

SETPARENT DatHead
	IF (NEGATE p (*))
	   (NOT 1 (Pp <Dat/Gen>))
	   (NOT 1 (Pp <Dat>))
	   (NOT 0 PP)
	TO (0* S:Dat + S:3 OR IO:Dat + IO:3 OR DO:Dat + DO:3 BARRIER @CLB) ;

SETPARENT Gen - PP
	IF (NEGATE p (*))
	# TO (1*C A - Att) ;
	TO (1 (*) LINK ppSC NA - Att) ;

LIST COMPNoun = "სურვილ·ი"
     	      	"ნებ[ა]"
     	      	"ნებ[ა]/ნებ"
     	      	"იმედ·ი"
		"მიზეზ·ი"
		"ილუზი[ა]"
		"გა·გონებ[ა]/გონ" ; # and many more

# BARRIER V?
SETPARENT ("რომ") # + Cj
	IF (NEGATE p (*))
	TO (-1* COMPNoun) ;

# resumptive pronoun, ამიტომ V …, რომ
SETPARENT ("<რომ>" Cj Sub)
	IF (NEGATE p (*))
	# TO (-1* V LINK -1 ("ამიტომ")) # doesn't work!
	TO (-1* V LINK -1 Adv + Causal) ;

SETPARENT ("<რომ>" Cj Sub)
	IF (NEGATE p (*))
	TO (-1* <S-DO-IO> + DO:3 BARRIER V) ;

SETPARENT ("<რომ>" Cj Sub)
	IF (NEGATE p (*))
	TO (-1* <S-DO> + COMPVerb + DO:3 BARRIER V) ;

#SETPARENT ("<რომ>" Cj Sub)
#	TO (1* V BARRIER V) ;

SETPARENT ("<რომ>" Cj Sub)
	IF (NEGATE p (*))
	TO (-1* <S-IO> + IO:3 BARRIER V) ;

#SETPARENT V
#	TO (-1* ("<რომ>" Cj Sub) BARRIER V) ;

SETPARENT VN + Nom
	IF (NEGATE p (*))
	TO (0* ("ნდომ[ა]/ნდ") + DO:3 BARRIER CLB) ;

SETPARENT OPT
	IF (NEGATE p (*))
	TO (-1* ("შე·საძლო/ძლ") BARRIER CLB) ;

# adjective coordination
SETPARENT Cj + Coord
	IF (NOT 0 @CLB)
	   (1 Att)
	   (2 NA - Att)
	   (-1 Att)
	TO (2 (*)) ;

SETPARENT Cj + Coord + ("მაგრამ")
	IF #(NOT p (*))
	   (NOT 0 @CLB)
	   (1 Att)
	   (2 NA - Att)
	   (-1 Comma)
	   (-2 Att)
	TO (2 (*)) ;

# უფრო … ვიდრე
# in progress

SETPARENT Compar
	IF (NEGATE p (*))
	TO (-1* ("უფრო") LINK 1 (*)) ;

SETPARENT V
	IF (NEGATE p (*))
	TO (-1* ("ვიდრე" Cj Compar)) ;

SETPARENT N
	IF (NEGATE p (*))
	TO (Sccll (*) LINK -1 ("ვიდრე" Cj Compar)) ;

ADD >OBL-COMPAR TARGET Compar - RELS
    IF (-1 ("უფრო")) ;

ADD >OBL-COMPAR TARGET Compar - RELS
    IF (s ("უფრო")) ;

ADD >OBJ TARGET (*)
    IF (p Compar) ;


# იმ შემთხვევაში თუ
LIST COMPNounTu = "შე·მთხვევ\\[ა\\].*"r ;

# for თუ როგორ, თუ რომელი, etc. (elaborate!)
# LIST COMPVerbTu = "მი·ხვდომ[ა]/ხვდ" ;

SETPARENT ("რომ") # + Cj
	IF (NEGATE p (*))
	TO (-2 V LINK -1* COMPNoun BARRIER V) ;

SETPARENT ("თუ") + Cj
	IF (NEGATE p (*))
	TO (-1* COMPNounTu BARRIER V) ;

SETPARENT ("თუ") + Cj
	IF (NEGATE p (*))
	TO (-2 V LINK -1* COMPNounTu BARRIER V) ;

# should mark Cj + Coord for being verb conjoining
# is @CLB enough?
SETCHILD Cj + Sub OR Compl
	IF (NEGATE c (*)) # can have only one child, so this is OK
	TO (1* Cj + Coord + @CLB) ;

SETCHILD Cj + ("როგორც")
	 IF (NEGATE c (*))
	 TO (1 Adv + Temp) ;

ADD >ADV TARGET Adv + Temp
    IF (NEGATE 0 RELS)
       (-1 Cj + ("როგორც")) ;

SETCHILD Cj + Sub OR Compl
	IF (NEGATE c (*)) # can have only one child, so this is OK
	TO (1* V) ;

# მანძლიზე,… როცა
SETPARENT ("როცა") + Cj
	IF (NEGATE p (*))
	TO (-1* Temp OR ("მანძილ·ი") BARRIER V) ;

# იმისა, რომ…
SETPARENT ("რომ") + Cj
	IF (NEGATE p (*))
	TO (-1 Comma LINK -1 Pron + Pers + 3 + Gen + L) ;

# ის, თუ…
SETPARENT ("თუ") + Cj + Sub
	IF (NEGATE p (*))
	TO (-1 Comma LINK -1 Pron + Pers + 3) ;

# try to attach to the left
SETPARENT Cj + Sub OR Compl
	IF (NEGATE p (*))
	TO (-1* V) ;

# then to the right: როგორც კი …, … V
SETPARENT Cj + Sub # OR Compl
	IF (NEGATE p (*))
	TO (1* V) ;

# V თუ არა
SETPARENT V
	IF (NEGATE p (*))
	   (1 ("თუ") LINK 1 Neg)
	TO (-1* V) ;

SETPARENT V
	IF (NEGATE p (*))
	   (1 ("თუ") LINK 1 Neg)
	TO (1* V) ;

# წარმოიდგენდა, როგორ…
SETPARENT Adv + Int
	IF (NEGATE p (*))
	TO (1* V) ;

# ასე კარგად; should perhaps be Adv Deg?
SETPARENT ("ასე") OR ("ისე")
	IF (NEGATE p (*))
	TO (1 A + Advb) ;

SETPARENT ("კი" Disc)
	IF (NEGATE p (*))
	TO (-1 (*)) ;

LIST VerbAttachableAdv = Temp Loc Sent Mann Iter Comm Disc Repet Causal ;

SETPARENT Adv + VerbAttachableAdv OR PP OR A + Advb + Sg OR ("მაშინვე") #more?
	IF (NEGATE p (*))
	   (NOT 0 Rel)
	TO (1* V OR VN OR Part BARRIER CLBwords | Cj + Sub) ;

SETPARENT Adv + VerbAttachableAdv OR PP OR A + Advb + Sg #more?
	IF (NEGATE p (*))
	   (NOT 0 Rel)
	TO (-1* V OR VN OR Part BARRIER CLBwords | ("რომ")) ;

SETPARENT Adv + Rel
	IF (NEGATE p (*))
	TO (1* V BARRIER CLBwords | Cj + Sub) ;

SETPARENT Advb - Att
	IF (NEGATE p (*))
	TO (-1* V BARRIER CLB) ;

SETPARENT N + Dat + Temp
	IF (NEGATE p (*))
	TO (-1* V BARRIER CLB) ;

# these set only one child! See below.
#SETCHILD V
#	TO (-1* Cj + PP BARRIER CLB) ;

#SETCHILD V
#	TO (-1* Adv + VerbAttachableAdv BARRIER CLB) ;

#SETCHILD V
#	TO (-1* PP LINK NOT p Cj + Coord BARRIER CLB) ;

#SETCHILD V
#	TO (-1* Advb - Att BARRIER CLB) ;

#SETCHILD V
#	TO (-1* N + Dat + Temp BARRIER CLB) ;

# distinguish between -1* and 1*?
#SETPARENT Inst - Att - PP
#	IF (NEGATE p (*))
#	TO (0* V); # BARRIER CLB) ;

SETPARENT ("მიერ" Pp)
	IF (NEGATE p (*))
	TO (1* V OR Part OR VN BARRIER Cj + Sub OR @CLB) ;

# ავღანეთში მოქმედი თალიბები
SETPARENT PP OR POSTP OR Inst - Att - PP
	IF (NEGATE p (*))
	   (NOT 0 Rel)
	TO (1* Part OR V OR VN - Gen OR VN + PP BARRIER CLB) ;

SETPARENT PP - Rel OR POSTP - Rel OR Inst - Att - PP - Rel
	IF (NEGATE p (*))
	TO (0* V BARRIER Cj + Sub OR @CLB) ;

# if no verb was found…
SETPARENT PP - Rel OR POSTP - Rel OR Inst - Att - PP - Rel
	IF (NEGATE p (*))
	TO (-1* Head) ;

SETPARENT Modal
	IF (NEGATE p (*))
	TO (1 V OR VN) ;

SETPARENT Modal
	IF (NEGATE p (*))
	TO (-1 V OR VN) ;

SETPARENT Adv + Foc
	IF (NEGATE p (*))
	TO (1 V) ;

SETPARENT Adv + Foc
	IF (NEGATE p (*))
	TO (1 Neg LINK 1 V) ;

SETPARENT Adv + Deg
	IF (NEGATE p (*))
	   (NOT 1 Punct)
	TO (1 (*)) ;

# … არის, რომ …
SETPARENT ("რომ") # + Cj
	IF (NEGATE p (*))
	TO (-1* PREDVerb) ;

LIST TemporalExp = "მანძილ·ი" "მომენტ·ი" ;

SET TemporalExp = TemporalExp ;

SETPARENT ("როცა") | ("როდესაც")
	TO (-1* Temp OR TemporalExp) ;

# ერთი წლის წინათ, როცა…
SETPARENT ("როცა") | ("როდესაც")
	TO (-1* Temp OR TemporalExp LINK 1 Pp) ;

SETPARENT ("როცა") | ("როდესაც")
	IF (NEGATE p (*))
	TO (-1* V) ;

SET Hum3 = N + Hum - Att OR Anthr OR Pron + Pers + (3) ;

# Hum Noun -> head of relative clause
SETPARENT V + S:Erg
	IF (lc Pron + Rel + Erg)
	TO (lc Pron + Rel LINK -1* Hum3) ;

# Noun -> head of relative clause
SETPARENT V
	IF (NEGATE p (*))
	   (lcc Pron + Rel OR Adv + Rel)
	TO (lcc Pron + Rel OR Adv + Rel LINK -1* NAProp - Att OR Pron + Pers + (3)) ;

# free relative
SETPARENT V
	IF (NEGATE p (*))
	   (lc Pron + Rel + ("ვინ"))
	TO (lc Pron + Rel LINK -1* V + S:Nom + S:3Sg) ;

SETPARENT NomHead
	IF (NEGATE p (*))
	TO (1* Pron + Rel LINK p V LINK 1* S:Nom + S:3) ;

SETPARENT DatHead
	IF (NEGATE p (*))
	TO (1* Pron + Rel LINK p V LINK 1* S:Dat + S:3) ;

SETPARENT ErgHead
	IF (NEGATE p (*))
	TO (1* Pron + Rel LINK p V LINK 1* S:Erg + S:3) ;

#SETPARENT V
#	IF (NEGATE p (*))
#	TO (-1* Cj + Sub BARRIER V) ;

#SETPARENT V
#	IF (NEGATE p (*))
#	TO (-1* ("რომ" Cj Sub) OR ("თუ" Cj Sub) BARRIER V) ;

SETPARENT V
	IF (NEGATE p (*))
	TO (-1* Cj + Coord + @CLB BARRIER ("რომ") OR ("თუ")) ;

SETPARENT V
	IF (NEGATE p (*))
	TO (1* Cj + Coord + @CLB BARRIER V) ;

SETPARENT PluPerf OR Opt # OPT
	IF (NEGATE p (*))
	TO (-1* COMPNoun) ;

SETPARENT Head + Voc
	IF (NEGATE p (*))
	   (-1 Comma)
	TO (-1* V) ;

ADD >ADV TARGET Converb - RELS ;

ADD >ADV TARGET ("როგორც") + Adv - RELS
    IF (p N) ;

ADD >ADV TARGET N
    IF (NEGATE 0 RELS)
       (-1 ("როგორც") + Adv)
       (p V | Part | VN) ;

# refine
# V თუ არა
SETPARENT ("თუ")
	IF (1 ("<არა>"))
	TO (-1 V) ;

SETPARENT ("<არა>")
	IF (-2 V)
	TO (-1 ("თუ")) ;

ADD >AUX TARGET ("თუ") - RELS
    IF (1 ("<არა>"))
       (-1 V) ;

ADD >MWE TARGET ("<არა>")
    IF (-2 V)
       (-1 ("თუ")) ;

SETPARENT V
	IF (1 >AUX + ("თუ") LINK 1 Neg)
	TO (-1* V + COMPVerb) ;

SETPARENT V
	IF (NEGATE p (*))
	TO (-1* V + COMPVerb BARRIER V) ;

SETPARENT V
	IF (NEGATE p (*))
	TO (rrcc (*) LINK 1* ("–") LINK 1 V + COMPVerb) ; # BARRIER V) ;

ADD >COMP TARGET V - RELS
    IF (p V + COMPVerb) ;

# add tense concord
SETPARENT V
	IF (0 OPT)
	TO (-1* COMPVerbOPT) ;

SETPARENT V
	IF (0 OPT)
	TO (-1* COMPVNOPT) ;

ADD >COMP TARGET OPT
    IF (p COMPVerbOPT OR COMPVNOPT) ;

SETPARENT FirstName
	TO (1 LastName) ;

SETPARENT Anthr + Abbrev
	TO (1 LastName) ;

# ??
ADD >COMP TARGET V - RELS
    IF (1 >AUX) ;

# coordinated verbs
SETPARENT Cj + Coord
	IF (NEGATE p (*))
	   (c V)
	TO (-1* ("რომ")) ;

SETPARENT V
	IF (NEGATE p (*))
	TO (-1* ("რომ")) ;

ADD >XOBJ TARGET Part - RELS
    IF (p <AuxTrans> + Nom) ;

# interrogatives are prls if allowed
ADD >PRL TARGET Int + Nom - RELS
    IF (p PREDVerb)
       (NEGATE s >PRL) ;

# only for one-place PREDVerb?
ADD >PRL TARGET Nom - RELS
    IF (p PREDVerb LINK 1 Comma LINK 1 ("რომ"))
       #(s >COMP) # not yet assigned
       (NOT 0 1 | 2)
       (NEGATE s >PRL) ;

# სხვა ვინმე იქნებოდა (general?)
ADD >PRL TARGET SIndef + Nom - RELS
    IF (p PREDVerb)
       (NEGATE s >PRL) ;

ADD >PRL TARGET A + Nom - Att - PP - RELS
    IF (p V + PREDADJVerb) ;

ADD >PRL TARGET A - RELS
    IF (p PREDVerb + S:Nom + S:3 - Inv) ;

ADD >PRL TARGET A - RELS
    IF (p PREDVerb + DO:Nom + DO:3 + Inv) ;

# Nom Subject
ADD >SUBJ TARGET NomHead - RELS
    IF (p V + S:Nom + S:3)
       (NEGATE s >SUBJ) ;

ADD >SUBJ TARGET Pron + Nom + (1)
    IF (p V + S:Nom + S:1)
       (NEGATE 0 RELS)
       (NEGATE s >SUBJ) ;

ADD >SUBJ TARGET Pron + Nom + (2)
    IF (p V + S:Nom + S:2)
       (NEGATE 0 RELS)
       (NEGATE s >SUBJ) ;

ADD >SUBJ TARGET NomHead OR Pron + Nom
    IF (p Aux)
       (NOT 0 RELS)
       (NOT s >SUBJ) ;

# >PRL if Nom Subj already found. Refine!
ADD >PRL TARGET NomHead OR Pron + Nom
    IF (p V + S:Nom + PREDVerb)
       (NEGATE 0 RELS)
       (s >SUBJ) ;

# ბრმა ვარ
ADD >PRL TARGET NomHead OR Pron + Nom
    IF (p AUX + S:12)
       (NEGATE s >PRL)
       (NEGATE 0 RELS) ;

#@@@ Erg Subject
ADD >SUBJ TARGET ErgHead - RELS OR Pron + Erg - RELS
    IF (p V + S:Erg)
       (NEGATE s >SUBJ) ;

# Dat Subject
ADD >SUBJ TARGET DatHead OR Pron + Dat - PP
    IF (p V + S:Dat)
       (NEGATE 0 RELS)
       (NEGATE s >SUBJ) ;

#ADD >SUBJ TARGET Cj
    #IF (p V + S:Dat)
       #(NEGATE 0 RELS)
       #(NEGATE s >SUBJ)
#        ;

ADD >COMP TARGET ("რომ") # + Cj
    IF (NEGATE 0 RELS)
       (p PREDVerb | COMPVerb | COMPNoun) ;

# make this for თუ without როგორ, რომელი… etc.
# add disambiguation rule for თუ Cj/Adv

#ADD >COMP TARGET ("თუ") # + Cj
#    IF (NEGATE 0 RELS)
#       (p COMPVerbTu) ;

ADD >COMP TARGET ("თუ") # + Cj
    IF (NEGATE 0 RELS)
       (p COMPVerb) ;

ADD >COMP TARGET ("თუ") + Cj
    IF (NEGATE 0 RELS)
       (p COMPNounTu) ;

# better analysis?
# იშვიათად თუ ნახავდით
SETPARENT ("თუ") + Adv
	IF (NEGATE p (*))
	TO (1 V) ;

ADD >ADV TARGET ("თუ") + Adv
    IF (NEGATE 0 RELS)
       (p V) ;

# როგორც წესი
SETPARENT ("როგორც") + Adv
	IF (NEGATE p (*))
	TO (1 N) ;

# >PRL if Nom arg already found. Refine!
ADD >PRL TARGET PastPart + Nom
    IF (p V + DO:Nom + PREDVerb)
       (NEGATE 0 RELS) ;

ADD >OBJ TARGET NomHead OR Pron + Pers + Nom
    IF (NEGATE 0 RELS)
       (p V + DO:Nom + Inv)
       (NEGATE s >OBJ) ;

ADD >DO TARGET NomHead OR Pron + Pers + Nom
    IF (NEGATE 0 RELS)
       (p V + DO:Nom)
       (NEGATE s >DO | >OBJ) ;

# >PRL if Nom arg already found. Refine!
ADD >PRL TARGET NomHead OR Pron + Pers + Nom
    IF (p V + DO:Nom + PREDVerb)
       (NEGATE 0 RELS)
       (s >DO) ;

ADD >IO TARGET DatHead + Hum - RELS OR Pron + Pers + Dat - PP - RELS
    IF (p V + IO:Dat)
       (NEGATE s >IO) ;

ADD >DO TARGET DatHead - RELS OR Pron + Pers + Dat - PP - RELS
    IF (p V + DO:Dat)
       (NEGATE s >DO) ;

ADD >IO TARGET DatHead - Temp - RELS
    IF (p V + IO:Dat + IO:3)
       (NEGATE s >IO) ;

ADD >IO TARGET Pron + Pers + Dat + (1) + Sg - PP - RELS
    IF (p V + IO:Dat + IO:1Sg)
       (NEGATE s >IO) ;

ADD >IO TARGET Pron + Pers + Dat + (1) + Pl - PP - RELS
    IF (p V + IO:Dat + IO:1Pl)
       (NEGATE s >IO) ;

ADD >IO TARGET Pron + Pers + Dat + (2) + Sg - PP - RELS
    IF (p V + IO:Dat + IO:2Sg)
       (NEGATE s >IO) ;

ADD >IO TARGET Pron + Pers + Dat + (2) + Pl - PP
    IF (p V + IO:Dat + IO:2Pl)
       (NEGATE 0 RELS)
       (NEGATE s >IO) ;

ADD >ADV TARGET Temp + Dat
    IF (NEGATE 0 RELS)
    #IF (p V + IO:Dat)
    #   (NEGATE p V LINK c >IO)
     ;

ADD >NEG TARGET Adv + Neg
    IF (NEGATE 0 RELS)
    # IF (p V)
    ;

# adverbial sentence (dispatch on conjunction!)
ADD >ADV TARGET Cj + Sub
   IF (NEGATE 0 RELS) ;

#ADD (>COMP) TARGET Cj
#    IF (p V) ;

ADD >NAMEMOD TARGET Att + FirstName - RELS;

ADD >NAMEMOD TARGET Anthr + Abbrev - RELS
    IF (p LastName) ;

ADD >NUM TARGET Num - RELS ;

ADD >ATR TARGET Att - Qual - RELS ;

ADD >ATR TARGET Att - RELS
    IF (p N) ;

# postpositions
ADD >OBJ TARGET (*)
    IF (NEGATE 0 RELS)
       (p POSTP) ;

# prepositions
ADD >OBJ TARGET (*)
    IF (NEGATE 0 RELS)
       (p PREP) ;

# Adj coordination
ADD >ATR TARGET Cj + Coord
    IF (NEGATE 0 RELS)
       (cc A + Att) ;

ADD >PRED TARGET Cj + Coord
    IF (NEGATE 0 RELS)
       (c V) ;

ADD V TARGET Cj + Coord
    IF (NEGATE 0 V)
       (c V) ;

ADD >DET TARGET Pron + Dem
    IF (NEGATE 0 RELS)
       (p NA) ;

ADD >POSS TARGET Pron + Poss
    IF (NEGATE 0 RELS) ;

ADD >QUAL TARGET Qual + Att - RELS
    IF (p Prop) ;

#ADD >POSS TARGET Gen
#    IF (NEGATE 0 RELS)
#       (p NA) ;

ADD >GEN TARGET Gen - PP
    IF (NEGATE 0 RELS)
       (p NA) ;

ADD >OBL TARGET (PP:თვის)
    IF (NEGATE 0 RELS)
       (p VN OR V) ;

ADD >AG TARGET ("მიერ" Pp)
    IF (NEGATE 0 RELS)
       (p VN OR V OR Part) ;

ADD >PRED TARGET V - RELS IF (p Cj | Compl) ;

ADD >REL TARGET V
    IF (p NAProp - Att OR Pron + Pers + (3))
       (cc Pron + Rel OR Adv + Rel) ;

ADD >REL TARGET V
    IF (p V + S:Nom + S:3Sg)
       (c Pron + Rel) ;

# top-level verbs
ADD >PRED TARGET V IF (NEGATE 0 RELS) (NOT p (*)) ;

SETPARENT Adv + VerbAttachableAdv OR PP OR Advb OR Inst
	IF (NEGATE p (*))
	TO (1* V); # BARRIER CLB) ;

# not sure why c (*) is necessary
SETPARENT Adv + VerbAttachableAdv OR PP
	IF (NEGATE p (*))
	TO (c (*) LINK rc* (*) LINK 1* V) ;

#SETPARENT PP
#	TO (c (*) LINK rc* (*) LINK 1* V) ;

ADD >AUX TARGET Disc
    IF (NEGATE 0 RELS) ;

# ასე კარგად
ADD >ADV TARGET Adv
    IF (NEGATE 0 RELS)
       (p Advb) ;

ADD >AUX TARGET Adv + Sent
    IF (NEGATE 0 RELS)
       (p V) ;

ADD >PRL TARGET Advb - RELS
    IF (NEGATE 0 RELS)
       (p AdvbVerb) ;

# where is the border between ADV and ADJUNCT?
ADD >ADV TARGET Adv | Advb - FutPart # | Inst | PP | POSTP
    IF (NEGATE 0 RELS)
       #(NEGATE c (*))
       (p V | Part | VN) ;

# purposive Advb
ADD >ADV TARGET Advb + FutPart
    IF (NEGATE 0 RELS)
       (p V | Part | VN) ;

# ADD >ADV TARGET ("შორს") OR ("ახლოს")
#    IF (p V OR Part OR VN) ;

ADD >OBL TARGET PP:თვის - RELS
       (p Head) ;

ADD >ADV TARGET Inst | PP | POSTP
    IF (NEGATE 0 RELS)
       (p Head) ;

ADD >ADV TARGET Adv + Deg OR (".*ობით"r Adv)
    IF (NEGATE 0 RELS) ;

ADD >MODAL TARGET Modal
    IF (NEGATE 0 RELS) ;

# focus particle attached to following NA
SETPARENT Adv + Foc
    IF (NEGATE p (*))
    TO (1 Head) ;

ADD >AUX TARGET Adv + Foc
    IF (NEGATE 0 RELS) ;
  #     (p V) ;

ADD >ADV TARGET Adv + Sent
    IF (NEGATE 0 RELS)
       (p V) ;

# propagate GF from coordination to conjuncts
ADD $$RELATION TARGET NAProp OR Pron
    IF (NEGATE 0 RELS)
       (p Cj + Coord + $$RELATION) ;

# SETPARENT (<MWE>) TO (-1 (*)) ;
# ADD >MWE TARGET (<MWE>) ;

#SETPARENT Punct - Dash TO (-1* >PRED) ;

LIST LQuote = "<„>" "<»>" ;
LIST RQuote = "<”>" "<«>" ;

SETPARENT LQuote IF (NEGATE p (*)) TO (1 (*)) ;
SETPARENT RQuote IF (NEGATE p (*)) TO (-1 (*)) ;
SETPARENT Quote  IF (NEGATE p (*)) TO (-1 (*)) ;
SETPARENT Dash   IF (NEGATE p (*)) TO (1 (*)) ;

SETPARENT Punct IF (NEGATE p (*)) TO (-1 (*)) ;
SETPARENT Punct IF (NEGATE p (*)) TO (1 (*)) ;

ADD >QUOTE TARGET Quote - RELS ;
ADD >QUOTE TARGET Dash - RELS ;

ADD >P TARGET Punct IF (NEGATE 0 RELS) ;

ADD >VOC TARGET Voc IF (p V) ;

# copy
#SETPARENT (*)
#	IF (NEGATE p (*))
#	TO (-1* Cj + Sub BARRIER V) ;

# VP coordination
SETPARENT V
	IF (NEGATE p (*))
	TO (0* Cj + @CLB - ("მაგრამ") BARRIER V) ;

SETPARENT Cj + Coord + @CLB
	IF (NEGATE p (*))
	TO (0* ("მაგრამ") + Cj + @CLB) ;

SETPARENT V
	IF (NEGATE p (*))
	TO (0* Cj + @CLB) ;	  

SETPARENT Neg + L
	IF (-1 ("ოღონდ"))
	TO (1 (*) LINK p* (*) - ("ოღონდ") ) ;

SETPARENT Cj + Coord
	IF (-1 BOS)
	TO (1* V) ;

ADD >AUX TARGET Cj + Coord - RELS
    IF (p V) ;

SETPARENT Cj + Coord
	IF (NEGATE p (*)) (-1 BOS)
	TO (1 (*) LINK p* (*)) ;

ADD >VOC TARGET Voc - RELS ;

SETPARENT ("კარგი" Interj)
	TO (1 ("რა" Interj)) ;

ADD >MWE TARGET ("კარგი") + Interj - RELS
    IF (1 ("რა" Interj)) ;

ADD >INTERJ TARGET Interj - RELS ;

SETPARENT N
	IF (NEGATE p (*))
	TO (-1* ("<ჯანდაბას>")) ;

ADD >OBL N - RELS
    IF (p ("<ჯანდაბას>")) ;

SECTION

# the rest
SETPARENT (*)
	IF (NEGATE p (*))
	TO (0* V) ;

SETPARENT (*)
	IF (NEGATE p (*))
	TO (0* VN) ;

#SETPARENT (*)
#	IF (NEGATE p (*))
#	TO (-1* (>>>)) ;

ADD (>??) TARGET (*) IF (NEGATE 0 RELS) ; # rest

REMOVE (*) - RELS ;

REMOVE (NonStand) ;





END
