# ============================================ #
# Abkhaz disambiguator                         #
# ============================================ #

# see https://edu.visl.dk/cg3/single/ for CG documentation

# Questions:

# phrases marked by ҳәа which are not complements of quotation verbs should
# be >ADVCL or >ADVCL:QUOTE
#

# add rules: DO:Ad => -1 cannot be Pron Pers 1Sg etc.

# tags taken from abkhaz-noun.fst and abkhaz-verb.fst Sigma lists
STRICT-TAGS += Abbrev Abs Cnv Adhort 
       Adj Adv Advb Again AgainPfx Agit Alas Anthr Aor Approx
       AsIf AsLongAs Bracket Card Caus Cj Coll Colon Comma 
       Cond-I Cond-II Conj-I Conj-II Connect Coord Cop
       Cs:Rec Cs:Rel Cs:1Pl Cs:1Sg 
       Cs:2Pl Cs:2SgF Cs:2SgM Cs:3Pl Cs:3SgF Cs:3SgM Cs:3SgNH 
       DO:Ad DO:Indef DO:Rel DO:1Pl DO:1Sg DO:2Pl DO:2SgF 
       DO:2SgM DO:3 DO:3SgH DO:ҿ DO:ҿа́а Dash Date Deict 
       Dem Det [Det] Digits Dist Dyn Ellipsis Emph Encl:Every Encl:Single 
       Encl:Really Encl:гьы Encl:еиҧш Encl:цқьа Encl:ҵәҟьа 
       EveryTime Excess ExclPoint F FPv:аа FPv:ла́ FPv:лы́ 
       FPv:на FPv:ны FPv:ҩа FPv:ҩы FarFrom Fin FromWhere 
       Fut-I Fut-II H How Hydronym Hyphen IO:Rec IO:Rel IO:1Pl
       IO:1Sg IO:2Pl IO:2SgF IO:2SgM IO:3Pl IO:3SgF IO:3SgM 
       IO:3SgNH Impf Impv Indef Indet InferPast InferPres Int 
       IntMark Intens Interj Interrogative Intr Iter Just LHP 
       LO:Rec LO:Rel LO:1Pl LO:1Sg LO:2Pl LO:2SgF LO:2SgM 
       LO:3Pl LO:3SgF LO:3SgM LO:3SgNH Lab LastName M Med NH 
       Name Neg NonFin Noun Num Pfx NumPfx RelAdj
       Mult Oblig-I Oblig-II OneOf Opt Ord Org 
       PP PP:аан PP:ахь PP:ахьынтә PP:ахьынӡа PP:да
       PP:зы PP:ла PP:ан PP:ны PP:н PP:нтә PP:нӡа PP:шьҭахь PP:ҟа 
       PP:ҟны PP:ҟынтә PP:ҟынӡа PP:ҿы PP:ҿы́ PP:ҿынтә 
       PP:ҿынӡа Paren Past PastIndef Patr Perf Period Pers 
       Pl Place PluPerf
       PO:Rec PO:Rel PO:1Pl PO:1Sg PO:2Pl PO:2SgF PO:2SgM 
       PO:3Pl PO:3SgF PO:3SgM PO:3SgNH
       Poss:Rel Poss:1Pl Poss:1Sg Poss:2Pl Poss:2SgF Poss:2SgM
       Poss:3Pl Poss:3SgF Poss:3SgM Poss:3SgNH
       Pred Pres Pron Prop Prox Prt Pass StatPass Punct 
       Pot Purp Quant Q QFromWhere QSize QToWhere QWhat QWhere QWho Size
       Q:Ad Q:Rel Q:1Pl Q:1Sg Q:2Pl Q:2SgF Q:2SgM 
       Q:3 Q:3SgH RHP RO:Rec RO:Rel RO:1Pl RO:1Sg RO:2Pl 
       RO:2SgF RO:2SgM RO:3Pl RO:3SgF RO:3SgM RO:3SgNH Range 
       Really Rec Refl Refl:1Pl Refl:1Sg Refl:2Pl Refl:2Rel 
       Refl:2SgF Refl:2SgM Refl:3Pl Refl:3SgF Refl:3SgM 
       Refl:3SgNH Rel:Pl Reln:Against Reln:For Reln:Invol Reln:Pot 
       Reln:TogetherWith Reln:With Res Rhet Roman Root Semicolon
       Sg Since Star Stat StatDer Sub Subj Symbol Together 
       S:Ad S:Indef S:Rec S:Rel S:1Pl S:1Sg S:2Pl S:2Sg S:2SgF
       S:2SgM S:3Pl
       S:3SgF S:3SgM # transitive verbs
       S:3SgNH # transitive verbs
       S:3SgH S:3 # intransitive verbs
       [LO:3SgNH]
       Time
       Quote Left Right
       Redup
       ToWhere Tr TrCaus Until V VCoord VN WhEver When Where 
       Why 1Pl 1Sg 2Pl 2SgF 2SgM 3Pl 3Sg 3SgF 3SgM 3SgNH  [S:3SgNH]
       <Manner>
       <Relax> <NoLex> <HuntingLang> <NumPfxNoHyphen> <PreAdj> <Deriv> <PlStem>
       >ROOT ROOT
       >NSUBJ
       >PREDLINK # remove!
       >DET >NUMMOD
       >FLAT:NAME >PUNCT
       >ADVMOD
       >ADVMOD:Q
       >??
       >CONJ
       >PARATAXIS
       >NMOD >NMOD:POSS >NMOD:QUOTE
       >COMP # ?
       >XCOMP # open clausal complement (predicative/clausal complement without own subject)
       >CCOMP # core argument clause
       # >CCOMP:PRED
       # >CCOMP:RELCL
       >CSUBJ
       >CCOMP:OBJ
       >CCOMP:QUOTE
       >CCOMP:PURP
       >CCOMP:IOBJ
       >XCOMP:LO
       >CCOMP:LO
       >CCOMP:RO
       
       >OBL
       >OBJ
       >OBJ:LO
       >OBJ:RO
       >OBJ:PO
       >OBJ:POSS
       >ADVCL
       >ADVCL:COND
       >ADVCL:CONV
       >ADVCL:COMPAR
       >ADVCL:QUOTE
       >ADVCL:SEQ # preliminarily called sequential adverbial clause (of PastIndef and Aor)
       >IOBJ
       >MARK
       >AMOD
       >CASE
       >CC
       >ACL
       >ACL:RELCL
       >APPOS
       >VOCATIVE
       >DISCOURSE
       >COMPOUND:PRT
       >COMPOUND:PRED
       >COMPOUND
       >FLAT
       >COP
       CopNounFin
       <Lemma> <LemmaLC>
       <Sel> ;

# OPTIONS += safe-setparent ;

# run like:
# cat test.vrt | vislcg3 --grammar abk-dis.rle --trace > test.dis

# OBS: do not use [0], [1] etc. as tags since they are used internally in the Lisp interface

# Rules to implement:
#
# in NP -> N + Adj, N cannot be Indet?

MAPPING-PREFIX = > ;

# ========== #
# Delimiters #
# ========== #

DELIMITERS = "<.>" "<!>" "<?>" "<…>" "<;>" "<–>" ;

# ============= #
# Tags and sets #
# ============= #


# ========
   SETS
# ========

SET BOS = (>>>) | (<s>) ;
SET BOP = (>>>) | Comma | Semicolon | Colon | Punct | ("–") ;

SET NA = Noun | Adj ; 

LIST TENSE = Pres Fut-I Fut-II Aor Impf Impv ;

# LIST POSTP = PP PP:ахь PP:да PP:зы PP:ла PP:шьҭахь PP:ҟа PP:ҟны PP:ҟынтә PP:ҿы PP:ҿы́ PP:ан ;

# enclitic postposition
SET EPOSTP = (/^PP:/r) ;

SET POSTP = PP | EPOSTP ;

# conjunctional interrogative prefixes
LIST ConjIPf = Where FromWhere ToWhere When How Why Until Size ;

SET CONJIPF = ConjIPf - Q ;

LIST QUEST = Q QWho QWhat
             QFromWhere QSize QToWhere QWhere ; # remove these

LIST LO = /^LO:/r ;

LIST Rel = /:Rel$/r ;

LIST Rec = /:Rec$/r ;
LIST Reln = /^Reln:/r ;

# LIST Poss = /^Poss:/r ;

LIST Poss = Poss:Rel Poss:1Pl Poss:1Sg Poss:2Pl Poss:2SgF Poss:2SgM
            Poss:3Pl Poss:3SgF Poss:3SgM Poss:3SgNH ;

LIST Poss:1 = Poss:1Sg Poss:1Pl ;
LIST Poss:2 = Poss:2SgM Poss:2SgF Poss:2Pl ;

LIST 2Sg = 2SgM 2SgF ;

SET NOUN = Noun | VN ;

SET Hum = H | Anthr ;

SET HUMleft = H | Anthr | Ord | ("а́ктәи") ;

SET FPv = FPv:аа | FPv:на | FPv:ла́ | FPv:ҩа | FPv:лы́ | FPv:ны | FPv:ҩы ;

# Argument markers

SET AM:1Sg = S:1Sg | DO:1Sg | IO:1Sg | RO:1Sg | LO:1Sg ;
SET AM:2SgF = S:2SgF | DO:2SgF | IO:2SgF | RO:2SgF ;
SET AM:2SgM = S:2SgM | DO:2SgM | IO:2SgM | RO:2SgM ;
SET AM:2SgH = AM:2SgF | AM:2SgM ; 
SET AM:3SgH = S:3SgH | DO:3SgH | RO:3SgM | RO:3SgF ;
SET AM:3SgNH = S:3SgNH | DO:3 | IO:3SgNH | RO:3SgNH ;
SET AM:3SgM = S:3SgM | IO:3SgM | RO:3SgM ;
SET AM:3SgF = S:3SgF | IO:3SgF | RO:3SgF ;
SET AM:3SgHMF = AM:3SgH | AM:3SgM | AM:3SgF ; 
SET AM:1Pl = S:1Pl | DO:1Pl | IO:1Pl | RO:1Pl ;
SET AM:2Pl = S:2Pl | DO:2Pl | IO:2Pl | RO:2Pl ;
SET AM:3Pl = S:3Pl | DO:3 | IO:3Pl | RO:3Pl ; # more!

SET AM:2 = AM:2SgH | AM:2Pl ;

LIST Ad = S:Ad DO:Ad Q:Ad ;

SET S:3Sg = S:3SgH | S:3SgNH | S:3SgM | S:3SgF ;

SET MF = M | F ;

SET S:Hum = S:1Sg | S:2Sg | S:3SgH | S:3SgM | S:3SgF | S:1Pl | S:2Pl ;

# SET DET = Det | ([Det]) ;

SET  S:Hum3Sg =  S:3SgF | S:3SgH | S:3SgM ;
SET DO:Hum3Sg =  DO:3SgH ; 
SET IO:Hum3Sg =  IO:3SgF | IO:3SgM | IO:3SgNH ;
# SET AM:Hum3Sg =  S:Hum3Sg | DO:Hum3Sg | IO:Hum3Sg ;

SET DO:12 = DO:1Pl | DO:1Sg | DO:2Pl | DO:2SgF | DO:2SgM ;
SET DO:Hum = DO:12 | DO:3SgH ;

SET  S:NonHum3Sg =  S:3 | S:3SgNH ;
SET IO:NonHum3Sg =  IO:3SgNH ;
SET LO:NonHum3Sg =  LO:3SgNH | ([LO:3SgNH]) ;
SET AM:NonHum3Sg =  S:NonHum3Sg - S:Ad | DO:3 - DO:Ad | IO:NonHum3Sg | LO:3SgNH | ([LO:3SgNH]) ;

SET SgNonHum = Noun - Hum - Pl | V + Rel ;

SET PlNonHum = Noun - Hum + Pl | ("а́-р") ; # more!

SET VERB = V | Pred | LHP ; # LHP because it’s there personal affixes are coded
SET VerbVN = VERB | VN ;
SET VMain = V + Fin | V + Opt | QUEST | Cop | Pred + Fin | RHP + Fin | CopNounFin ;

# remove this!
# SET AdRel = (S:Ad S:Rel) | (DO:Ad DO:Rel) ;

SET AD = (S:Ad S:3) | (DO:Ad DO:3) ;

LIST CLB = Semicolon Colon Ellipsis "<ҳәа>" "<уҳәа>" Connect "<аха>" IntMark ExclPoint ;
LIST CLBc = Semicolon Colon Ellipsis "<ҳәа>" "<уҳәа>" Connect "<аха>" Punct Dash ; # Comma is Punct!

LIST HowPurp = How Purp ;

SET COORD = Coord - Cj ; # | Encl:гьы ; # prelim!

LIST DET = Det [Det] ;

LIST VSaying = "а-ҳәа-ра́" "а́·ҳәа-ра" "а́иц·ҳәа-ра" "а-ҿа́а·ҭ-ра" "а-хәы́ц-ра" "а-ҟрым-ҿры́м-ра"
               "а́ибы·ҳәа-ра" "а́-д·ҵа-ра" "а́-ӡба-ра" ; # "а-џьа·шьа-ра́"


# ======== #
  SECTION  #
# ======== #

# SELECT <Dis> ; # select manually disambiguated reading, REMOVE!
SELECT <Sel> ; # select manually disambiguated reading

REMOVE Subj + S:2Sg ; # prelim. bug fix

REMOVE Why + AsLongAs ; # this and similar ones should be removed from the morphology?
REMOVE Why + WhEver ;
REMOVE Why + Conj-I ;
REMOVE CONJIPF + AsIf ;
REMOVE CONJIPF + QWhat ;
REMOVE Purp + When ;

# REMOVE Why + Cnv ; 

REMOVE Redup ;

# REMOVE (/он>/r) + Pres + Abs ; # being moved to morphology

REMOVE PP:ны IF (NOT 0 (/ы>/r)) ;

REMOVE NH + Pred + S:Hum ;

REMOVE S:Rel + DO:Rel ; # cannot cooccur?

REMOVE Impv + Reln:Pot ; # cannot coocur?

REMOVE Pred + Reln:With ;

REMOVE ("а-ды́р-ра") IF (NOT 0 ("<.*дыр.*>"r)) ; # put into morphology!

# check better!
REMOVE Abs + Encl:гьы ;

# remove readings with verbal morphemes from Manner nouns
REMOVE Rec + <Manner> ;
REMOVE Reln + <Manner> ;
REMOVE LO + <Manner> ;

REMOVE ("а́у-ра" Stat) ;

REMOVE ("аа-ра́") + FPv:аа ;

REMOVE ("а́а") + Noun ;
REMOVE ("аа́") + Noun ;

REMOVE ("а-иа-ра́") IF (0 ("а-иа́ша") + How) ; # дышиашаз 

REMOVE ("ҳаҭы́рла") ; # prefer а́-ҳаҭыр + PP:ла

SELECT ("ҵау́ланы" Adv) ;

REMOVE ("а́и·ҧ·ла-ра") ; 

REMOVE ("а́-цәгьа-заа-ра") ; # prefer the Adj; do this in general!

REMOVE ("а-уу-ра́") IF (0 ("а-ду́")) ;

# but?
SELECT ("а-цә·уада́ҩ-заа-ра") ;

SELECT ("Иура") + Prop ;
REMOVE ("Ҳаҳ") + Prop ;

SELECT ("а-ҧсы́" H Indet NumPfx) IF (1 ("а-ха́-заа-ра")) ; # шә(-)ҧсы ихазар(гьы) check what this means!

REMOVE <NumPfxNoHyphen> IF (NOT 0 ("а́-мш") OR ("а́-мз") OR ("а́-бла"));
REMOVE VCoord ;
SELECT ("<рыла>" "дара́") ;
SELECT Pron + Pers + ("ҳа́") IF (1 AM:1Pl) ;
SELECT Prt + Quote ; # ҳәа, ҳәагьы etc.
REMOVE ("<бзиа>" V) ;
SELECT ("уи́") ;

SELECT ("цқьа́") + Adv ;

# SELECT ("а-у́с") IF (1 ("а-у-ра́")) ;

# SELECT ("ус") ;

REMOVE ("аи́бга") ; # ист. аи́бга (абхазское племя)

REMOVE ("а́ҟара") + Adv ;

# those and similar ones should be excluded from the morph
REMOVE ("а-цә·ӡ-ра́") IF (0 ("а-цәы́·ӡ-ра")) ;
REMOVE ("а-цәы·ӡ-ра́") IF (0 ("а-цәы́·ӡ-ра")) ;

SELECT ("<изкны>" "а-з·к-ра́") ;
SELECT ("<азы>" PP) ;
SELECT ("сара́" Pron) ;
SELECT ("уара́" Pron) ;

REMOVE ("а́-ҭа-ра") + Pass ; # иҭахон

REMOVE ("аҽакы́") + Adv ; # remove from morph!

"<шәаҳауазар>" REMOVE ("а́у-ра") ; # remove from morph!

REMOVE ("а-вакы́") + Noun ;

REMOVE ("а-ба́ртә") + Adj ; # derived from а-ба́р bar

REMOVE ("а́-ҧа") + <Relax> ;

REMOVE ("а-ки́т") IF (0 ("а-к-ра́")) ;

SELECT ("иара́" Pron) ;

LIST Relative = "а́б" "а́н" "сара́" "а́-иаҳәшьа" "а́-иашьа" "иара́" "абду́" "анду́" "а-ҭаацәа́" "а-гәы́ла"
              "а-хәыҷы́" "а-ҧҳәы́с" "а-ҭа́ца" "а́-иашьеиҵбы" "а́-саби" "а-ха́ҵа" ;

SELECT ("иара́" 3SgM Coord) IF (1 Relative + Coord) ;
SELECT ("а́н") + $$Poss + Coord IF (1 Relative + $$Poss + Coord) ;
SELECT Relative + Coord IF (1 Relative + Coord) ;

# Иуреи сареи
SELECT Anthr + COORD IF (1 Pron + Pers + Coord) ;

SELECT Pron + Pers + 3SgM + COORD IF (-1 Anthr + COORD) ;
# more of these
SELECT Relative + Poss:1Sg + Coord IF (1 Pron + Pers + 1Sg + Coord) ;

SELECT ("шәара́" Pron) ;
SELECT ("руакы́" Pron) ;
SELECT ("у́рҭ" Pron) ;
SELECT ("убри́" Pron) ;
SELECT ("егьи́" Pron) ; # not аира́
SELECT ("а́-кә-заа-ра") + Stat + Pres ;
SELECT ("акы́р" Adv) ;
SELECT ("акы́рӡа" Adv) ;
SELECT ("ишҧа́" Pron) ;
SELECT ("акы́" Num) ;
SELECT ("акгьы́" Pron) ;
SELECT ("а́хьтә" PP) ; # vs. а́-хьтә
SELECT ("а-тәы́" PP) ;
SELECT ("акы́раамҭа") ;
SELECT ("а́амҭа") ; # not а́-мҭа Num
REMOVE ("а-тәа́н") ;
REMOVE ("а-ры́гә") ;
REMOVE ("а-хьӡы́") ;
SELECT ("шьа́рда" Adv) ;
REMOVE ("а-са́с") ;
REMOVE ("а́рҭ" Adj) IF (NOT -1 Noun) ; # ripe
# REMOVE ("а-ра́антә" Adj) ; # а-ра́ан: очередь
# REMOVE ("а-ра́антәи" Adj) ;

SELECT ("<дууп>" "а-ду́") ;

REMOVE ("а-ццакы́ра") IF (0 ("а́-ццакра")) ;

REMOVE ("а-дауҳа́") IF (0 ("а-доуҳа́")) ;

SELECT ("ҳа́рҭ") ;

# REMOVE ("а́ҳцәа") ;

SELECT ("заҵәы́к") ;

SELECT ("хаз-хазы́") ;

SELECT ("а́-ҭыҧынтәи") ;

SELECT ("а́из·ааигәа-ра") ; # and not а́аигуа

REMOVE ("а-ҳәа-ра́") + StatPass ;

REMOVE ("а-з·иа́·ха-ра") IF (0 ("а-бзи́а·ха-ра")) ;

SELECT ("а́-цха") IF (-1 ("а́-шьха")) ;
SELECT ("а́-цха") IF (1 ("а-гьа́ма")) ;

REMOVE ("а-цәы́мҕ·ха-ра") ; # denominal, see а-цәы́·мҕ·ха-ра

REMOVE ("а́-уадаҩ") + Noun + Pred ;

REMOVE ("а́-ма-заа-ра") + IO:Rec ; # = аимазаара
REMOVE ("а́има-ра") ; # = аимазаара

REMOVE ("а-лаҳа́") IF (0 ("аҳа-ра́")) ; # инжир ficus carica

REMOVE ("ҽе́иҵыхны") ; # prefer а-ҽ·е́и·ҵы·х-ра

REMOVE ("а-сы́") IF (0 ("а-кы-заа-ра́")) ; # шыску

REMOVE ("а́-чма") IF (0 ("а-чы́мазара")) ;

SELECT ("аа́нтәи") ;
SELECT ("ара́хь" Adv) ;
SELECT ("џьаргьы́" Adv) ;
SELECT ("уа́ҟа" Adv) ;
SELECT ("нас" Adv) ; # not Prop F
SELECT ("аҳы́" Interj) IF (0 ("<Аҳы>") OR ("<Аҳы>")) ;
REMOVE ("аҳы́" Interj) ;
REMOVE ("а-ҳәа-ра́" Intr) ; # prelim! remove!
REMOVE ("а-ҳәа́н" Noun) ;

SELECT ("<иан>" "а́н") ;
SELECT ("<Иан>" "а́н") ;

REMOVE ("а-гәа́р") IF (0 ("а-гәа́ра")) ;

REMOVE ("а-ба-ра́" Intr S:2SgM) ; # убама

REMOVE Anthr + PP:н ;

SELECT ("шаҟа́") ;
SELECT ("иа́шаны") ;
SELECT ("хара́нтә") ;
REMOVE ("ауы́ха") ;
REMOVE ("а-бга́") ; # охот. яз.

REMOVE ("а́б") IF (0 ("а́-бз")) ;

# can be noun! check.
SELECT ("еиҳа́рак" Adv) ;

REMOVE ("аҩы́на") IF (0 ("а-ҩна́-заа-ра")) ;

REMOVE 	("а́из·га-ра" Intr) ;

REMOVE ("а-ӡи́а" Advb) ; # аӡиас

REMOVE ("а́-ҧш") IF (0 ("а-зы·ҧш-ра́")) ;

SELECT ("а-шәы́") IF (1 ("а-шә·ҵа-ра́")) ;
REMOVE ("а-шәы́") ;

REMOVE ("а-ны́мха") IF (0 ("а-зы·н·ха-ра́")) ;

SELECT ("а-зы́ҳәа") + PP IF (0 (/зыҳәа>/r)) ;

SELECT ("ҽа́" Adj) IF (1 Indet) ;
SELECT Indet IF (-1 ("ҽа́") OR ("аҽа") OR ("даҽа́")) ;

SELECT ("жәпакы́" Adv) ;
REMOVE ("а-блы́") ; # Nabelbruch

REMOVE ("а́-ҵкыс" PP) IF (0 ("а́ҵкыс" PP)) ;

SELECT ("уажәгьы́" Adv) ;
SELECT ("шьа́хәла" Adv) ;

REMOVE ("а́-с-ра") + IO:Rec ; # = а́ис-ра

REMOVE ("а-ца́") IF (0 ("а-ца-ра́")) ;

REMOVE ("а·у-ра́") OR ("а-у-ра́") + Reln:With ;

REMOVE ("мӡа́кәа") ; # prefer V

REMOVE ("а́-жәтә" "<.+ытә>"r) ;

SELECT ("а́ӡынтәи") ;

LIST EOP = Comma IntMark Punct ExclPoint ;

SELECT ("да́д" "<дад>") IF (-1 BOP OR Comma) (1 EOP) ;
SELECT ("да́д" "<Дад>") IF (-1 BOP) (1 Comma OR IntMark OR Punct OR ExclPoint) ;

SELECT ("мшәан" Adv) IF (-1 BOP OR Comma) (1 Comma OR IntMark OR Punct OR ExclPoint) ;
SELECT ("мшәа́н" Adv) IF (-1 BOP OR Comma) (1 Comma OR IntMark OR Punct OR ExclPoint) ;

SELECT ("а́-сас") ;

SELECT ("убра́") ;

SELECT ("уажәазы́" Adv) ;

SELECT ("а-ҧса-ра́" S:Rel) IF (0 ("и-аҧсо́у" Adj)) ;

SELECT ("а́-шә") IF (1 ("ҟьа́ҟьаӡа")) ;

REMOVE ("а-хәыҷы́" Adj Pl Det) ;

SELECT ("а-ҵаҩы́") IF (-1 ("а-кла́сс")) ;

SELECT ("шәҩы́") ;

SELECT ("абра́ҟа" Adv) ;

SELECT ("ҽака́ла" Adv) ;

SELECT ("а-ҵаҩы́" Noun H Pl Poss:3SgM) ; # иҵаҩцәа

REMOVE ("а-ҿа́" Det) ; # согласие (на вступление в брак)

SELECT ("а-ма́ҭа") ; # not а́-маҭа (but: иҽага кны а́маҭа днахагылт!)

SELECT ("а́-жәпа" Adj) ;

SELECT ("а́ура" Noun) IF (0* ("а-ме́тр") OR ("ме́тра") OR ("а-киломе́тр")) ;
# -ҟоуп
REMOVE PP:ҟа + Cop ;

REMOVE ("а-шьха́р") IF (0 ("а́-шьхара"));

SELECT ("иа́шаны") IF (1 ("а́·ҳәа-ра"));

SELECT ("хы́нтә" Num);
SELECT ("а-хы́нтә" Num);

SELECT ("уа́ҳа" Adv) ;

SELECT ("иахье́иҧш" Adv) ;

SELECT ("еицҿа́кны" Adv) ;

SELECT ("а-ҭы́ҧан") ;

REMOVE ("а-ры́қә") + Pred IF (0 ("а́-қә-заа-ра")) ; # острый кончик ножа

REMOVE ("аиқәаҵәа́") + Noun ; # охот. яз.

"<злам>" SELECT ("а́-ла-заа-ра") + Rel ;

REMOVE ("а-ҳа́" Noun) IF (NOT -1 <PreAdj>) ;

REMOVE ("а́-хьӡ-заа-ра") IF (0 ("а́хьӡ-заа-ра")) ;
REMOVE ("а́хьӡ-заа-ра" Why) ;
REMOVE ("а́хьӡ-заа-ра" QWhat) ;

REMOVE ("а-фо́н") IF (0 ("а́-фа-ра")) ;

SELECT Prop IF (1 ("а́хьӡ-заа-ра" S:Ad)) ;
SELECT Noun IF (1 ("а́хьӡ-заа-ра" S:Ad)) ;

SELECT Prop IF (1 ("»") LINK 1 ("а́хьӡ-заа-ра" S:Ad)) ;
SELECT Noun IF (1 ("»") LINK 1 ("а́хьӡ-заа-ра" S:Ad)) ;

SELECT ("са́" Pron) ;

REMOVE ("иа́") + Cj + Coord IF (NOT 0* ("иа́") + Cj + Coord) ;

SELECT ("ҩба́" Num) ;

REMOVE ("а́-з" Adj) ;

SELECT ("убра́ҟа") ;

SELECT ("а-ҽны́") ;

REMOVE ("а́ибар") ; # еибаркны

REMOVE ("а-и́н") ; # азин

SELECT ("иага́") IF (1 Conj-I + Encl:гьы) ;

SELECT ("адәахьы́") ;

SELECT ("блаҵары́ла") ;

SELECT ("а-зхара́") ;

SELECT ("уа́ҳагьы") ;
SELECT ("ҳы") ;

REMOVE ("а́ҳ") IF (0 ("аҳа-ра́")) ;

REMOVE ("а́-фатә" Adj) ;

SELECT ("иаҳа́" Adv) ;
SELECT ("иаҳагьы́" Adv) ;
SELECT ("<иҧа>" "а-ҧа́") ;
SELECT ("<ихала>" "ха́ла") ;
SELECT ("а́сеиҧш") ;
SELECT ("а́ан" PP) IF (-1 Adj OR Noun) ;
SELECT ("уаха́" Adv) ;
SELECT ("<злоу>" "а́-ла-заа-ра") ;
SELECT ("а-ры́цҳа" Adj) IF (-1 Noun) ;
REMOVE NH IF (0 H) (1 ("а-ры́цҳа" Adj)) ;

SELECT ("уа́а" "<Уаа>") IF (1 Comma) ;

SELECT ("<иаҧхьа>"i "а́ҧхьа" PP) ;

REMOVE ("аумашәа́") ; # keep оумашәа́

SELECT ("оҳ") ;

SELECT ("а́-мза") IF (1 ("а-шәахәа́")) ;

"<умшәан>" SELECT ("а-шәа-ра́") ;

# сыҟоуп
SELECT ("а́-ҟа-заа-ра" Pres S:1Sg) ;

SELECT ("<иалоу>" "а́-ла-заа-ра") ;
SELECT ("а-лша́ра") ;

# remove!
SELECT ("убасшәа́") ;

SELECT Num + H + Indet + Digits ; # 17-ҩык

SELECT ("Аҧсны́") ;

SELECT ("а́-рацәа") ;

SELECT ("а́ҧхьаҟа") ;

SELECT ("ааигәа́-сигәа") + Adv ;

SELECT ("а́-мчра") IF (-1 ("а-сове́т")) ;

# REMOVE ("а-ҿа́ҵа") ; # competes with а-ҿаҵа́

SELECT ("а-хаҿы́") ; # not а-хы́, а-ха́

REMOVE ("а́-са") IF (0 ("а́н")) ;
REMOVE ("а-са́") IF (0 ("а́н")) ;

REMOVE ("а-сы́" Poss:2SgM) ; # уск
#REMOVE ("а-сы́қәа") ;

SELECT ("<иусқәа>") + ("а-у́с") ;

SELECT ("а́-иаҳәшьа" /^Poss:/r) ;
SELECT ("а́-иашьа" /^Poss:/r)
    IF (NOT 0 ("а-шьа́"))
       (NOT 0 ("а-ры́цҳа·шьа-ра"));

REMOVE Adj + PP:ан ; # prelim.

SELECT ("инаркны́" PP) ;

SELECT ("<аӡы>" "а-ӡы́") ;

# SELECT ("а-ҿы́" PP) IF (-1 Noun OR Adj) ; # can go wrong

SELECT ("абни́") ;

SELECT ("а́б" H)
    IF (NOT 0 ("а́-бз") OR ("а́-бла") OR ("а-бызшәа́") OR ("а-бзара́")) ;

SELECT ("за́а" Adv) ;

SELECT ("а-зы́ҳәа") IF (-1 Pron + Pers + 3SgM);

SELECT ("ара́нӡа") ;

SELECT ("а́ила·цәажәа-ра" RO:Rec) ;

SELECT ("а-ҟы́нтә") OR ("а-ҟы́нтәи") ;

SELECT ("изба́н" Int) ;

SELECT ("у́сгьы" Adv) ;

SELECT ("а́хь" PP Poss:2SgM) IF (-1 Pron + 2SgM) ;
SELECT ("уа́хь" Adv) ;
# SELECT ("а́хь" PP Poss:3SgF) ;

SELECT ("а́хь" PP) IF (NOT 0 ("<.*ы>"r)) (NOT -1 <PreAdj>) ;

REMOVE ("а́хь" PP)
    IF (0 ("<.*ы>"r)) ;

SELECT ("а-зы́" PP Poss:3SgM) ;
SELECT ("а-зы́" PP Poss:3Pl) ;

SELECT ("а-на́ҩс") ;
SELECT ("а́-шьҭахь") ;
SELECT ("а́-шьҭахь" PP) IF (-1 ("ҧы́ҭрак")) ;

SELECT ("аха́ан" Adv) ;
SELECT ("хара́" Adv) ;
SELECT ("а́лада" Adv) ;

SELECT ("ҕәҕәала") ;
SELECT ("ҕәҕәала́") ;
SELECT ("ҧхьаҟа́") ;

SELECT ("а-ба-ра́=аҳа-ра́") ;

REMOVE ("а́-ца" H) ;

# зауз
SELECT ("а́у-ра" PastIndef S:Ad IO:Rel) ;

# зегь раҧхьа
SELECT ("а́ҧхьа" PP) IF (-1 ("зегьы́")) ; 

REMOVE ("а-тәы́" Noun) IF (0 ("а-тәы́ла" Noun)) ;

REMOVE ("а́рма") IF (0 ("а́-ма-заа-ра")) ;

REMOVE ("а́и·башь-ра") ; # but а́иба·шь-ра

REMOVE Reln:TogetherWith IF (0 Together) ;

SELECT ("лассы́" Adv) ;
SELECT ("заҟа́" Pron) ;

SELECT ("иахьагьы́") ;

REMOVE ("а-ла́" PP:ан) ;
REMOVE ("а-ла́" PP:ны) ;
REMOVE ("а́-ла" PP:ан) ;
REMOVE ("а́-ла" PP:ны) ;

# ахьҭан, шоуран, more?
#SELECT ("а-шо́ура" RHP) ;
#SELECT ("а́-хьҭа" RHP) ;

SELECT ("ҵаҟа́" Adv) ;

SELECT ("а́ҳасабала" PP Poss:3SgNH) IF (-1 Noun + NH) ;

SELECT ("а́-џьымшь" Pl) ; # not а-џьымшьы́

SELECT ("аба́сгьы") ;

SELECT ("<ицаз>" "а-ца-ра́") ;

SELECT ("а-хы́=а-ҧсы́") ;

SELECT ("иахьа́") ;

SELECT ("а́-ҭаҳмада" H) ; # not Prop

SELECT ("изба́нзар") ;

SELECT ("ҩы́нтә" Mult) ;

REMOVE ("а́-хаа" PP:аан) ; # ихаан
REMOVE ("а-хы́" PP:аан) ;

# SELECT ("<ауп>" "а́кә-заа-ра") ;

SELECT ("а́уп") + Adv IF (-1C V + Fin) ;
REMOVE ("а́уп") + Adv ;

# SELECT ("а́кә-заа-ра" Cop Pres) ;

LIST AdvInterj = Adv Interj ;

SELECT ("уа́") + Pron IF (1 Poss:2SgM) ;

SELECT ("уа́") + AdvInterj ;

REMOVE ("а́н" Pred) ;

REMOVE ("а-кы́") IF (0 ("а-з·к-ра́")) ; # ирызкны etc.

SELECT ("а-ҟы́нӡа") ;

REMOVE ("а́-лакә") IF (0 ("а́кә-заа-ра")) ;

REMOVE ("абна́" Adv) ;

REMOVE ("а-ба́р") IF (0 ("а-ба-ра́")) ;

SELECT ("а-зы́·маншәала-заа-ра") ;

REMOVE ("а-ҳәа́р" Pred) ;
REMOVE ("а-ҳәы́с" Pred) ;

# REMOVE ("Иаха") ;

SELECT ("а-ҵыхәтәантәи́") ;
SELECT ("и́-рццакны") ;

SELECT ("и́-ҵагь") ;

SELECT ("<ишааз>" "аа-ра́") ;

REMOVE ("а-ума́") IF (0 ("а́-ма-заа-ра")) ;
REMOVE ("а́-ума") IF (0 ("а́-ма-заа-ра")) ;

SELECT ("да́ара") ;
SELECT ("иа́рбан") ;
SELECT ("а́-шҟа") ;
SELECT ("а-ҟны́" PP) ;

SELECT ("а́-да" PP) ;

SELECT ("аӡәы́" Pron) ; # not Num

SELECT ("а-цәаҩа́") ; # not а-цәа́ҩа

SELECT ("<дин>" "а-ди́н") ;

SELECT ("дырҩа́гь") ;
SELECT ("уажәы́" Adv) ;
SELECT ("а-зе́иҧш") ;
SELECT ("а́-жәлар") - Pred ; # check!

SELECT ("а́ҧхьа") + PP + Poss IF (NOT 0 Impv) ; # шәаҧхьа

SELECT ("а́иҧш") ;
SELECT ("а́иҧш" Poss:3SgM) IF (-1 H) ; # аҭаҳмада еиҧш
SELECT ("а́иҧш" Poss:3SgNH) IF (-1 NH) ;
SELECT ("а́иҧш" Poss:3SgNH) IF (-1 How OR When) ; # ишдыру еиҧш
SELECT ("а́иҧш" Poss:3SgNH) IF (-1 Adv) ; # абас еиҧш

SELECT ("а-бызшәа́") ;

SELECT ("а-ҿа́р") ;

SELECT ("а́-урыс") ;

SELECT ("а-хаба́р" Noun) ;

SELECT ("а́-ҧсаӡ") ;

SELECT ("а-ҩы́за") ;

SELECT ("а-ҧе́иҧш") ;

# SELECT ("а-ҳа́мҭа") ;

REMOVE ("а́-мҭа") + Poss:1Pl IF (0 ("а-ҳа́мҭа") + Advb) ;

SELECT ("а́асҭа" PP) ;

SELECT ("егьы́рҭ" Adj) ;

SELECT ("а-раса́") IF (-1 ("а-коко́с")) ;

# SELECT ("<змоу>" "а́-ма-заа-ра") ;
REMOVE ("а́у-ра") IF (0 ("а́-ма-заа-ра")) ;

REMOVE ("<аҳа>" "а́ҳ") ; # fix this: ҳ -> ҳа

REMOVE ("а-хәы́" H) ;
REMOVE ("а-ла́н") ;

SELECT ("а́-ц·к-ра") ;

SELECT ("а-з·ҵаа-ра́") OR ("а-зҵаа́ра") ;

# Meer, Gestade etc. vs. а-га-ра́
REMOVE ("а́га" Pred) ;

SELECT ("аҕа́") IF (-1 ("а́-жәлар")) ;

REMOVE ("а́-цыгә") ; # ацгәы

SELECT ("зама́налаҵәҟьа") ;

REMOVE ("ҟаҵа́") ; # only ҟаҵа имаӡам

# not Adj if Poss
SELECT ("аиҳабы́" Noun) + Poss ; 

REMOVE ("а-ҟа́да") ;

REMOVE ("а-ҩы́" PP:ны) ;
REMOVE ("а́-ҩ" PP:ны) ;

SELECT ("џьаргьы́" Adv) IF (1 V + Neg) ;

SELECT ("насгьы́" Adv) ;

SELECT ("<рахь>" PP) ;

SELECT ("аиа́шазы" Adv) IF (1 Comma) ;

REMOVE ("а́рба") ;

REMOVE ("а́-ҧҳә" Advb) ; # а-ҧҳәы́с

SELECT ("аба́р") IF (1 Comma) ; # not а-ба́р Noun

SELECT (/<А.*>/r "а-нцәа́") ;

REMOVE ("а-да-ра́") IF (NOT -1 ("а-чы́ра")) ;

REMOVE ("а́-ҧ") IF (0 ("а-ҧсы́")) ;

REMOVE ("а́ха") ;

REMOVE ("а́у") IF (0 ("а-у́с")) ;

REMOVE ("а-иа́") IF (0 ("а-бзи́а")) ;
REMOVE ("бзи́а" Adv Cop) ; # бзиоуп

SELECT ("ибзи́аны") ;
SELECT ("ибзи́аӡаны") ;

REMOVE ("а-цәы́·р·га-ра");

SELECT ("а-ҩны́ҟа" Adv) ;

REMOVE ("а-ца́р") ;

SELECT ("уҳәа́") ; # ??

SELECT ("а-шо́ура") ;

SELECT ("кыр" Adv) ;

SELECT ("а-са́хьаркыратә") ; # not V

REMOVE ("а-ҭауры́х") ; # keep а-ҭоуры́х

SELECT ("ҵа́уп") ;
SELECT ("еибганы́") ;

SELECT VN IF (1 ("а́-шьҭа-заа-ра")) (NOT 0 POSTP) ;

# solve this differently, by marking ы́ lexical
REMOVE ("<ахан>" "а-ханы́") ;
REMOVE ("<Ахан>" "а-ханы́") ;

# REMOVE ("а́-ча") ; # перепел

SELECT ("<уаала>" "аа·ла-ра́" Impv) ;
SELECT ("<Уаала>" "аа·ла-ра́" Impv) ;
SELECT ("<баала>" "аа·ла-ра́" Impv) ;
SELECT ("<Баала>" "аа·ла-ра́" Impv) ;

# дзеиҧшроу(зеи)
SELECT ("а́иҧшра" Pres Q) ;

SELECT ("шаа́нагара") IF (1 ("а́-ҟа-заа-ра")) ;

SELECT ("а-ҵа́с" Det) ;

SELECT ("а-уаҩы́" "<уаан>") IF (-1 Rel) ;

SELECT ("<рыр>" "а́-р") ;
SELECT ("<ир>" "а́-р") ;
SELECT ("<иргьы>" "а́-р") ;

SELECT ("<зда>" "а́-да" PP) ;

SELECT ("а́ибашьра" Noun) ;

SELECT ("а-хы́=а-ҿы́") ;

SELECT ("мыцхәы́") ;

SELECT ("<иаҳауа>" "аҳа-ра́") ;

REMOVE ("аҳа-ра́" IO:3SgNH) ;

SELECT ("а-ӡы́с" Det) ;

SELECT ("ас" Adv) ;

SELECT ("<есҽнытәи>" "есҽны́тәи") ;
SELECT ("<есыҽнытәи>" "есы́ҽнытәи") ;

LIST TempAdv = "иаха́" "жәытәна́тә" "жәытә-на́тә" "ахана́тә" "наџьна́тә" "шьыжьы́" "иаха́" "иацы́" "а-жәы́тә"
     "а́-жәтә" "ажәы́тә" "шьыжьымҭа́н" "нахьхьи́" "ҵыҧх" "аха́ан" "ау́ха" "шьжьымҭа́н" "жәытә-на́тәӡа" "а-ха́ан"
     "жәытәна́тәӡа" "иацу́ха" "хааны́" "шьыбжьо́н" "а-шарҧы́" "ажәы́тәан" "аха́" "шарҧазы́" "ҧа́хьа" "а-иа́"
     "а́-хәылбыҽха" "а́-шьжьымҭан" "а́дырҩаҽны" "а́нкьа" "аша́мҭаз" "аша́мҭазы" "у́сҟан" "уахы́ки-ҽна́ки" "ҧы́ҭрак"
     ;

SELECT ("аахы́с") + PP + Poss:3SgNH
    IF (-1 TempAdv) ;

# аха сымаӡам

REMOVE ("а́-ха" Noun) IF (NOT 1 ("а́-ма-заа-ра")) ;
REMOVE ("а́-ха" Noun) IF (NOT 0 ("<аха>") OR ("<Аха>")) ;

SELECT ("а́-ха" Noun)
       IF (1 ("а́-ма-заа-ра" Neg))
       	  (2 Punct) ;

REMOVE ("а́иуа" NH Sg) ; # иреиуоуп

REMOVE ("а-сура́") ; # бз.

REMOVE ("аа·ла-ра́") - Impv ;

# ??
# SELECT ("а́-рацәа" Abs) ;

REMOVE ("а́-қә") IF (0 ("а́-қә-заа-ра")) ;

SELECT ("а́-қә-заа-ра") IF (-1 ("а́-нагӡара")) ;

# REMOVE ("а-р:а́ҳа-ра") IF (0 ("аҳа-ра́")) ; # difficult to disambiguate

SELECT ("а-бзоура́" Noun /^Poss:/r PP:ла) ;

# should be generalized
SELECT ("а-хцәы́" /хцәы>/r) ; # and not а-хы́цә
# SELECT ("а-ҩы́" /ҩы>/r) ;
SELECT ("а-ӡы́" /ӡы>/r) ;
SELECT ("а-цкы́" /цкы>/r) ;
SELECT ("а-жьы́" /жьы>/r) IF (NOT 0 ("а-бжьы́")) ;
SELECT ("а́-жь" /жь>/r) ;
SELECT ("а-хахәы́" /хахәы>/r) ;

REMOVE ("<ашә>" "а-шәы́") ; # find some general rule!

SELECT ("анс") IF (1 ("<акә>") OR ("<акәу>")) ;
SELECT ("арс") IF (1 ("<акә>") OR ("<акәу>")) ;

SELECT ("еиҭа́" Adv) ;

SELECT (/".*чч/r) IF (0 (/<.*чч/r)) ;

SELECT ("Гагра") + Place ;
SELECT ("Гагратәи") + Place ;

SELECT ("Шәача") + Place ;
SELECT ("Шәачатәи") + Place ;

REMOVE ("а-гәа·ҧха-ра́") + S:Ad IF (-1 When) ; # more of these?

SELECT ("дзаҟа́разаалакь") ; # add to lex.!

SELECT ("а-бааҧсы́") IF (0 ("а́аҧса-ра")) ;

REMOVE ("а́-ҧаҩ") OR ("а́-ҧацәа") OR ("а-ҧаҩы́") ; # these compete with а-ҧа́-цәа

REMOVE ("а-шәҩы́") ; # competes with шәҩык

SELECT ("а-шәы́шықәса") ; # not "а́-шықәса" Poss:2Pl

SELECT ("а́-лаф") ;

SELECT ("изакәу́") ;
SELECT ("а́кә-заа-ра") IF (NOT 0 ("изакәы́зеи")) ; # too rigid?

SELECT ("а-ны·р:ха-ра́") + DO:Ad IF (-1 ("а-гәы́")) ;

SELECT ("<изкуп>" "а-з·к-ра́") ;

REMOVE ("а-цә·шәа-ра́") + Tr ;

REMOVE ("а́иҵа") IF (0 ("аиҵа́")) ;

REMOVE ("а́-ҭа-ра") IF (0 ("дызу́сҭа")) ;

REMOVE ("а-ҭа́·м-заа-ра") IF (NOT 0 Conj-I OR Subj OR Purp) ;

REMOVE ("аихагы́ла") + Adj IF (-1 Num + Ord) ;

# Аҧсныҟа даауеит
REMOVE ("а-у-ра́") IF (0 ("аа-ра́")) (-1 PP:ҟа) ;

SELECT ("а-к-ра́" Tr DO:Ad) IF (-1 ("ма́п")) ;
SELECT ("а-к-ра́" Tr) IF (-1 ("ма́п")) ;

SELECT ("а-ча́з") IF (1 ("а-хы́лҧа") - Det) ;

REMOVE ("а-ҳәа-ра́") + Tr + DO:3SgH ; # must be а́-ҳәа-ра then

# check!
SELECT ("а́-хәда" Noun) ;
SELECT ("и́рласны" Adv) ;
SELECT ("хазы́" Adv) ;

SELECT ("а-зы́ҳәан" PP) ; # ?

SELECT ("<раан>" PP) ;

SELECT ("а́-хаантәи" <PreAdj>) ;

SELECT ("уа́анӡа" Adv) ;

SELECT ("зынӡа́" Adv) ;

SELECT ("<ду>" Adj) ;

REMOVE ("а́-ҩа") ;

# REMOVE ("а-з·ҵаа-ра́") ;

REMOVE ("а-з·ҳа-ра́" Tr) ; # а-ҳа-ра́ сплести

SELECT ("<рыма>" "а́-ма-заа-ра") ;

SELECT ("а-ҵакы́") IF (NOT 0 ("а-ҵа·к-ра́")) ;

SELECT ("уа́хьынтә" Adv) ;

REMOVE ("а-иа́ша·ха-ра") ; # we have а́-иаша·ха-ра

# SELECT ("а-ҳа́уа") ; # but: изызҳауа!

SELECT ("а-з·к-ра́" "<ирызку>") ;

REMOVE ("а-з·у-ра́") IF (0 ("а-з·ҳа-ра́")) ; # ирызҳауеит etc.

SELECT ("а-у́с") IF (1 ("а-д·у́ла-ра")) ;

REMOVE ("а-ҧшӡа́" Noun Pred) ;

SELECT ("а́-шьҭахь" PP Poss:3SgNH) IF (-1 Noun + NH + Sg) ;

SELECT ("Урыстәыла") ;

REMOVE ("а́-мдыр") IF (0 ("а-ды́р-ра")) ;

SELECT ("а́н" Noun H Sg Poss:3SgF) IF (-1 F) ;

SELECT ("ари́") ;

SELECT ("ара́") ;
SELECT ("абра́") ;

SELECT ("а-дуне́и") ;

SELECT ("а-ҩны́") IF (-1 H OR M OR LastName) ; # not а-ҩ-ра
SELECT ("а-ҩны́") IF (-1 ("а-ҧсшьа́рҭа")) ;

REMOVE Noun + Reln:TogetherWith ;

# ??
# SELECT ("а-бзи́а" Abs) ;

# too general?!
REMOVE ("а-ҩы́за" Adj)
    IF (0 Poss - Poss:3SgNH) ;
SELECT ("а-ҩы́за" Adj)
    IF (-1 ("ари́") OR ("абри́") OR ("убри́") OR ("уи́")) ;

# аҩыза Сталин
SELECT ("а-ҩы́за" Noun) IF (1 LastName) ;


SELECT ("а-ҩы́за" Adj Poss:3SgNH) ;

SELECT ("уи́" Pers)
    IF (1 ("а-ҩы́за" Adj)) ;

REMOVE ("а́ша") ; # иа́ша

SELECT ("а-цә·к-ра́" DO:Ad) IF (-1 ("ма́п")) ;

# адырра инаҭеит
SELECT ("а-ды́рра") IF (1 ("а́-ҭа-ра") + Tr + Ad) ;
SELECT ("а́-ҭа-ра") + Tr + Ad IF (-1 ("а-ды́рра")) ;
SELECT ("а-ды́рра") IF (1 ("а́у-ра") + S:Ad) ;
SELECT ("а́у-ра") + S:Ad - IO:Rec IF (-1 ("а-ды́рра")) ;

# ииҭаз азҵаара
SELECT ("а́-ҭа-ра") + Tr + Rel IF (1 ("а-зҵаа́ра")) ;
SELECT ("а-зҵаа́ра") IF (-1 ("а́-ҭа-ра") + Rel) ;


# too general?
REMOVE ("<.*ын>"r Abs) ;

REMOVE Pred + Abs + Pres IF (NOT 0 ("<.*ны?>"r)) ;

REMOVE ("<.*ан>"r) + Abs
    IF (0 PastIndef)
       (1* Aor + Fin) ;

REMOVE PP:аан IF (NOT 0 ("<.*аан>"r)) ;

SELECT ("жәытәна́тә") ;
SELECT ("аахы́с" PP) IF (-1 ("жәытәна́тә") OR ("жәытә-на́тә")) ;

REMOVE ("а-ша-ра́") + Tr + S:3SgF + DO:12 ;

# ихьӡ зху
SELECT ("а-хы́-заа-ра" LO:Rel) IF (-1 ("а́-хьӡ")) ;

SELECT ("еиҳа́" Adv) IF (NOT -1 Noun) ;

# илҭахыз зегь
SELECT Rel - QWhat IF (1 ("зегьы́") + Pron) ;


SELECT NonFin IF (1 ("а-џь·шьа-ра́")) ;
REMOVE Rel IF (1 ("а-џь·шьа-ра́")) ;
REMOVE Abs IF (1 ("а-џь·шьа-ра́")) ;
REMOVE QWhat IF (1 ("а-џь·шьа-ра́")) ;
REMOVE Why IF (1 ("а-џь·шьа-ра́")) ;

SELECT QWhat + RHP IF (-1 ("иа́рбан")) ;

####

REMOVE Why + Purp ; # should be removed from morphology!
REMOVE Why + Cond-I ; # should be removed from morphology!
REMOVE Why + Cond-II ; # should be removed from morphology!

# remove non-finite forms without rel marker not preceded
# by a relativized argument
# that is, except e.g. зҧа дубо
REMOVE NonFin - Abs - Rel - CONJIPF - Cond-I - Conj-I - Conj-II - RHP
       - Q - Purp - Opt - Rhet - AsLongAs - Until - EveryTime - AsIf
    IF (NOT -1 Rel)
       (NOT -2 Rel) ;

SELECT Purp IF (1 ("а-ҭах-ра́") OR ("а-ҭах·ха-ра́")) ;

REMOVE Purp + Rel IF (NOT 1 Rel) ;

SELECT Purp + Rel IF (1C Rel) ;

# Инагӡа, – иҳәан.
REMOVE Abs IF (NEGATE 0* V BARRIER Dash) ;

# Иуҳәарц иуҭахыз, interesting construction: DO is Rel, and not the Purp!
SELECT ("а-ҭах-ра́") OR ("а-ҭах·ха-ра́")
    IF (-1 Purp) ;

# if not DO:Ad it has to be Rel
REMOVE ("а-ҭах-ра́") + DO:3 - DO:Ad
    IF (-1 Purp) ;

SELECT ("а-ҭах-ра́") + Rel
    IF (-1 Purp + Rel) ;

SELECT DO:Ad IF (1C V) (-1 Purp) ;

SELECT ("а-ҭах·ха-ра́") + S:Ad
    IF (-1 VN) ;

REMOVE DO:Ad IF (-1 Anthr) ; # marker must be д-

# ижәбо ала
SELECT ("а́-ла") + PP IF (-1 ("а-ба-ра́") + DO:Rel) ;

# ?? marker must be д-
# REMOVE DO:Ad IF (-1 H + Sg OR Anthr) ;
REMOVE S:Ad IF (-1C H + Sg OR Anthr - Pl) ;

REMOVE Ad IF (-1C Pron + Pers + 3Sg) ; # can only be S:3SgH
REMOVE Ad IF (-1 Pron + Pers + 1Sg) ;
REMOVE Ad IF (-1 Pron + Pers + 2SgM) ;
REMOVE Ad IF (-1 Pron + Pers + 2SgF) ;
REMOVE Ad IF (-1 Pron + Pers + 1Pl) ;
REMOVE Ad IF (-1 Pron + Pers + 2Pl) ;

LIST Water = "а-ӡи́ас" "а́-мшын" ;

SELECT ("а-хы́қә") + Poss:3SgNH IF (-1 Water) ;

REMOVE POSTP IF (1C Ad - FPv:аа) ; # ?? before FPv:аа DO I col marker can be dropped? ааихмырсыҕьӡакәа

REMOVE Poss:3SgNH - PP - ("ха́ла") - ("а́-збжа") ; # and similar?

SELECT Num + Pfx IF (1 Num) ;

REMOVE Noun + Abs + Pres ;

REMOVE RHP IF (-1C V - Rel) ;
REMOVE RHP IF (NOT -1 LHP) (NOT -2 LHP + Int) ; # изакә хҭыс бааҧсқәаз
REMOVE LHP IF (NOT 1 RHP) (NOT 2 RHP) ;

SELECT RHP IF (-1C LHP) ;

REMOVE LHP + Adj IF (1 RHP + Adj) ;

REMOVE Ad IF (-1 Period | BOS) ;

REMOVE Ad IF (-2 Period | BOS) (-1 Punct) ;

REMOVE Ad - LHP - ("а-ҳәа-ра́")
    IF (-1 Comma OR Semicolon OR Cj) ;

REMOVE Poss:1Sg + Cop IF (0 Pred + S:1Sg) ; # сыхиоуп
REMOVE Poss:2SgM + Cop IF (0 Pred + S:2SgM) ;
REMOVE Poss:2SgF + Cop IF (0 Pred + S:2SgF) ;
REMOVE Poss:3SgM + Cop IF (0 Pred + S:3) ; # ибзиоуп
REMOVE Poss:1Pl + Cop IF (0 Pred + S:1Pl) ;
REMOVE Poss:2Pl + Cop IF (0 Pred + S:2Pl) ;

# сдәылҵыз џьшьаны
# add more!
LIST PhraseObjVerb = "а-џь·шьа-ра́" ;

# -шәа ҟаҵаны
REMOVE Ad
    IF (-1C V - HowPurp OR Cond-I OR AsIf OR Adv OR POSTP)
       (NOT 0 PhraseObjVerb)
       (NOT -1 NonFin + Rel)
       (NOT -1 NonFin + CONJIPF)
       (NOT -1 ("уа́ҳа")) # уаҳа сылшом
       (NOT -1 ("а́ҟара")) ; # жәаҩык раҟара сыҭ

REMOVE Ad IF (-1C Cop) ;

# correct?
REMOVE Ad IF (-1C POSTP - ("а́ҟара") OR Advb OR Abs) ;

REMOVE V + Why IF (1C Ad) ;

REMOVE Adj + H + Pl - <PreAdj> - Det
    IF (NOT -1 H) ;

SELECT NOUN - Pred
    IF (0C NOUN) 
    (1C Ad) ;

SELECT NOUN - Pred
    IF (0C NOUN)
       (0C POSTP) ;

# doesnt work?
REMOVE Ad
    IF (-1C PP:зы) ;

REMOVE V + Fin
    IF (1C Ad)
       (NOT 1 ("а-ҳәа-ра́")) ;

# REMOVE LHP + Ad ;

# аха ҳамаӡам
SELECT ("а-ха́" Noun) IF (1 ("а́-ма-заа-ра" Neg Emph)) ;
REMOVE ("а-ха́" Noun) IF (NOT 1 ("а́-ма-заа-ра" Neg Emph)) ;

SELECT ("аха́") + Cj ;
SELECT ("зны́") + Cj IF (1* ("зны́")) ;
SELECT ("зны́") + Cj IF (-1* ("зны́")) ;
SELECT ("зны") + Adv ;

SELECT ("аба́с") + Adv ;

SET FIN = Fin | Cop | QUEST ;

# Pers + 3Sg is Hum and needs д as agens marker
REMOVE Pers + 3Sg IF (0 Dem) (1C Ad) ;

REMOVE Dem IF (0 Pers) (1C Punct OR FIN) ;

SELECT Noun IF (0C VN OR Noun) (1 PP) ;

SELECT ("а-бжьа́ра" PP) IF (-1 NumPfx) ;

SELECT Pl OR Rel:Pl OR NumPfx IF (1 PP + Poss:3Pl) ;

SELECT Noun IF (1 PP + Poss:3Pl) (-1 Num + Card) ;

# уи ада(гьы)
SELECT ("а́-да" PP) IF (-1 ("уи́")) ;
SELECT ("уи́" Pron Pers) IF (1 ("а́-да" PP Poss:3SgNH)) ;

# check more Pron Dem!
REMOVE Pron + Dem IF (1 Pron) (NOT 0 ("ари́")) ;

SELECT ("а́-да" PP Poss:3Pl Encl:гьы) ; # рыдагьы

SELECT Anthr + M IF (1 LastName) ;
SELECT Anthr + F IF (1 LastName) ;

REMOVE Patr IF (NOT 1 LastName) ;

REMOVE Anthr + M IF (0 Place) (NOT 1 Patr) (NOT 1 LastName) ;
REMOVE Anthr + F IF (0 Place) (NOT 1 Patr) (NOT 1 LastName) ;

REMOVE ("Лара") + Anthr ;

# SELECT ("а́-иашьа" /^Poss:/r) IF (1 Anthr + M) ;

# аӡиас Гәымсҭа
SELECT Hydronym IF (-1 ("а-ӡи́ас") OR ("а-ӡи́а")) ;
SELECT Hydronym IF (1 ("а-ӡи́ас") OR ("а-ӡи́а")) ;

SET HM = H | M ;

# -и иареи
SELECT Pron + 3SgM + COORD IF (-1 HM + COORD) ;

# PP:зы never ends in з?
REMOVE PP:зы IF (0 (/<.*з>/r)) ;

SELECT ("ла́" Pron) IF (1 (/3SgF/r)) ;

# this might exclude very rare forms, e.g., ҳа-ра́ <- а-ра́
SELECT ("ҳара́") + Pron - Indet ; # IF (1 (/1Pl/r)) ;

SELECT Adj + Pred IF (-1 ("а́иҳа")) ;

# лхахәы еиқәаҵәа
REMOVE Adj + Sg + Poss:3SgM
    IF (0 Adj + Sg + ([Det]))
       (-1 Noun - POSTP) ;

SELECT ("аахы́с" PP) IF (-1 When - Q) ;
SELECT ("аахы́с" PP) IF (-1 Pron + Pers + 3Sg) ;

# Pron Pers is free, Pron Dem is bound? check/fix!
SELECT Pron + Pers + 3Sg IF (1 PP + Poss:3SgNH) ;

SELECT Pron + Pers + 3Sg IF (1 Adv) ;


REMOVE VN + (/^LO:/r) - (/Poss:/r) - DET ; 

REMOVE Neg + Reln:For IF (0 Neg + Reln:Pot) ;

REMOVE H + PP:ҿы́ ;

# ахәынтә раан
SELECT Mult IF (1 ("а́ан") + PP) ;

SELECT Ord IF (0 ("а-тәы́")) ; # 20-тәи

# Lexical disambiguation
# ========================

# upper case

REMOVE ("Ду") + Prop IF (-1 ("а-нцәа́")) ;
REMOVE ("Дыу") + Prop IF (-1 ("а-нцәа́")) ;

SELECT Prop + ( "<[Џ-ЯҚҬҼЧҾҶ].+>"r)
       IF (NOT -1 BOS OR ("–") OR ("“") OR ("«") OR <PreAdj>) ;

# First name if followed by uppercase (unknown last name)
SELECT Prop + Anthr + ( "<[Џ-ЯҚҬҼЧҾҶ].+>"r)
       IF (1 ("<[Џ-ЯҚҬҼЧҾҶ].+>"r))
          (NOT 1 Place) ;


SELECT ("а-ха́ан") IF (-1 HUMleft) ;

SELECT ("а́а·на·га-ра") IF (-1 ("а-гәы́")) ;

SELECT ("а́-л·ша-ра") IF (-1 Conj-I) ;

# асахьақәа ранҵара илшеит
SELECT ("а́-л·ша-ра") + S:Ad IF (-1 VN) ;

SELECT ("а-у-ра́") IF (-1 Conj-I) ;

LIST DirectSpeechMarker = "ҳәа́" "уҳәа́" "<»>" "–" ;

SELECT VSaying + DO:Ad IF (-1 DirectSpeechMarker) ;

REMOVE ("а-ҳәа-ра́" Tr DO:1Sg) ; # суҳәоит

SELECT ("иара́" 3SgM) IF (-1 ("а-ҳәа-ра́")) (-2 DirectSpeechMarker) ;

SELECT ("а́-шьҭа-заа-ра") IF (-1 ("ҳәа́") OR ("уҳәа́")) ;

SELECT ("а́-м·ҟьа-ра") IF (-1 ("а-гәы́")) ;

SELECT ("а́-ла-заа-ра")
       IF (-1 ("а-хәарҭара́")) ;

SELECT ("а́-ла·к-ра") IF (-1 ("а-напы́")) ;

SELECT ("а-ҩа́ха-ра") IF (-1 ("а-напы́") OR ("а́-бла") OR ("а́-џьымшь")) ;

SELECT VN OR Abs OR Purp
       IF (1 ("а-на́ла·га-ра") OR ("а́-ла·га-ра"))
       	  (NOT 0 ("а-зи́н")) ;

# add more possibilities
SELECT ("а́-ла·га-ра")
       IF (-1 VN) ;

# уҧсы ушьап
SELECT ("а-шьа-ра́") + DO:Ad IF (-1 ("а-ҧсы́") OR ("а-хы́")) ;
SELECT ("а-хы́") IF (1 ("а-шьа-ра́") + Ad) ;


# ҧсы схоу, ҧсы злам
SELECT ("а-ҧсы́" NH) IF (1 ("а-ха́-заа-ра") OR ("а́-ла-заа-ра")) ;
SELECT ("а-ха́-заа-ра") IF (-1 ("а-ҧсы́")) ;

# ала
SELECT ("а-ла́") IF (-1 ("а́-хьча")) ; # Schäferhund

REMOVE ("а-ла́") IF (1 ("а́аҳә-ра") + S:Ad) ;

SELECT ("а-у́с") IF (1 ("а-у-ра́")) ;

SELECT ("а-у-ра́") 
    IF (-1 ("а-у́с") OR ("а́-маҵ") OR ("а́ҳра") OR ("а́-шаҳаҭра")) ;

# иазгәасымҭар ауам/ауеит
SELECT ("а-у-ра́") IF (-1 Conj-I) ;

LIST Precipitation = "а-қәа́" "а-сы́" "а-кы́рцх" "а-қәаршаҩы́" ;

SELECT ("а·у-ра́" Dyn) IF (-1 Precipitation) ;

LIST Sound = "а-бжьы́" "а́-шьҭыбжь" ;

# loose semantic connection
SELECT ("аҳа-ра́") IF (-1* Sound) ;

SELECT ("аҳа-ра́") + Ad IF (-1 Sound) ;


REMOVE ("а-ды́р-ра") + Neg - Reln:Pot ;

# more?
REMOVE Cond-I
    IF (1C Ad)
       (NOT 1 ("а-ҳәа-ра́") OR ("а-у-ра́") OR ("а-ҭах-ра́") OR ("а-ды́р-ра")
       	      OR ("а-ба-ра́") ) ;

REMOVE ("а́-ҭаа-ра" S:3SgNH) ; # prefer "а-ҭ·а́а-ра"

SELECT ("а-бжьа́-заа-ра")
       IF (-1 ("а́иҕара")) ;

SELECT ("а-га-ра́" Tr DO:Ad) # not Caus: агәра ргеит
    IF (-1 ("а-гәра́")) ;
SELECT ("а-га-ра́" Tr S:Ad Reln:Pot)
    IF (-1 ("а-гәра́")) ;

SELECT ("а-р:га-ра́") + TrCaus IF (-1 ("а-гәра́")) ;

# LIST Hunger = "а́-мла" "а́-ӡба" ;

# дагоит, даганы
# OBS: иалагаргьы!
SELECT ("а-га-ра́") + Intr + IO:3SgNH - S:Ad IF (0C ("а-га-ра́")) ;
# REMOVE ("а-га-ра́") + Tr + IO:3SgNH - S:Ad ;

# ??
#REMOVE ("а-га-ра́") + Intr
#    IF (NOT 0 IO:3SgNH) ;

SELECT ("а-га-ра́") + Intr - IO:3SgNH IF (-1 Sound) ;
SELECT ("а́-ҵ·га-ра") + Intr IF (-1 Sound) ;

SELECT ("а-р:га-ра́") IF (-1 Sound) ;

SELECT ("бзи́а" Adv)
       IF (1 ("а-ба-ра́")) ;

SELECT ("бзи́а" Adv)
       IF (1 ("а́иба·ба-ра")) ;

SELECT ("аиа́шазы" Adv) ;

REMOVE ("а-иа́ша" Adj)
    IF (0 ("а-иа́ша" Noun))
       (NOT -1 Noun) ;

REMOVE ("а-баҟа́") IF (0 ("а́-ҟа-заа-ра")) ; # абаҟоу

SELECT ("ус") + Adv
       IF (NOT 1 Ad)
          (NOT 1 Adj + Indet);

# ус дук
SELECT ("а-у́с") IF (1 ("а-ду́")) ;

SELECT ("а-цәҟьа́") + Noun
       IF (1 ("а-ҿа·шәа-ра́")) ;

REMOVE ("а́-ҟа-ра") + VN ;
REMOVE ("а́ҟа-ра") + VN ;
REMOVE ("а́ҟара-заа-ра") + V ;

REMOVE PP IF (1C Ad - FPv:аа) ; # see above with POSTP

SELECT Num + Ord + Roman
    IF (1 ("а-шәы́шықәса")) ;

SELECT ("а́аи") IF (1 Comma) ;

# Rec needs a pl subject
REMOVE Intr + S:1Sg + IO:Rec ; # check if IO:Rec always relates to Subj
REMOVE Intr + S:2SgM + IO:Rec ;
REMOVE Intr + S:2SgF + IO:Rec ;
REMOVE Intr + S:3SgH + IO:Rec ;

# MWE?
SELECT ("иара́") + 3SgNH
    IF (1 ("уба́с")) ;

# уи
REMOVE ("а-и-ра́") + Impv
    IF (0 Pron + Det)
       (NEGATE 1* ExclPoint) ;

REMOVE V IF (1 ("заҵәы́к" Adv)) ;

SELECT ("заҵәы́к" Adv)
    IF (-1C Noun + DET) ;

SELECT ("а́-бла")
    IF (1 ("а-ба-ра́" S:3SgNH)) ;

SELECT ("а́-шә") IF (1 ("а-к-ра́") OR ("а́ат-ра")) ;
SELECT ("а-к-ра́" Tr) IF (-1 ("а́-шә")) ;

REMOVE ("жәаха́" Adv) IF (-1 Num + Pfx) ;

REMOVE ("а́и·ма·к-ра") IF (0 ("а́има·к-ра")) ;

SELECT ("а-ҭах-ра́" DO:Ad) IF (-1 Conj-I) ;

SELECT ("а́-ла") + PP IF (-1 How) ;
SELECT ("а́-ла") + PP IF (-1 ("зегьы́")) ;

SELECT ("а́-ла") + PP IF (-1 ("а́-л·ша-ра")) ; # исылшоз ала

# see lexicon def. of дук
REMOVE ("дук") + Adv
    IF (NEGATE 1 Neg)
       (NEGATE 2 Neg) ;

SELECT ("а́-лаҧш") + Noun
    IF (1 ("а́-ҵа·шәа-ра")) ;

SELECT ("а-ҳәа-ра́") + Tr - Lab
    IF (-1 Dash) ;

# but:
SELECT ("а-хәы́ц-ра" Intr)
    IF (-1 Dash) ;

# generalize!
SELECT ("иара́" 3SgM)
    IF (-1 ("а-хәы́ц-ра" Intr))
       (-2 Dash) ;

SELECT ("иара́" 3SgM)
    IF (1 ("а́кә-заа-ра") + IO:3SgM) ;

SELECT ("а-ҧа́" Poss:3SgM)
    IF (-1 Anthr) ;

SELECT ("а-ҧа́" Poss:3SgM)
    IF (-1 ("а-нцәа́")) ;

SELECT ("а́б" Poss:3Pl H)
    IF (-1 (Pron Pers 3Pl)) ;

SELECT ("а́-шьҭахь" PP)
    IF (-1 When) ;

SELECT ("иаҳа́" Adv)
    IF (1 Adj) ;

SELECT ("а́мала" Adv)
    IF (1 Comma) ;

SELECT ("а-ҩны́" Noun)
    IF (1 ("а-ҩна́·ла-ра" LO:3SgNH)) ;

SELECT ("а́хь" PP Poss:3SgM)
    IF (-1 ("иара́" 3SgM)) ;

SELECT ("иара́" 3SgM)
    IF (1 Poss:3SgM) ;

# SELECT ("дук" Adv) IF (1 ("<мырҵыкәа>")) ;

SELECT ("дук" Adv)
    IF (1* Neg BARRIER CLB)
       (NOT -1 Noun) ;

SELECT ("аиҳа́рак") + Adv
    IF (NOT -1 Noun) ;
SELECT ("аиҳа́раӡак") + Adv
    IF (NOT -1 Noun) ;

# Prop зыхьӡыз
SELECT Prop
    IF (1 ("а́-хьӡ") + S:Ad + Poss:Rel) ;

# шаҟа …зеи
SELECT ("шаҟа́") + Pron
    IF (1 QWhat) ;

# а́ла # see general rule above
# SELECT ("<рыла>" PP) IF (-1 ("зегьы́")) ;

SELECT ("аа́" Interj) OR ("а́а" Prt) IF (-1 BOP) (1 Comma) (2* ExclPoint) ;
SELECT ("аа́" Prt) IF (-1 BOP) (1 Comma) (2* IntMark) ;

# S should be relativized (generalize to verbs preferring nonanimate DO)
REMOVE ("а-ды́р-ра" QWho DO:Rel) ;

REMOVE ("а-қә-ра́") IF (0 ("а́-қә-заа-ра")) ;

SELECT ("а́-шқәс") IF (-1 Num + Card) ;

SELECT ("а́-хьӡ") IF (-1 ("ҳәа́")) ;
SELECT ("а́-хьӡ") IF (1 ("а́-ма-заа-ра") + S:Ad) ;

SELECT ("а-ны́шә") IF (1 ("а́-ма·да-ра")) ;
SELECT ("а́-ма·да-ра") IF (-1 ("а-ны́шә")) ;

SELECT ("а́-лахь") IF (1 ("а́и·қә-заа-ра")) ;

SELECT ("а́ила·ҧса-ра") IF (-1 ("а-хы́")) ;

SELECT ("а-ры́цҳара") ;

REMOVE ("а-ла́р") IF (0 ("лара́")) ;

# Аҿатә/Ажәытә Уасиат
SELECT ("а-уаси́аҭ") IF (-1 <PreAdj>) ;

SELECT Noun IF (-1C <PreAdj> - Pred) ;

# word affinities, experimental

SELECT ("а́-бла") IF (1* ("а-ба-ра́")) ;

SELECT ("а-ҵа-ра́" Tr) IF (-1 ("а-ҵара́")) ; # аҵара зҵоз

SELECT ("ииу́н") - Poss:3SgM IF (-1 ("а́-шықәса")) ;

REMOVE ("а-ча́") IF (0 ("а́-ча")) (1 ("а-шь-ра́")) ;

# ишьацәа хаххала дааргеит
SELECT ("а́-шьацәа") IF (1 ("ха́ххала")) ;

SELECT ("а́-шьжьымҭан") + Adv ;

SELECT ("ха́ла") ;

LIST sizeAdj = "а-ду́" "а-ма́ҷ" "а-ду́ӡӡа" "а́-наӡа" "а-бзи́а" "а́-ҕәҕәа" "а́-мыжда" "а́-наскьа" ;

REMOVE ("а-қәра́") + Noun
    IF (1 sizeAdj) ;

LIST PriceAdj = "а-ду́" "á-ҳарак" "а́-мариа" "а́-цәгьа" ;

# зыхә мариоу
SELECT ("а́-хә") + NH IF (1 PriceAdj) ;

# ========================

SELECT PP + Poss:1Sg
    IF (-1 Pron + Pers + 1Sg) ; 
SELECT PP + Poss:2SgM
    IF (-1 (Pron Pers 2SgM)) ; 
SELECT PP + Poss:2SgF
    IF (-1 (Pron Pers 2SgF)) ; 
SELECT PP + Poss:1Pl
    IF (-1 (Pron Pers 1Pl)) ; 
SELECT PP + Poss:2Pl
    IF (-1 (Pron Pers 2Pl)) ; 

SELECT Pron + Pers + 1Sg
    IF (1 Poss:1Sg) ;

SELECT Pron + Pers + 2SgM
    IF (1 Poss:2SgM) ;

SELECT Pron + Pers + 2SgF
    IF (1 Poss:2SgF) ;

SELECT Pron + Pers + 1Pl
    IF (1 Poss:1Pl) ;

SELECT Pron + Pers + 2Pl
    IF (1 Poss:2Pl) ;

SELECT PP + Poss:3SgNH
    IF (-1C Pron + Dem + Sg) ;

# but: урҭ рыхәаҧшраз ирҭаауеит ауаа рацәа
#SELECT (DO:3)
#    IF (-1* Pron + Pers + 3Pl BARRIER V + Fin) ;

SELECT (Pron Pers 3SgNH)
    IF (1 AD) ;

SELECT AD 
    IF (-1 (Pron Pers 3SgNH))
       (0C V) ;

REMOVE POSTP IF (1C AD) ;

# use barrier?
SELECT (Pron Pers 1Pl)
    IF (1* AM:1Pl) ;
SELECT (Pron Pers 2Pl)
    IF (1* AM:2Pl) ;
SELECT (Pron Pers 3Pl)
    IF (1* AM:3Pl) ;

SELECT (Pron 1Sg)
    IF (1 Poss:1Sg) ;

SELECT 1Sg
    IF (0* AM:1Sg) ;

SELECT V + AM:1Sg
    IF (-1* 1Sg BARRIER Comma LINK NEGATE 1 Poss:1Sg)
       #(NOT 0 Poss:1Sg)
        ;

# dangerous: ҳа ҳҿы аангылара иаауаз
#SELECT V + AM:1Pl
#    IF (-1* 1Pl) ;

SELECT V + AM:2Pl
    IF (-1* 2Pl) ;

# but: ахалаҭ шкәакәақәа ршәын
#SELECT (DO:3)
#    IF (-1 Pl)
#       (0 (DO:Ad)) ;

# finite forms and absolutives cannot be direct objects
# except if subordinate to а-ҳәа-ра́
REMOVE V + Fin
    IF (1C Ad)
       (NOT 1 ("а-ҳәа-ра́")) ;

REMOVE Abs
    IF (1C Ad) ;

REMOVE Adv
    IF (1C Ad - ("а-ҳәа-ра́")) ;

REMOVE Ad
    IF (-1C Abs) ;

SELECT Noun + DET
    IF (-1C Pron + Dem) ;

# do corpus search for this
SELECT Abs + Aor
    IF (0C Abs)
       (1* Fin + Aor BARRIER CLB) ;

REMOVE Abs + Pres - Adj
    IF (0 Pres + Rel - Pred)
       (1 Noun) ;

REMOVE Abs + Pres
    IF (0 Pres + Rel)
       (1 <PreAdj>)
       (2 Noun) ;

# аха ибжьы адгьыл иҵыҩны изаҳауадаз ?
REMOVE Abs + Rel
    IF (NEGATE 1* Rel BARRIER CLB OR VMain) ;

# dangerous?
REMOVE NonFin - QUEST - Cop
    IF (NEGATE 0* FIN)
       (NEGATE 0* AsIf)
       (NEGATE 0* Rhet) ;

REMOVE NOUN + PP:зы IF (0 Purp) ;
# REMOVE VN + PP:зы IF (0 Purp) ;

SELECT Rel
    IF (-1C Rel + Purp) ;

# Special verbs

SELECT VN
    IF (1 ("а-ҿы́-заа-ра")) ;

# SELECT ("аа·ла-ра́" Impv) ; # уаа-ла!

SELECT ("а-рацәа́" Adj) IF (-1C Noun) ;

# Noun vs. VN
# SELECT Noun IF (1 ("а́-л·га-ра") + LO:3SgNH) ;

SELECT Num + H + Indet + Card IF (-1 H + Pl) ;
SELECT H + Pl IF (1 Num + H + Indet) ;

# Noun vs. Adj

# ideally only for equal lemma form, but that cannot be formulated in CG?
REMOVE Adj + Det + Pl IF (0 Noun + Det + Pl) ;

## brute force

REMOVE ("а́аигәа-заа-ра") ;
SELECT ("а́аигәа") + Pred ;
SELECT ("а́-хара") + Adj + Pred ;

SELECT ("а́-ҟа·ла-ра") ;

REMOVE <Manner> ;

REMOVE ("а́-ҳәа-ра") IF (0 ("а-ҳәа-ра́")) ; # is more probable

SELECT ("<сыҭ>" "а́-ҭа-ра") ;

SELECT ("а́-зқәа") ; # спина

SELECT ("а-ҿы́") + PP + Poss:3SgNH
    IF (-1 Noun + NH + Sg - POSTP) ;

SELECT ("а-ҿы́") + PP + Poss:3SgNH
    IF (-1 Adj + Sg - POSTP)
       (-2 Noun + NH + Sg - POSTP) ;

# too dangerous?
# SELECT Ad if (-1 NH) ;

# SELECT Noun IF (-1C Rel) ;

REMOVE <Deriv> ;

# Syntactic disambiguation
# ========================

# coordinate equal POS
SELECT Noun + COORD
    IF (-1C Noun + COORD) ;

SELECT Noun + COORD
    IF (1C Noun + COORD) ;

# refine!
REMOVE COORD
    IF (NEGATE -1 COORD)
       (NEGATE 1 COORD)
       (NEGATE -2 COORD)
       (NEGATE 2 COORD)
       (NEGATE -3 COORD)
       (NEGATE 3 COORD) ;

SELECT COORD
    IF (-1* COORD LINK NEGATE -1* COORD BARRIER CLB) ;

SELECT COORD
    IF (1* COORD LINK NEGATE 1* COORD BARRIER CLB) ;

SELECT COORD + Noun
    IF (-1C COORD + Noun) ;

SELECT COORD + Noun - POSTP
    IF (-2C COORD + Noun) ;

# ??
#REMOVE COORD
#    IF (NEGATE 1* COORD LINK NEGATE 1* COORD BARRIER CLB)
#       (NEGATE -1* COORD LINK NEGATE -1* COORD BARRIER CLB) ;

# уааи ҳахәаҧшып; уааи only?
SELECT ("аа́и-ра") + Impv
    IF (1 Fut-I + S:1Pl) ;

LIST Say = "а́·ҳәа-ра" "ҳәа́" ; # more!

# ??
#REMOVE Impv
#    IF (1C* Fin BARRIER CLB OR Say)
#       (NEGATE 1* Impv) ;

SELECT Impv
    IF (1 ExclPoint) ;

REMOVE Impv
    IF (1* IntMark) ;

SELECT Int
    IF (1* IntMark) ;

# remove Impv if finite non-imperative follows
REMOVE Impv
    IF (1* Fin - Impv BARRIER CLB OR Comma OR Say OR Impv OR Dash) ;

SELECT Impv
    IF (1 Comma)
       (2C Impv) ;

# needs refinement!
REMOVE Fin - PastIndef
    IF (1C* Fin BARRIER CLBc OR Say)
       (NEGATE 1* ("ҳәа́"))
       ;

# but Aor might be to the left?
REMOVE PastIndef + Fin
    IF (NOT 1* Aor + Fin) ; # Hewitt p. 100

REMOVE AsIf + Rel
    IF (NOT 1 Rel) ;

#REMOVE Abs + Rel
#    IF (NOT 1 Rel) ;

# serial with Rel uptake: дызҭираны иҟаз Иуда иҳәоит
SELECT Rel
    IF (-1C Abs + Rel) ;

# зыҧсы ҭаны иҟаз
SELECT V + Rel
    IF (-1* Poss:Rel BARRIER V + Rel) ;

# fixme: see Mark 1.29
#REMOVE Pres + Abs
#    IF (0 Impf)
#       (Negate 0* Fin) ;

SELECT PastIndef
       IF (0C V)
       	  (1*C Fin + Aor BARRIER CLBc ) ;

SELECT Abs OR NonFin
       IF (0C V)
       	  (1*C Fin BARRIER CLBc )
          (NEGATE 1* ("ҳәа́")) ;

REMOVE NonFin - Cop
       IF (0 Fin)
       	  (NEGATE 0* Fin OR AsIf OR Int BARRIER CLB) ; # but must be rel for Int

REMOVE Fin - PastIndef - Impv - Connect
       IF (0C* Fin BARRIER CLBc OR ("а-ҟы́нтә") OR ("а-зы́н"))
          (NEGATE 1* ("ҳәа́")) ;

REMOVE NonFin + QWhat
       IF (0C* Fin BARRIER CLB) ;

#REMOVE PastIndef
#       IF (0 Abs)
#    	  (1* Fin) ;

# dangerous
#REMOVE Poss:3SgNH
#       IF (NEGATE -1 NA) ;

#REMOVE AdRel
#       IF (NEGATE -1 Poss:Rel) ;

SELECT Rel # AdRel
       IF (-1C Poss:Rel) ;

REMOVE QWho - Rel
       IF (NOT -1* Poss:Rel) ;

#REMOVE Q
#       IF (1* ExclPoint) ;

#REMOVE Q
#       IF (NOT 1* IntMark) ;

SELECT Pron + 2Pl
       IF (1 Poss:2Pl) ;

SELECT Pron + Pers + 3Pl
    IF (1 Pred + S:Ad + S:3) ;

SELECT Pron + Pers + 3Pl
    IF (1 LO:3Pl) ;

# S-IO
SELECT Intr + S:3SgH + LO:3SgNH
    IF (0C V)
       (-1C NH)
       (-2 Pron + Pers + 3SgM OR 3SgF) ;

SELECT Pron + Pers + 3SgM OR 3SgF
    IF (1C NH)
       (2C Intr + S:3SgH + LO:3SgNH) ;

# does | bind stronger?? No?!
SELECT Pron + Pers + 3SgM | Pron + Pers + 3SgF
    IF (1C S:3SgH - LO) ;

# иара данырба
SELECT Pron + 3SgM
    IF (1C DO:3SgH ^ S:3 ^ LO:3SgNH) ;

# иара урҭ иреиҳоит
SELECT Pron + 3SgM
    IF (1 Pron + 3Pl OR Pl)
       (2C S:3SgM + LO:3Pl + DO:3) ;

SELECT Pron + 3Pl
    IF (-1 Pron + 3SgM)
       (1C S:3SgM + LO:3Pl + DO:3) ;

# Adv dangerous? exclude PP from -1 Noun?
SELECT Adj - Pred - DET - Num - Poss - Cop
    IF (0C Adj OR Noun OR Adv)
       (-1 Noun + Sg - Indet) ;

SELECT Adj + Pl - Pred - DET - Num - Poss
    IF (0C Adj OR Noun)
       (-1 Noun + Pl + H - Indet) ;

# ашәҟәыҩҩы ҿа
#SELECT Adj - DET - Pred - Poss
#    IF (-1 Noun) ;

SELECT Adj + Pl IF (-1 <PlStem>) ;

SELECT Noun - PP
    IF (1C Adj - <PreAdj> - DET - Pred - Poss) ;

SELECT Pl OR Rel:Pl IF (1 Poss:3Pl) ;

SELECT RHP
    IF (1C LHP) ;

SELECT RHP
    IF (1 Noun - DET)
       (2C LHP) ;

# абарҭ роуп уара иуҩызцәа гәакьақәоу!
SELECT LHP + Rel
    IF (1C RHP + NonFin) ;

# + other Cond forms?
SELECT ("а-ҭах-ра́" DO:Ad) IF (-1 Cond-I) ;
SELECT ("а-ҭах-ра́") - DO:Ad IF (1* Cond-I BARRIER CLB) ;

REMOVE ("уи́" Dem) IF (1 Poss:3Pl) ;

REMOVE ("уи́" Dem) IF (1 Poss:3Pl) ;

#SELECT ("е́иҧш" Adv)
#    IF (-1 Res) ;

# stative verb cannot follow a Dyn Abs (?)
# but: 
# REMOVE Stat IF (-1* NonFin + Abs + Dyn BARRIER V) ;

LIST TempExp = "аҽны́" "аа́мҭа" "аамҭазы́" "а́мш" "а́уха" "а́шьҭахь" "нахы́с" "а́иҧш" "иаха́" ; # and more

SELECT When
    IF (1 TempExp | Comma ) ;

# extend this!
SELECT RHP IF (-1C LHP) ;

# plus similar ones?
REMOVE RHP + QWhat IF (-1 LHP + How) ;

# noun postmodified by adj has no PP
REMOVE Noun + POSTP IF (1C Adj - DET - <PreAdj> - Pred) ;

# have to distinguish compound-type and modifying-type Adj-Noun
# Compounding Adjs are often denominal (= <Deriv>)

SELECT Noun - DET - Poss
    IF (-1 <PreAdj> + <Deriv>) ;

SELECT <PreAdj> - <Deriv>
    IF (1C Noun - DET - Poss) ;

SELECT <PreAdj> + <Deriv> # if available
    IF (1C Noun - DET - Poss) ;

# remove non-negated absolutives with expressed Subj (Aor only?)
REMOVE Abs + Tr + (/^S:/r) + Aor - Neg ;

REMOVE Abs + ("<.+н>"r) ; # Abs should normally end in -ны

# излалҳәаз ала
SELECT RO:Rel + Reln:With
    IF (1 ("а́-ла") + PP + Poss:3SgNH) ;

SELECT ("а́-ла") + PP + Poss:3SgNH
    IF (-1 RO:Rel + Reln:With) ;

# ахынтә раан
SELECT Mult IF (1 ("а́ан")) ;

SELECT H + Pl IF (-1 Num + H + Card) ;

# prefer the analysis without agent marker
REMOVE AsIf + Tr + S:Hum IF (0 AsIf + Tr - S:Hum) ;

### Lexical disambiguation

LIST TempNoun = "а́амҭа" "а-мину́ҭ" "а́-шықәса" "а́-мш" "а́-шқәс" "а-саа́ҭ" "а́-мз" "а-шәы́мҭа" "а́амҭа" "а́-мчыбжьа" "а-шәы́шықәса" "а-жәа́мш" "а-жәа́шықәса" "а́-мчыбжь" "ха́ха-хымш" "а́-мшцәгьа" "а-зқьы́шықәса" "а-секу́нд" "а́-ӡынра" ;

SELECT ("а́-шьҭахь" PP) IF (-1 TempNoun OR ("а́жәа")) ;

LIST Clothes = "а́-маҭәа" "а-ха́лаҭ" "а-блу́з" "а-па́лта" "а-кьа́ҿ" ;

LIST Clothes_V = "а-шәы́-заа-ра" "а-шәы́·х-ра" ;

SELECT Clothes_V
    IF (-1 Clothes) ;

SELECT Clothes_V
    IF (-2 Clothes) ;

SELECT Clothes + Noun IF (1C Clothes_V + Ad) ;

SELECT ("а-шьа-ра́") # ишьоуп
    IF (-1 ("ҳәа́")) ;

SELECT ("а-шьа-ра́")
    IF (-1 Advb) ;

SELECT ("а-ҧсы́" NH) IF (1 ("а-шьа-ра́") OR ("а-р:шьа-ра́")) ;

SELECT ("а-шьа-ра́") IF (-1 ("а-ҧсы́")) ;

# Наҳар иҟаиҵара изымдыруа, дшаҟь-шаҟьо дааихаххит

SELECT ("а-ды́р-ра") + S:Ad OR DO:Ad
    IF (-1 Fut-I + NonFin) ;


# ҳәа + V

# дсымбар ҳәа сшәоит
SELECT ("а-шәа-ра́") + Intr
    IF (-1 ("ҳәа́"))
       (-2 Conj-I) ;


# аҧара

SELECT ("а-ҧа́ра")
    IF (-1 ("а-маа́ҭ")) ;

LIST HumS = S:1Sg S:2SgM S:2SgF S:3SgM S:3SgF S:1Pl S:2Pl ; 
LIST HumDO = DO:1Sg DO:2SgM DO:2SgF DO:3SgH DO:1Pl DO:2Pl ; 
LIST HumIO = IO:1Sg IO:2SgM IO:2SgF IO:3SgM IO:3SgF IO:1Pl IO:2Pl ; 

# disambiguate Tr/Intr
SELECT ("а-к-ра́") + Tr + HumS IF (0C ("а-к-ра́")) ;
REMOVE ("а-к-ра́") IF (0 ("а-ду́")) ; # дук

SELECT ("а-к-ра́") + Tr + Ad IF (-1 ("а́-мца")) ;

# а́-цәа/а-цәа́
# ??

LIST V_ацәа́_LO = "а-ҭа́·ӡ-ра" "а-ҭа·ӡа-ра́" "а-ҭа́·гӡа-ра" "а-ҭы́·ҵ-ра" "а-ҭа́·ла-ра"
                 "а́-л·ҵ-ра" "а-хы́·х-ра" "а́-ла·шәа-ра" ;

SELECT ("а-цәа́") IF (1 V_ацәа́_LO + LO:NonHum3Sg) ;

SELECT ("а-хы́·х-ра") + LO:NonHum3Sg IF (-1 ("а-цәа́")) ;

SELECT ("а-цәа́") IF (1 ("а-ҧ·ҽ-ра́") + Ad) ;

# а́-бҕа (спина, хребет) / а-бҕа́ (гора, скала)

SELECT ("а́-бҕа") IF (1 ("а́-ҕәҕәа")) ;

# PP:н

LIST naNoun = "а-қы́ҭа" /тәы́ла$/r /тәыла$/r "а-ҭы́ҧ" "а́-шықәс" "а-жәа́шықәса" "а-шәы́шықәса" "а́-мҩа" ;

REMOVE PP:ан - naNoun ;

REMOVE PP:ны IF (NOT 0 ("<.+ны>"r)) ;

# prefer V Abs
REMOVE PP:ны IF (0 V + Abs) ;

# агәы as DO
# many more!
LIST DO_агәы_V = "а-ша́ҭа-ра" ;

SELECT DO_агәы_V + Tr + Ad IF (-1 ("а-гәы́")) ;


# агәы as IO
LIST S_агәы_V = "а́у-ра" ;

# игәы иауамызт prelim!
SELECT S_агәы_V + IO:3SgNH - Ad IF (-1 ("а-гәы́")) ;

# агәы as LO
LIST LO_агәы_V = "а-ҭа́-заа-ра" ;

# игәы иҭоу
SELECT LO_агәы_V + LO:3SgNH - Ad IF (-1 ("а-гәы́")) ;


# аҧсы NH as DO

LIST DO_аҧсы_V = "а́и·в·га-ра"  ;

SELECT ("а-ҧсы́") + NH IF (1 DO_аҧсы_V + DO:Ad) ;

# as S

SELECT ("а-ҧсы́") + NH IF (1 ("а-ха́-заа-ра") + S:Ad) ;
SELECT ("а-ха́-заа-ра") IF (-1 ("а-ҧсы́")) ;

# а-ҿы́, а-ҿа́

# аҿахьы
SELECT ("а-ҿы́") + Noun + PP:ахь ;

# а-шьа́

SELECT ("а-шьа́") IF (1 ("а-хы́·ҵәала-ра") + Ad) ;

# а́жәа as DO

LIST DO_ажәа_V = "а-ҳәа-ра́" "а́ила·ҟәаҟәа-ра" ;

# аха иҿы ааихыхны ажәак изымҳәеит
SELECT DO_ажәа_V + Tr + Ad IF (-1 ("а́жәа")) ;

SELECT DO_ажәа_V + Tr - Ad
    IF (-1 Cnv)
       (-2 ("а́жәа")) ;


SELECT ("а-лы́мҳа") IF (1 ("а-кы́д·ҵа-ра") + Ad) ;

REMOVE ("кы́дҵаны") ; # prefer а-кы́д·ҵа-ра

# аус уны, but also: аус иухьаны (!)
SELECT ("а-у-ра́") + Tr IF (-1 ("а-у́с")) ;

# а́-ла vs. а-ла́ as DO

LIST DO_а́ла_V = "а́и·қә·ҧса-ра" "а́и·ха·ҟәыс-ра"
                "а́-р:кәараҵа-ра" # this is rare
                ;

SELECT ("а́-ла") + Noun IF (1 DO_а́ла_V + Ad) ;

SELECT DO_а́ла_V + Ad IF (-1 ("а́-ла") + Noun) ;

SELECT ("а-ла́") + Noun IF (1 ("а́иш-ра") + Ad) ;


# а́-ла S
# ила иамбаӡеит
SELECT ("а́-ла") + Noun IF (1 ("а-ба-ра́") + S:3SgNH - Ad) ;

SELECT ("а́-ла") + PP + Poss:3SgNH
    IF (-1 Noun + NH + Sg - POSTP - Advb)
       (1 ("а́-ҟа·ҵа-ра") - Ad) ;

SELECT ("а́ис-ра") - IO:3SgM - IO:3SgNH + Ad
    IF (-1 ("а-гәы́") OR ("а-мшы́н")) ;

# verbs that prefer an animate (human, animal) S
LIST S_Anim_V = "а-у-ра́"  "а́аӡа-ра" ;

#
LIST AgentTypeNoun = "а-па́ртиа" ; # add more

# extend this!
# Subj cannot be NH except if agent type
# if DO:12 the agent if present should normally precede the verb
REMOVE S_Anim_V + S:3SgNH - Pot + DO:12
    IF (NOT -1 AgentTypeNoun) ;

# verbs that prefer an animate (human, animal) IO
LIST IO_Anim_V = "а́у-ра" "а-ҳа-ра́" "а́игәырҕьа-ра" "а́-ҭа-ра" "а́иса-ра" ;


REMOVE IO_Anim_V + IO:3SgNH ;


# verbs that prefer an animate (human, animal) DO
LIST DO_Anim_V = "а-шь-ра́" "а́аӡа-ра" ;

LIST Anim = "а-ҳәа́" ("а-хәыҷы́" Noun)  ; # animals, child, etc.

SELECT Anim OR Hum
    IF (1 Ad + DO_Anim_V) ;

SELECT Ad + DO_Anim_V
    IF (-1 Anim - POSTP - Advb) ;


# verbs prefering human Agent

# as IO:


# place LO

LIST PLACE = Place "а́дгьыл" ;

SELECT ("а́-қәын·ха-ра") + LO:3SgNH IF (-1 PLACE) ;

# уаҳама: prelim, should be removed from morph
REMOVE ("а-ҳа-ра́") + Q + S:2SgM + DO:3 + DO:Ad ;

# place LO of -хы-

LIST OnPlace = "а-ҭы́ҧ" "а-дуне́и" "а-мшы́н" "а-ҩны́" "а-ӡи́ас" "а́-жәҩан" "а-мху́рсҭа"
               "а́-шьҭа" "а́-лаҧш" "а-ҧсҭа́заара" ;

SELECT OnPlace IF (1* ("а-хы-заа-ра́") + LO:3SgNH - S:Ad) ;
SELECT OnPlace IF (2* ("а-хы-заа-ра́") + LO:3SgNH + S:Ad BARRIER V) ;

SELECT ("а-хы-заа-ра́") + LO:3SgNH - S:Ad IF (-1 OnPlace) ;
SELECT ("а-хы-заа-ра́") + LO:3SgNH + S:Ad IF (-2 OnPlace BARRIER V) ;

# verbs prefering non-human DO
# add more

LIST DO_NH_V = "а-у-ра́" # (о свадьбе) сыграть; (о мамалыге) сварить
               "а·у-ра́" # получить, получать
               "а-ҳа-ра́"
               "а-хәы́ц-ра"
               "а-з·хәы́ц-ра"
               ("а-р:ба-ра́" Intr) # высушить
               ("а-ҧш-ра́" Tr) # перебирать
               "а́-шш-ра" # плести
               ;
               

REMOVE DO_NH_V + DO:Hum ;
REMOVE DO_NH_V + DO:Rel + QWho ;

# илаҧш
SELECT ("а́-лаҧш") + Noun + Poss:3SgM IF (-1 Hum) ;

SELECT ("а́-лаҧш") + Noun IF (1 ("а-кы́д·хала-ра") + S:Ad) ;

# nouns that can go with Adj а́ӡа jung, frisch, unreif
LIST Noun_аӡа = "а-ҧсы́" "а-ны́шә" "а́дгьыл" "а-кәа́ц" "а́-махә" "а-џьықәре́и"
                "а-кы́кахш" "а-уаҩы́" "а-хы́" "а-хы́ш" "а́-хш" "а-бҕьы́нҵә" "а-карто́ш"
                "а-кьа́т" "а-кәта́ҕь" "а-нхаҩы́" "а-па́ркь" "а-шьа́ц"
                "а-ҩы́" "а-ҭаҭы́н" "а-ҭы́рас" "а́-мажәа" "а́са" ;

SELECT ("а́ӡа") + Adj IF (-1 Noun_аӡа) ;

# -х-

LIST Headgear = "а-хы́лҧа" ; # and more

SELECT ("а-хы́·х-ра") + DO:Ad IF (-1 Headgear) ;

# sit on vehicle/horse
# could be further disambiguated by distinguishing between vehicle (иақәтәеит) and
# place to sit on (branch etc.) (иқәтәеит) as LO
REMOVE ("а́-қә·тәа-ра" LO:3SgM) ;
REMOVE ("а́-қә·тәа-заа-ра" LO:3SgM) ;

REMOVE ("а́-қә·тәа-ра") - LO:3SgNH ;
# REMOVE ("а́-қә·тәа-заа-ра") - LO:3SgNH ;

LIST VMoveTo = "а-ца-ра́" ;

SELECT VMoveTo IF (-1 PP:ҿы́) ;

# to be generalized: object + verb collocations

SELECT ("а́у-ра") + S:Rel IF (1 ("а-ҧа́ра")) ; 

# агәыҩбара иоуит он засомневался
SELECT ("а́у-ра") + S:Ad IF (-1 ("а-гәы́ҩбара")) ; 

LIST VMoney = "а́-ма-заа-ра" "а-шәа-ра́" "а́-ҭа-ра" "аа·га-ра́" "а́у-ра" "а́-р:ҧсах-ра" "а́-м·х-ра"
              "аа·га-ра́" "аа́·га-ра" "а́-ла·гала-ра" "а-з·а́у·жь-ра" "а-ҭ·га-ра́" "а-ҭа́-заа-ра"
              "а-цәы́·ӡ-ра" "а-ҭа·ҧса-ра́" "а́-ҧсах-ра" ;

SELECT ("а-ҧа́ра") IF (1 VMoney + Ad) ;
SELECT ("а-ҧа́ра") IF (1 ("«")) (2 VMoney + Ad) ;
SELECT ("а-ҧа́ра") IF (1 Adv) (2 VMoney - Ad) ;

SELECT VMoney + Ad IF (-1 ("а-ҧа́ра")) ;

LIST Smokable = "а-ҭаҭы́н" ;

SELECT ("а́-ха-ра") + Ad IF (-1 Smokable) ;

SELECT ("а-шәа-ра́") + Tr + Ad IF (-1 ("а-ҧа́ра")) ;

SELECT ("а-цәы́·ӡ-ра") + Ad IF (-1 ("а-ҧа́ра")) ;

SELECT ("а-ҧа́ра") IF (-1 ("а́у-ра") + S:Rel) ; 

LIST Payable = "а-ха́раҧса" "а-штра́ф" "а-маа́ҭ" "а-уа́л" "а́-хә" ;

SELECT ("а-р:шәа-ра́") + Tr IF (-1 Payable) ;

SELECT ("а-ҧҟа́ра") IF (1 ("а́-қә·ныҟәа-ра")) ;

SELECT ("а-иа́ша" Adj Sg) IF (-1 Noun) ;

SELECT ("а́-ҵаҟа" PP) IF (-1 Noun) ;

SELECT ("а́и·х·га-ра") + Tr + Ad IF (-1 ("а-шьаҿа́") OR ("а-шьапы́")) ;

SELECT ("а-ха́ра") IF (1 ("а́-д·ҵа-ра") + Ad) ;
SELECT ("а́-д·ҵа-ра") + Ad IF  (-1 ("а-ха́ра")) ;

# харада ахара идҵаны
SELECT ("а-ха́ра") + PP:да IF (1 ("а-ха́ра")) ;


SELECT ("а-ҳа-ра́") + Ad IF (-1 ("а́-каҭа")) ; # add more

SELECT ("а́-қә·ла-ра") + LO:NonHum3Sg IF (-1 ("а́-мҩа") OR ("а-дәы́")) ;

REMOVE ("а-р:ба-ра́") + Intr + Caus + DO:3 - DO:Ad ; # иирбеит

SELECT ("а-р:ба-ра́") + Intr + DO:Ad
   IF (-1 ("а-ҧхӡы́")) ; # more things that can be dried (off)

SELECT ("а-хра́") IF (1 ("а́-ла-заа-ра") + Ad) ;
SELECT ("а́-ла-заа-ра") + Ad IF (-1 ("а-хра́")) ;

# freeze/ask for
SELECT ("а-ҵаа-ра́") IF (-1* ("ҳәа́") BARRIER CLB) ; # not "а-ҵа́а-ра"
SELECT ("а-ҵаа-ра́") IF (-1 ("<–>")) ;

# ask for needs Hum Subj
REMOVE ("а-ҵаа-ра́") + Ad IF (-1 NH) ;
REMOVE ("а-ҵаа-ра́") + Ad IF (-1 Adj) (-2 NH) ;

SELECT ("а́·ҳәа-ра" DO:Ad) IF (-1 ("ҳәа́")) ;

SELECT ("а́·ҳәа-ра" DO:Ad) IF (-1 ("а́-цәгьа")) ;

SELECT ("а-ҳәа-ра́" DO:Ad) IF (-1 Pron + Dem) ;

REMOVE ("а́ҳәа") IF (0 ("а-ҳәа-ра́")) ;
REMOVE ("а-ҳәа́") IF (0 ("а-ҳәа-ра́")) ;

LIST Speech = "а́жәа" "а́ҧсшәа" "а-ныҳәаҿа́" ;

REMOVE ("а́-ҳәа-ра") IF (-1 Speech) ;

SELECT ("а-ҳәа-ра́" DO:Ad) IF (-1 Speech) ;

# generalize!
REMOVE ("а́-ҳәа-ра") + S:Ad IF (-1 Advb) ;

REMOVE ("а́·ҳәа-ра" DO:Ad) IF (-1C Hum) ;
SELECT ("а́·ҳәа-ра" DO:Ad) IF (-1 ("а́ҧсшәа")) ; # begrüßen
SELECT ("а́·ҳәа-ра") + DO:Ad + Neg IF (-1 ("акы́") + Encl:гьы) ;

REMOVE ("а-ҳәа-ра́" DO:Ad) IF (-1C Hum) ;

# generalize to other verbs with NH DO
REMOVE ("а-гәа́ла·р:шәа-ра" DO:Ad) IF (-1C Hum) ;

REMOVE ("а-гәа́ла·р:шәа-ра" DO:Ad) IF (1* How BARRIER CLB) ;

REMOVE ("а́-ҧсаа-ра") + S:Hum ;

# problematic for fairy tails with animals acting
REMOVE ("а́-рҳәа-ра" S:3SgNH) ;
REMOVE ("а-рҳәа-ра́" S:3SgNH) ;
REMOVE ("а́·ҳәа-ра" LO:3SgNH) ;
REMOVE ("а-ҳәа-ра́" Lab) ;
REMOVE ("а-р:ҳәа-ра́" Caus Lab) ;

SELECT ("а-ҳәа-ра́" DO:Ad) IF (-1 Fin) ; # … дахыҵит рҳәон

SELECT ("а-з·е́иҭа·ҳәа-ра") ;
SELECT ("а́иҭа·ҳәа-ра") ;

REMOVE ("а́-ҳәа-ра" IO:Rec) ;
REMOVE ("а-ҳәа-ра́" IO:Rec) ;

SELECT ("а-ҳәа-ра́" DO:Ad) IF (-1 ("а́-хьӡ")) ;

SELECT ("а-ҳәа-ра́") IF (-1* ("а-ныҳәаҿа́")) ; # … and more

SELECT ("а-ҳәа-ра́") IF (-1 ("а-ҭе́л") + PP:ла) ;

SELECT ("аха́ангьы" Adv) ;

SELECT ("бзи́ала" Adv)
    IF (NOT -1 Noun) ;


# игәы иҭазу
SELECT ("а-ҭа́-заа-ра") + LO:NonHum3Sg IF (-1 ("а-гәы́")) ;
# try to generalize differently!
SELECT ("а-ҭа́-заа-ра") + LO:NonHum3Sg + Neg IF (-1 Comma) (-2 ("а-ҭа́-заа-ра")) (-3 ("а-гәы́")) ;

# ?? check!
SELECT ("а-ҭа́-заа-ра") - LO:3SgNH IF (-1 ("а-ҧсы́")) ;
SELECT ("а-ҧсы́" H) IF (1 ("а-ҭа́-заа-ра")) ;

# add similar ones where LO cannot be animate
# this one can be animate!
# REMOVE ("а-ҭа́-заа-ра" LO:3SgM) ;

SELECT ("а-р:ха-ра́") IF (-1 ("а-хы́") OR ("а-гәы́") OR ("а-напы́")) ; 

# remove the first one when the second one works
SELECT ("а-р:а́ҳа-ра") + Ad IF (-1 ("а-хы́") OR ("а-ҿы́")) ; 
SELECT ("а-ра́ҳа-ра") + Tr + Ad IF (-1 ("а-хы́") OR ("а-ҿы́")) ; 

REMOVE ("а-р:а́ҳа-ра") IF (0 ("аҳа-ра́")) ;
REMOVE ("а-ра́ҳа-ра") IF (0 ("аҳа-ра́")) ; # difficult to disambiguate

SELECT ("а́-хара") IF (-1 ("а-ҭаҭы́н")) ;

SELECT ("а-у-ра́" Tr DO:Ad) IF (-1 ("а-у́с")) ;

REMOVE ("а-ҭахы́") IF (0 ("а-ҭах-ра́")) ;

SELECT ("а-зы́" "<.*зы>"r PP) ;

SELECT ("а́-ма-заа-ра" "<рыман>") ; # not а́рма

SELECT ("а-х·ҽ-ра́") + DO:Ad IF (-1 ("а́-хәда")) ;

# -ла-

# generalize!
SELECT ("а́-ла-заа-ра") - S:Ad
    IF (-1 ("а́-бна")) ;

# -ҭа-

LIST Noun_ҭа = "а-мшы́н" "а-у́ҭра" ; # many more!!

LIST V_ҭа = ".*-ҭа-.*"r ".*-ҭа́-.*"r ".*-ҭа·.*"r ".*-ҭа́·.*"r  "а-ҭа́-заа-ра" ;

SELECT V_ҭа + LO:3SgNH IF (-1 Noun_ҭа) ;

SELECT ("а-ҭа·у-ра́") IF (-1 ("а-бы́сҭа")) ;

REMOVE ("а-ҭа·у-ра́") ; # competes with аҭазаара in иҭоу

# REMOVE ("а-ҭа́-заа-ра" LO:3SgM) ;

REMOVE ("а́-ҭа-ра" StatPass) ;

# -ҩ-

LIST V_ҩ = "а-ҩны́·с-ра" ;

SELECT ("а-уа́да") IF (1 V_ҩ + LO:NonHum3Sg) ;

REMOVE ("у́нан") IF (NOT 1 Comma OR ("<џьбеит>")) ;

SELECT ("а́-хәа-ра") IF (-1 ("а-хы́")) ;

# пользоваться чем-л.
SELECT ("а́-р:хәа-ра") + IO:3SgNH IF (-1 ("а-хы́")) ;

SELECT ("а-хы́") IF (1 ("а́-р:хәа-ра") OR ("а́-хәа-ра")) ;

REMOVE ("а́-ҭаа-ра") + HumDO ; # only inanimate direct object

REMOVE Noun + Pl IF (1 ("а-ҭы́ҧ") + Pl - Det) ;

REMOVE Det + PP:да ;
REMOVE Poss + PP:да ;

"<иқәын>" REMOVE ("а-қәны́") ; # Lein

SELECT ("ара́" Adv) IF (-2 ("ана́" Adv)) ; 

REMOVE ("аҽны́" Adv) IF (-1 ("уи́")) ;
SELECT ("уи́" Dem) IF (1 ("а-ҽны́")) ;

REMOVE ("а́-ма-заа-ра" S:1Pl LO:3SgNH) ; # IF (0 S:3 + S:Ad + LO:1Pl)

SELECT ("а-ха́·шҭ-ра" Tr Impv) ; # (иухаумыршҭын!), see Yan.
REMOVE ("а-ха́·шҭ-ра" Tr) ;

SELECT ("а-ҧсы́" H) IF (1 ("а-ӡа-ра́")) ;
SELECT ("а-ӡа-ра́") IF (-1 ("а-ҧсы́" H)) ;

LIST Hydro = Hydronym "а-ӡи́а" "а-ӡи́ас" ;

SELECT ("а́-р-ра" LO:3SgNH) IF (-1 Hydro) ;

SELECT Hydronym IF (1 ("а-ҧшаҳәа́")) ;

# generalize!
REMOVE ("а-џь-ра́" DO:Ad) IF (-1C H) ;

# till the soil
SELECT ("а-ҽа-ра́") + Tr IF (-1 ("а́дгьыл")) ;

LIST Seeds = "а-шы́" "а́-хәыӡ" ;

SELECT ("а́-ла·ҵа-ра") + Ad
    IF (-1 Seeds) ;

SELECT Seeds IF (1 ("а́-ла·ҵа-ра") + Ad) ;
SELECT Seeds + COORD IF (1 Seeds + COORD) (2 ("а́-ла·ҵа-ра") + Ad) ;

# Rel + Noun

LIST ReadingStuff = "а-шәҟәы́" ;

REMOVE ("а́-лы·ҩ-ра") + Rel
    IF (0 ("а́-ҩ-ра") + Rel)
       (1 ReadingStuff) ;


SELECT QUEST IF (1 IntMark) ;

REMOVE S:Ad - VSaying - LHP IF (-1 Punct OR Adv) ;

SELECT LHP IF (1C RHP) ;

# ======== #
  SECTION  #
# ======== #

# Heuristics
# ========================

# Remove Poss:3SgNH at sentence start

SELECT Impv
    IF (0C* Impv BARRIER CLB) ;

# dangerous
#REMOVE Poss:3SgNH
#       IF (-1 BOP) ;

# but: ила
# SELECT PP IF (-1 Noun) ;

# ?? check in corpus
SELECT ("а́-ла") + PP + Poss:3Pl IF (-1 Noun + Pl) ;

# dangerous!
# SELECT ("а́-ла" PP) ; # could in rare cases be Noun

# 15 мшы рыла
SELECT ("а́-ла") + PP + Poss:3Pl
   IF (-1 Noun)
      (-2 Num + Card) ;

# REMOVE StatPass IF (0 Stat) ;

# REMOVE Again ;

REMOVE Opt + StatPass ;

# dangerous?
SELECT Poss:3SgM OR Poss:3SgF
    IF (-1 Pron + Pers + 3Sg) ;

SELECT Pron + Pers + 3Sg
    IF (1 Poss:3SgM OR Poss:3SgF) ;

SELECT ("уи́" Pers) # not Dem
    IF (1C Pred + LHP) ;

#SELECT Pron + Pers
#    IF (1C V) ;

SELECT Pron + Pers
    IF (1 Pron + Quant) ;

REMOVE NH IF (0 H) (1C DO:3SgH) ;

# rare verb
REMOVE ("а́-дыр-ра") ;
REMOVE ("а́иц·дыр-ра" Intr) ;

REMOVE ("а-ды́р-ра") + Neg - Reln:Pot ;

REMOVE ("а́-р:дыр-ра") IF (0 ("а-ды́р-ра")) ;

REMOVE ("а́-маӡа") IF (0 ("а́-ма-заа-ра")) ;

REMOVE Pred + EveryTime ;
SELECT EveryTime ;

SELECT ("а́-ҭа-ра") + Ad IF (-1 ("ҭа́ха") OR ("а-ҭа́к")) ;

SELECT ("ари́" Pron) ;
SELECT ("ара́ҟа" Adv) ;

REMOVE ("а́-х") ; # ахы

SELECT ("а-ба́р") IF (1 ("а-ҟны́")) ;

SELECT ("аба́р") ;

SELECT ("а-ҿы́" PP) IF (-1 ("зегьы́")) ;

SELECT ("а-ха́ҵа") + H + Poss:3SgF ; # лхаҵа
SELECT ("а-ҧа́") + H + Poss:3SgF ; # лҧа
SELECT ("а-ҧа́") + H IF (1 ("а-х·ша-ра́")) ;

# common verbs

REMOVE ("а-ба-ра́") + Subj IF (0 ("а́-л·баа-ра")) ;

# but: илаба!
SELECT ("а-ба-ра́") IF (NOT 0 ("а-лаба́") OR ("бара́") OR ("а-на́л·баа-ра")) ;

#SELECT ("а-бзи́а") + Adj - Det
#    IF (1 ("а-ба-ра́")) ;

SELECT ("а-ба-ра́" Tr)
    IF (-1 ("бзи́а" Adv)) ;

SELECT ("а-ба-ра́" Tr)
    IF (0C V)
       (NOT 0 ("а-на́л·баа-ра")) ;

REMOVE ("а́иба·ба-ра" DO:Ad) IF (-1 ("а-бзи́а")) ;

SELECT ("а́-хәа-ра") IF (-1 ("а-гәы́")) ;

SELECT ("аҳа-ра́") IF (-1* ("а́-ӡбахә") BARRIER CLB) ;

SELECT ("аа·на́га-ра") IF (-1 ("а-гәы́")) ;
SELECT ("аа·на́га-ра") IF (-1 Adv) (-2 ("а-гәы́")) ;
SELECT ("аа·на́га-ра") IF (1 ("а-гәы́")) ;

# not а́-лага-ра (молоть) except for илагеит
SELECT ("а́-ла·га-ра" LO:3SgNH)
    IF (NOT 0 LO:3SgM) ;

LIST TeachingPlace = "а-шко́л" "а-факульте́т" "а-семина́риа" "а-институ́т" "аспиранту́ра"
     	      "а-те́хникум" "а-ҵараи́урҭа" "а-ҵара́" ;

SELECT ("а́-л·га-ра" Intr) IF (0* TeachingPlace) ;

LIST Way = "а́-мҩа" "а-мҩаду́" "а-мҩахәа́сҭа" ;

SELECT ("а́-л·га-заа-ра") IF (0* Way OR ("а-ҭе́л")) ;

LIST Pupil = "а-хша́ра" "а-ҿа́р" "а-хәыҷы́" ;

# ??
SELECT ("а́аӡа-ра") IF (0* Pupil) ;

LIST bodilyFeeling = "а́-мла" "а-ӡба́" "а́-хьҭа" "а-шо́ура" "а́-цәа" "а́-чча" "а-ӡы́ша" ;

SELECT ("а-к-ра́" Intr)
    IF (-1 bodilyFeeling) ;

# more?
SELECT ("а-у-ра́") OR ("а-з·у-ра́")
    IF (-1 ("а-қәа́")) ;

SELECT ("а-с-ра́") IF (-1 ("а-ҧша́")) ;

SELECT ("а́-қә·ҵа-ра") IF (-1 ("а-хы́") OR ("а́-ҳаҭыр") OR ("а́-пату") OR ("а-ҭы́ҧ")) ;

SELECT  ("а́иқәаҵәа" Adj) IF (-1 ("а-пасма́")) ;

SELECT ("а́-қәла") IF (0* ("а-ҩы́за")) ;

SELECT ("а́-ҵәца") IF (1* ("а́зна") OR ("а-ӡы́")) ; # etc.

REMOVE ("а-це́и-ра") ;

SELECT ("а́-ҟа·ла-ра") + PastIndef + Rel; # иҟалаз

# иаауҭаххалак зегьы ахьубо аџьырмыкьаҿы дцаны деимдарц
REMOVE ("а́-дар-ра") IF (0 ("а́и·м·да-ра")) ;

SELECT H IF (1 ("а́-ц-заа-ра")) ;

SELECT ("а́-ма-заа-ра" S:Ad) IF (-1 ("ха́р")) ;

SELECT ("а́-жә-ра" Abs) IF (1 ("а́-ҟа-заа-ра")) ;

List Beverage = "а-ӡы́" "а-ҩы́" "а-ча́и" "а-каҳуа́" "а-уа́тка" "а-уара́ш" "а-шәы́рӡ"
                "а-ко́ниак" "<мартини>" ;

SELECT ("а́-жә-ра") + Tr + Ad IF (-1 Beverage) ;
SELECT ("а́-жә-ра") IF (1 Beverage) ;

SELECT ("а-ҩы́") IF (1 ("а́-жә-ра")) ;

SELECT ("а-жьы́") IF (1 ("а́-фа-ра")) ;

SELECT ("а-қы́жә") IF (1 ("а-жьы́")) ;

# ишиҳәаз еиҧш
SELECT How IF (1 ("а́иҧш")) ; 

SELECT ("а-ҳәа-ра́" How) IF (1 ("а́иҧш")) ; 

SELECT ("а́иҧш" Poss:3SgNH) IF (-1C V) ;


# REMOVE ("а́хьӡ-заа-ра") ; # competing with а́-хьӡ-заа-ра

SELECT Prop + Anthr + F IF (1 Poss:3SgF) ; # Амза лнапы …

SELECT ("а-ӡы́" PP:ҿы́) ;

SELECT ("а-гьа́ма") ; # not а́-ма-заа-ра

SELECT ("аа·ӡа-ра́") IF (-1 PP:нӡа) ;

REMOVE ("а́-ла-заа-ра" LO:2SgF) ; 

# prefer noun with first stem consonant б
REMOVE Poss:2SgF IF (0 ("(а|а́)-б.*"r)) ;

# selection restriction
REMOVE ("а-кы́" Adj)
    IF (-1 Noun + NH) ;

# SELECT ("а-ҧсы́") ; # but: бааҧс!
SELECT ("а-гәы́") IF (NOT 0 ("а-гәы́ла"))
       		    (NOT 0 ("а-гәа́а-ра"))
		    (NOT 0 ("а-гә·к-ра́")) ;

# SELECT ("а-хы́") IF (0C Noun) ;

SELECT ("а́-лахь") IF (1 ("а́и·ҵы·х-ра")) ;

# can go wrong?
SELECT ("а́-шьҭахь") + PP + Poss:3SgM IF (-1 H OR M OR LastName) ; 
SELECT ("а́-шьҭахь") + PP + Poss:3Pl IF (-1 Pron + Pl) ; 

SELECT ("уа́" Adv) ;

SELECT ("а́а·на·га-ра") ;

REMOVE ("а-гы́ла") IF (0 ("а-гы́ла-заа-ра")) ; # дгылан

SELECT Neg + Emph IF (0C Neg) ;

SELECT ("а-ха́-заа-ра")
       IF (-1 PP:ҟа OR PP:ахь OR ("а́хь") OR ("а́-шҟа") OR ("а́ҩада") OR ("а-хы́"))
          (NOT 0 ("а-ҩа́ха-ра")) ;

SELECT ("<ихан>" "а-ха́н" NH) IF (-1 Anthr OR H) ;

# Ба бшәахәоуп
SELECT ("ба́") + Pron IF (1 AM:2SgF) ;

SELECT Impv + S:2Pl ;

REMOVE LO:Rec + FPv:аа ; # дааиҧырагыланы
# REMOVE LO:3SgM - FPv:на IF (0 LO:Rec) ; # неицуҵар etc. ??
REMOVE RO:3SgM IF (0 RO:Rec) ; # неицуҵар etc.

REMOVE Noun + Num ;

# REMOVE FPv ;

REMOVE ("аа́.*"r) + FPv:аа ;

REMOVE VN + Stat IF (0 VN + Dyn) ; # prelim.

REMOVE VN - DET - Poss ;

REMOVE Ad IF (-1C Adj + Emph) ; # is Adv

# dangerous
# REMOVE Noun IF (0C NOUN) (NOT 0 Pl) (NOT 0 POSTP) ;
REMOVE VN IF (0C NOUN) (0 Pl) ;

# add interrogative?
REMOVE Reln:Pot - Neg - FarFrom ;

# REMOVE Poss:3SgNH ;

# competes with trans. relative
REMOVE StatDer + Why ;

# REMOVE Pred - Adj ;

REMOVE Rhet ;

REMOVE Excess ;

REMOVE Iter ;

REMOVE Subj ;

# REMOVE Adj + Det - <PreAdj> - (".*тәи"r) ;

REMOVE NumPfx - Indet ;
REMOVE NumPfx + Det ;

REMOVE <NoLex> - Adv - PP - Num - Prop - ("а́кә-заа-ра") - ("а-кы́-заа-ра") ;

# Cleft
SELECT Rel IF (-1C Cop) ;

SELECT Again + Rhet ;

SELECT Again + ("а-ды́р-ра") ; # издырхуада

REMOVE Again ;

REMOVE <HuntingLang> ;

SELECT ("дара́") ;

#SELECT Adv ;

SELECT ("а-ҿы́") + PP + Poss:3Pl IF (-1C NH + Pl) ;

REMOVE Det + Advb ;

REMOVE Emph - Neg ;

REMOVE AgainPfx - Again ; # often occur together

REMOVE ("а́и·ла.*"r) IF (0 ("а́ила.*"r)) ;
REMOVE (".*·е́и·ла.*"r) IF (0 (".*·е́ила.*"r)) ;

REMOVE Reln:With IF (0 (".*-ла·.*"r V)) ;

REMOVE (/Poss:/r) + Pred IF (0 V) ;

REMOVE VN + Indet ;

# nonhum causee
REMOVE Cs:3SgNH ;

SELECT Fin IF (NEGATE 0* V OR Pred BARRIER Period OR (Cj Coord)) ; # аҳа

REMOVE NonFin - Rel - Abs IF (1C Noun - Pred) ;

# ??
REMOVE StatPass ;

# exceptions for <Lemma>:

LIST LemmaExcept = "а́ҳцәа" ; # Pockennarben

SELECT <Lemma> - LemmaExcept
    IF (NOT -1 BOS)
       (NEGATE -1 Dash OR ("“") OR ("«") LINK -1 BOS) ;

# word is uppercase form of lemma
SELECT <LemmaLC> ;

SECTION

REMOVE FPv ;

# END

# ==================== #
  SECTION	       #
# 	   	       #
# Dependency relations #
# ==================== #

LIST RELS = /^>/r ;

SET N = NOUN - EPOSTP - Pred ;

SET COP = ("а́кә·ха-ра") + Cop | ("а́кә-заа-ра") + Cop ;

# ҽак зны
WITH NOPARENT ("зны́") OR ("зны")
  IF (-1 ("ҽна́к") OR ("а́-шқәс"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >ADVMOD (*) ;
} ;  

# иара убас
WITH NOPARENT ("уба́с")
  IF (-1 ("иара́"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >FLAT (*) ;
} ;

WITH NOPARENT LastName IF (-1 Anthr + MF) (NEGATE p (*)) {
   MAP >FLAT:NAME (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Абгахәыҷи Аҵысҕреи
WITH NOPARENT COORD
  IF (-1 COORD)
     (NOT p (*)) {
   MAP >CONJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
   REMCOHORT IGNORED WITHCHILD (*) (*) ;   
} ;

#WITH NOPARENT COORD
#  IF (2 COORD + Poss:3SgNH)
#     (1 Pron + Pers + 3Sg)
#     (NOT p (*)) {
#   MAP >CONJ (*) ;
#   SETPARENT (*) TO (jC1 (*)) ;
#   REMCOHORT IGNORED WITHCHILD (*) (*) ;   
#} ;


WITH NOPARENT COORD + Poss:3SgNH
  IF (-2 COORD)
     (-1 Pron + Pers + 3Sg)
     (NOT p (*)) {
   MAP >CONJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
   REMCOHORT IGNORED WITHCHILD (*) (*) ;   
} ;

# attach POSTP with >CASE to head noun

WITH NOPARENT PP | ("нахы́с")
     IF (-1 Noun - Abs |
         Rel - QUEST |
         Pron + Pers + 3Sg |
         Pron + Dem |
         How |   # шыҟаз ахь
         Where | # иахьиго азы
         ("уажәы́") |
         ("жәытәна́тә") | # жәытәнатә аахыс # fixme: either MWE or Noun + PP
         ("ҧы́ҭрак") | # ҧыҭрак ашьҭахь
         ("аба́с" Adv)) # аба́с а́ла
        (NOT p (*)) {
   MAP >CASE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# рацәак аамҭа
WITH NOPARENT ("а́-рацәа") + Adj + Sg + Indet
     IF (1 ("а́амҭа"))
        (NOT p (*)) {
   MAP >AMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# ишызбаз сзымдыруа аҟара сгаӡоума?
WITH NOPARENT ("а́ҟара")
     IF (-1 NonFin - Abs)
        (NOT p (*)) {
   MAP >CASE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Purp + азы
# афҩы мгарц азы
WITH NOPARENT PP + ("а-зы́")
     IF (-1 Purp)
        (NOT p (*)) {
   MAP >CASE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# сара сахь
WITH NOPARENT PP + Poss:1Sg
     IF (-1 Pron + Pers + 1Sg)
        (NOT p (*)) {
   MAP >CASE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT PP + Poss:2SgM
     IF (-1 Pron + Pers + 2SgM)
        (NOT p (*)) {
   MAP >CASE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT PP + Poss:2SgF
     IF (-1 Pron + Pers + 2SgF)
        (NOT p (*)) {
   MAP >CASE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT PP + Poss:1Pl
     IF (-1 Pron + Pers + 1Pl)
        (NOT p (*)) {
   MAP >CASE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT PP + Poss:2Pl
     IF (-1 Pron + Pers + 2Pl)
        (NOT p (*)) {
   MAP >CASE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# attach Num to Noun; NH missing!

WITH NOPARENT Num + H + Indet + Card
  IF (1C Noun + H + Pl)
     (NOT p (*)) {
   MAP >NUMMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Num + H + Indet + Card
  IF (1C Noun + H - Det)
     (2 Adj + Pl) {
   MAP >NUMMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# attach Pron Dem to Noun

WITH NOPARENT Pron + Dem + Sg - Encl:гьы
  IF (1C Noun - Pred + Det)
     (NOT 1 S:Ad)
     (NOT 2 COP)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >DET (*) ;
} ;

# attach Pron Int to V
WITH NOPARENT Pron + Dem + Pl
  IF (1C Noun + Pl)
     (NOT 2 COP)
     (NOT p (*)) {
   MAP >DET (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# attach Pron Int to V

# шаҟа иссиру, заҟа устахыз; change to Adv Int
WITH Adv + Int + NH
  IF (1C V + Q - Rel | Pred + Q - Rel)
     (NOT p (*)) {
   MAP >ADVMOD:Q (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# complex predicates
WITH RHP
  IF (-1 LHP)
     (NOT p (*)) {
   MAP >COMPOUND:PRED (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# акыр
WITH NOPARENT ("акы́р")
   IF (1 (*))
      (NOT p (*)) {
   MAP >ADVMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;



# attach Adj to Noun, hide Adj
# not sure using REMCOHORT is correct here

WITH NOPARENT Adj + <PreAdj> IF (1C Noun) (NEGATE p (*)) {
   MAP >AMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
   REMCOHORT IGNORED WITHCHILD (*) (*) ;
} ;

WITH NOPARENT Adj - Emph - Poss - EPOSTP  # ?? | Pron + Quant
   IF (-1C Noun - POSTP | Rel - QUEST)
      (NOT 0 Advb)
      (NOT 0 Pred)
      (NOT p (*)) {
   MAP >AMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
   REMCOHORT IGNORED WITHCHILD (*) (*) ;
} ;

WITH NOPARENT ("зегьы́") + Quant
   IF (-1 Noun OR Pron)
      (NOT p (*)) {
   MAP >DET (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
   REMCOHORT IGNORED WITHCHILD (*) (*) ;
} ;

#> ADD CopNounFin N | Pron IF (1 COP) (NOT 0 CopNounFin) ;

#>
# WITH NOPARENT COP
#  IF (-1 Noun - EPOSTP | Pron + Pers)
#     #(NEGATE c >CCOMP:RELCL)
#     (NOT p (*)) {
#  MAP >COP (*) ;
#  SETPARENT (*) TO (jC1 (*)) ;
##  REMCOHORT IGNORED (*) ;
#} ;

SETPARENT Num + Ord
        IF (NEGATE p (*))
	TO (1C Noun) ;

# is PP, but functions like ADVMOD (?)
WITH ("а́ҟара")
  IF (-1 Adv)
     (NOT p (*)) {
#  MAP >ADVMOD (*) ;
  MAP >CASE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# еиҧш

WITH ("а́иҧш")
  IF (-1 V)
     (NOT p (*)) {
  MAP >MARK (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH V
  IF (1* VMain)
     (1 ("а́иҧш") + >MARK)
     (NOT p (*)) { 
  MAP >ADVCL (*) ;  
  SETPARENT (*) TO (jC1 (*)) ;
} ;


WITH NOPARENT Pron + Dem + Sg | Noun - Pl - H
     IF (1 Poss:3SgNH - >CASE) (NOT p (*)) {
     MAP >NMOD:POSS (*) ;
     SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT H - Abs | Anthr + M
     IF (1 Poss:3SgM - >CASE - V) (NOT p (*)) {
     MAP >NMOD:POSS (*) ;
     SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Coord
  IF (1 N + Coord)
     (NOT p (*)) {
   MAP >CONJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Coord | Adj + Coord
  IF (-2 N + Coord)
     (-1 Comma | Pron + Pers)
     (NOT p (*)) {
   MAP >CONJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# fixme!
WITH NOPARENT Anthr + MF
  IF (2 Anthr + MF)
     (1 LastName + Coord)
     (3 LastName + Coord)
     (NOT p (*)) {
   MAP >CONJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Pron + Dem + Pl | Noun + Pl | Noun + Coord | Adj + Coord
     IF (1 Poss:3Pl)
        (NEGATE c >CASE)
        (NOT p (*)) {
     MAP >NMOD:POSS (*) ;
     SETPARENT (*) TO (jC1 (*)) ;
} ;


# акәхеит
WITH NOPARENT Pron + Pers + 3Sg | Pron + Dem + Sg | N - Pl
  IF (1 IO:3SgNH + Cop)
     (NOT p (*)) {
   MAP >XCOMP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Ҳәыски, лаки, цгәыки ракәын имаӡаз.
WITH NOPARENT Pron + Pers + 3Pl | Pron + Dem + Pl | N + Pl | N + Coord
  IF (1* IO:3Pl + Cop BARRIER VMain)
     (NOT p (*)) {
   MAP >XCOMP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH ("аба́р") + Adv
  IF (1 N) # generalize!
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ADVMOD (*) ;
} ;

# apposition

WITH Hum | Noun
  IF (-1 ("а́-хаара") + Poss:1Sg)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >APPOS (*) ;
} ;

WITH Hum | Noun
  IF (-2 Pron + Pers + 2Pl)
     (-1 Comma)
     (NOT p (*)) {
   MAP >APPOS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;   
} ;

# has to be refined!
# еицырдыруа аҧсуа шәҟәыҩҩцәа Анзор Мықәбеи Сарион Ҭаркьыли
WITH Anthr + MF - POSTP
  IF (-1* ("а-шәҟәыҩҩы́"))
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;   
   MAP >APPOS (*) ;
} ;

# ??
WITH NOPARENT Noun - EPOSTP OR Pron + Dem OR ("ус")
  IF (1* ("а́кә-заа-ра") BARRIER CLBc LINK NONE c >XCOMP)
     (NEGATE c >CASE)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >XCOMP (*) ;
} ;

# Абри иоуп бзиа избо.
WITH NOPARENT Noun + Hum - EPOSTP OR Pron + Dem
  IF (1* ("а́кә-заа-ра") + IO:3SgM BARRIER CLB)
     (NEGATE c >CASE)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >XCOMP (*) ;
} ;

WITH NOPARENT Pron + 3SgM
    IF (1 Poss:3SgM)
       (NOT c >CASE)
       (NOT p (*)) {
   MAP >DET (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Pron + 3SgF
    IF (1 Poss:3SgF)
       (NOT c >CASE)
       (NOT p (*)) {
   MAP >DET (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

SETPARENT Pron + 3Sg
         IF (NEGATE p (*))
            (NEGATE c >CASE)
         TO (1 Poss:3SgNH) ;

SETPARENT Rel
        IF (NEGATE p (*))
	TO (1* ("а́-кә-заа-ра")) ;

# сара соума хәарҭара злам ҳәа иуҧхьаӡо!
WITH V | Noun
  IF (1 Prt + Quote LINK 1 ("а́-ҧхьаӡа-ра"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >XCOMP (*) ;
} ;

SETPARENT V + When
        IF (NEGATE p (*))
	TO (1 TempNoun) ;

# See Yan., ауп 2.
WITH ("а́уп")
  IF (-1 V + Fin)
     (NOT p (*)) {
  MAP >ADVMOD (*) ;
  SETPARENT SAFE (*) TO (jC1 (*)) ;
} ;

# attach postpositional phrase to verb
# generalise!

# compounds
WITH ("а́-бна")
  IF (1 ("а-та́ура"))
     (NOT p (*)) {
  MAP >COMPOUND (*) ;
  SETPARENT SAFE (*) TO (jC1 (*)) ;
} ;

WITH ("а-кәа́ц")
  IF (1 ("а-жьхәҭа́"))
     (NOT p (*)) {
  MAP >COMPOUND (*) ;
  SETPARENT SAFE (*) TO (jC1 (*)) ;
  REMCOHORT IGNORED WITHCHILD (*) (*) ;
} ;

WITH ("а-нырха́га")
  IF (1 ("а́-цә"))
     (NOT p (*)) {
  MAP >COMPOUND (*) ;
  SETPARENT SAFE (*) TO (jC1 (*)) ;
  REMCOHORT IGNORED WITHCHILD (*) (*) ;
} ;

WITH Pl
  IF (1 Pron + Indef)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >NMOD (*) ;
} ;
     

# Италиа жәҩуан
WITH Prop + Place
  IF (1 Noun - Det)
     (NOT p (*)) {
   MAP >NMOD (*) ;
   SETPARENT SAFE (*) TO (jC1 (*)) ;
} ;


# testing: Abs forms that have adverbial function and cannot take local adverbials
LIST AbsAdv = "а́-рацәаҩ-заа-ра" ;

# noun / adj / pron with local postposition
WITH Noun | Pron | Adv
  IF (1* V - AbsAdv | Pred BARRIER Comma)
     (c PP | Adv + >CASE)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# саагәа in meiner Nähe
WITH ("а́аигәа") + Poss
  IF (1* V - AbsAdv | Pred BARRIER Comma)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# clause with local postposition 
WITH Rel - QUEST | NonFin
  IF (1* V | Pred BARRIER Comma)
     (c PP | Adv + >CASE)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH ("бзи́а")
  IF (1 ("а-ба-ра́") - DO:Ad)
     (NOT p (*)) {
  MAP >COMPOUND:PRT (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# мап зкыз
WITH NOPARENT ("ма́п")
     IF (1 DO:3)
        (1 DO:Ad)
        (NONE c >OBJ)
        (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# is this correct?
WITH NOPARENT ("нас") # Cj + Coord | Cj + Sub
  IF (1* VMain - Opt)
     (NOT p (*)) {
   MAP >CC (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Adv
  IF (1* V | Pred | VN Barrier Comma | Colon)
     (NOT p (*)) {
   MAP >ADVMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Noun + EPOSTP | VN + EPOSTP | Adj + EPOSTP
  IF (1* V | Pred | VN Barrier Comma | Colon)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Noun + EPOSTP | Adj + EPOSTP
  IF (1* VMain | VN BARRIER Colon)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Уаҧхьа ишызбаз сзымдыруа
WITH NOPARENT PP + Poss
  IF (1* V | Pred | VN)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;


WITH NOPARENT Noun | Adj | Pron
  IF (1* V | Pred | VN BARRIER Comma)
     (c >CASE)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Noun + EPOSTP | VN + EPOSTP
  IF (-1* V)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Ашәаҳәара иааҟәыҵит уи нахыс
WITH NOPARENT Noun OR Adj OR Pron
  IF (-1* V OR Pred OR VN BARRIER Comma)
     (c >CASE)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# A Noun-like compounds
# анырхага цәқәагьы
# rework this!
#WITH NOPARENT Noun + Det - Pl
#  IF (1C Noun - Det - Poss)
#     (NEGATE p (*)) {
#   MAP >AMOD (*) ;
#   SETPARENT (*) TO (jC1 (*)) ;
#   REMCOHORT IGNORED WITHCHILD (*) (*) ;
#} ;

# Advb case as predicate

WITH Advb
  IF (1 ("а́-ҟа-заа-ра"))
     (NOT p (*)) {
  MAP >XCOMP (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;
     

# verbs that take Purp as LO
SET VPurpLO = ("а-ҿы́-заа-ра") OR ("а́-ла·га-ра") OR ("а́-қә·к-ра") OR ("а́-л·ша-ра") OR ("а́-шьҭа-заа-ра") OR
              ("а́-ҵ·ҟьа-ра") ;

# verbs that take Purp as DO
SET VPurpDO = ("а-ҭах-ра́") ;

# verbs that take VN as LO
SET VVNLO =  ("а-ҿы́-заа-ра") OR ("а́-шьҭа-заа-ра") OR ("а́-ла·га-ра") ;

# verbs that take NonFin Pres as LO
SET VNonFinPresLO =  ("а́-ла·га-ра") ;

WITH NOPARENT Purp
  IF (1 VPurpLO)
     (NOT p (*)) {
   MAP >CCOMP:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Purp IF (1 VPurpDO) (NEGATE p (*)) {
   MAP >CCOMP:OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT VN
  IF (1 VVNLO)
     (NOT p (*)) {
   MAP >XCOMP:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT NonFin + Pres - Rel
     IF (1 VNonFinPresLO)
        (NOT p (*)) {
   MAP >XCOMP:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT NonFin | How
     IF (1 ("а-ды́р-ра") + DO:Ad)
        (NOT p (*)) {
   MAP >CCOMP:OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT NonFin | How
     IF (1 ("а-ды́р-ра") + S:Ad + Pot)
        (NOT p (*)) {
   MAP >CSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# V + игәы иҭоуп
# ахьаҵра згәы иҭамыз Амшәгьы
WITH NOPARENT Purp
     IF (2 ("а-ҭа́-заа-ра"))
        (1 ("а-гәы́"))
        (NOT p (*)) {
   MAP >CCOMP:PURP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT VN - PP
     IF (2 ("а-ҭа́-заа-ра"))
        (1 ("а-гәы́"))
        (NOT p (*)) {
   MAP >CCOMP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# шрылӡааз агәра анага
WITH NOPARENT How
     IF (2 ("а-га-ра́"))
        (1 ("а-гәра́"))
        (NOT p (*)) {
   MAP >CCOMP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Rel - QUEST
     # exclude nouns that probably are part of compound verb (or how to call it?)
     IF (1 Noun - ("а-хы́") - ("а-гәы́")
         | Pron + Quant)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ACL:RELCL (*) ;
};

WITH Rel - QUEST
     # exclude nouns that probably are part of compound verb (or how to call it?)
     IF (1*w Noun - ("а-хы́") - ("а-гәы́") OR Pron + Quant)
        (1 Comma)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ACL:RELCL (*) ;
};

# шаҟаҩы рҭахыз амаҵуцәагьы
WITH NonFin - Abs - QUEST
     IF (1 Noun - ("а-хы́") - ("а-гәы́")
         | Pron + Quant)
        (-1 Pron + Int | # which should be Rel instead?
            Noun + Poss:Rel)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ACL:RELCL (*) ;
};

# not sure if this is the best analysis
# Ауаа ракәым, аҧстәқәагьы ацәгьа ҟазҵақәо ирықәҿиаӡом
WITH ("а́кә-заа-ра") + Neg
  IF (2 Noun + Encl:гьы)
     (1 Comma)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ACL (*) ;
};

# Verb arguments

SET SgNoun = Noun - Pl - POSTP | Noun - Hum - POSTP ;

# adjacent S Noun (intrans only)

# check this
SET SArg = SgNoun | Noun + Pl | Num + NH + Card | Pron + Pers + 3Sg | VN | Adj | Pron + Neg ;

# NonHum or Pl
WITH NOPARENT SArg - ConjIPf
  IF (1 S:Ad - Adv - >XCOMP:LO)
     (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Pron + Pers + 3SgNH | Pron + Dem
  IF (1 S:Ad)
     (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Pron + Pers + 3SgM | Pron + Pers + 3SgF
  IF (1 S:3SgH)
     (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Vocative

LIST VOC = "а́-хаара" "а́-иашьа" ;

# …, сыхаара!
WITH VOC + Noun + Poss:1
  IF (-2 V)
     (-1 Comma)
     (1 ExclPoint)
     (NOT p (*)) {
  MAP >VOCATIVE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH ("а-хаҵкы́") + Noun + Poss:2
  IF (-2 V)
     (-1 Comma)
     (1 ExclPoint)
     (NOT p (*)) {
  MAP >VOCATIVE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Noun - Pred
  IF (-2* QUEST BARRIER V)
     (-1 Comma)
     (1 IntMark | Comma | Period)
     (NOT p (*)) {
  MAP >VOCATIVE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Noun - Pred
  IF (-2* VMain + AM:2 BARRIER V)
     (-1 Comma)
     (1 IntMark | Comma | Period)
     (NOT p (*)) {
  MAP >VOCATIVE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# Дад , иахьатәи ҳамш шҧоубои ? – ҳәа .
WITH Noun
  IF (2* VMain + AM:2 BARRIER V)
     (1 Comma)
     (-1 Dash | Comma)
     (NOT p (*)) {
  MAP >VOCATIVE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;



# attach both commas to vocative
WITH Comma
  IF (1 >VOCATIVE)
     (NOT p (*)) {
  MAP >PUNCT (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Comma
  IF (-1 >VOCATIVE)
     (NOT p (*)) {
  MAP >PUNCT (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# make other rules ignore vocative
REMCOHORT IGNORED WITHCHILD (*) >VOCATIVE ;

# attach both commas to appos
WITH Comma
  IF (1 >APPOS)
     (NOT p (*)) {
  MAP >PUNCT (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Comma
  IF (-1 >APPOS)
     (NOT p (*)) {
  MAP >PUNCT (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

REMCOHORT IGNORED WITHCHILD (*) >APPOS ;

# relativized postp

# зда ҳхәарҭам ача
WITH NOPARENT PP + Poss:Rel
  IF (1 NonFin - Abs - Rel - QUEST)
     (NOT p (*)) {
   MAP >ADVMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;
  

# adjacent DO and S Noun

WITH NOPARENT Pron + Pers + 3Sg | SgNoun - Pred |
              Adj - Pred |
              Num + Card | # акгьы
              Pron + Quant | # зегьы
              Pron + Int
  IF (1 DO:Ad)
     (NEGATE c >CASE)
     (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Pron + Pers + 3Sg | SgNoun - Pred
  IF (1 VN + Tr)
     (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Rel
  IF (1 S:Ad + S:3)
     (NOT p (*)) {
   MAP >CSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Rel
  IF (1 DO:Ad + DO:3)
     (NOT p (*)) {
   MAP >CCOMP:OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Pron + Pers + 3Sg | SgNoun - Pred
  IF (1w LO:NonHum3Sg LINK NONE c >OBJ:LO)
     (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Purposive clause

SET PurpVerbs = ("а-ҭах-ра́") | ("а-ҿы́-заа-ра") | ("а́кә-заа-ра")
    | ("а́-ла·га-ра") | ("а́-ӡба-ра") | ("а́-л·ша-ра") | ("а́-ҟа-заа-ра") | ("а́-қә·к-ра")
    | ("а́-г-заа-ра") | ("а-ҭах·ха-ра́") | ("а-ҽ·а·з·к-ра́") | ("а́-шьҭа-заа-ра")
    | ("аа-ра́") | ("аа́и-ра") | ("а́-д·ҵа-ра") | ("а́-ҳәа-ра") | ("а-ҳәа-ра́")
    | ("а-ца-ра́") | ("а-ша-ра́") | ("а́-г·ха-ра") | ("а́·ҳәа-ра") | ("а-ҿы́на·ха-ра")
    | ("а́бжьа·га-ра") | ("а-у-ра́") | ("а-не́и-ра") ;

# try to distinguish between object markers that cross-reference the purp!

# first try to attach to verbs that normally can have a Purp CCOMP
WITH NOPARENT Purp
     IF (1*w PurpVerbs LINK NEGATE c >OBJ:LO)
        (NOT p (*)) {
   MAP >CCOMP:PURP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Purp
     IF (-1*w PurpVerbs LINK NONE c >OBJ:LO)
        (NOT p (*)) {
   MAP >CCOMP:PURP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# сгәы иҭоуп
WITH NOPARENT Purp | VN
     IF (1*w ("а-ҭа́-заа-ра") LINK -1 ("а-гәы́"))
        (NOT p (*)) {
   MAP >CSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Purp | VN
     IF (-1*w ("а-ҭа́-заа-ра") LINK -1 ("а-гәы́"))
        (NOT p (*)) {
   MAP >CSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# then attach to other verbs
WITH NOPARENT Purp
     IF (1*w VMain BARRIER Comma)
        (NOT p (*)) {
   MAP >CCOMP:PURP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Purp
     IF (-1*w VMain BARRIER Comma)
        (NOT p (*)) {
   MAP >CCOMP:PURP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;


# attach noun to verb

# rel. verbform as arg
#SETPARENT V + Rel
#        IF (NEGATE p (*))
#        TO (1* VERB + AM:3SgNH BARRIER CLB) ;

SETPARENT VN
        IF (NEGATE p (*))
        TO (1* ("а-ҟәы́·ҵ-ра") BARRIER CLBc) ;

# ??
WITH Noun + NH
  IF (1*w Poss:3SgNH - PP BARRIER V | Noun | CLBc) # LINK NOT c >CASE OR >NMOD:POSS)
     (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Noun + H
  IF (1*w Poss:3SgF - PP BARRIER V | CLBc) # LINK NOT c >CASE) # OR >NMOD:POSS)
     (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

MAP >IOBJ TARGET VN
    IF (NEGATE 0 RELS)
       (p ("а-ҟәы́·ҵ-ра")) ;

# иаҳа бзиа
WITH NOPARENT ("иаҳа́") | ("еиҳа́")
   IF (1 VERB | Adj | Adv)
      (NOT p (*)) {
   MAP >ADVMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH ("џьара́")
  IF (-1 ("наҟ") | ("абра́")) # or other local adverbs
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ADVMOD (*) ;
} ;
     

# Adj + Emph is prelim.
WITH NOPARENT Adv OR Adj + Emph
   IF (1* VERB | VN # was - Rel; not sure about Rel, cannot be easily decided
       BARRIER CLBc)
      (NOT p (*)) {
   MAP >ADVMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Adv
  IF (-1* VERB OR VN BARRIER CLBc)
     (NOT p (*)) {
   MAP >ADVMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# аҭакс исҳәеит
WITH NOPARENT Advb # - Det
  IF (1* VERB OR VN BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Advb # - Det
  IF (-1* VERB OR VN BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

#WITH NOPARENT Advb + Sg - Det IF (1* VERB OR VN BARRIER CLBc) (NEGATE p (*)) {
#   MAP >ADVMOD (*) ;
#   SETPARENT (*) TO (jC1 (*)) ;
#} ;

#WITH NOPARENT Advb + Sg - Det IF (-1* VERB OR VN BARRIER CLBc) (NEGATE p (*)) {
#   MAP >ADVMOD (*) ;
#   SETPARENT (*) TO (jC1 (*)) ;
#} ;

WITH NOPARENT Adv OR Adj + Emph
   IF (1 Comma LINK 1* VERB OR VN BARRIER CLBc)
      (NOT p (*)) {
   MAP >ADVMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Adv
   IF (1* VERB)
      (NOT p (*)) {
   MAP >ADVMOD (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;


# nonhum argument

# first try to attach to right adjacent

# Intr
WITH NOPARENT N - Hum - Pl | N + Pl | Pron + Pers + 3Sg
     IF (1w S:3 + S:Ad LINK NONE c >NSUBJ)
        (NOT c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
} ;

# Tr
WITH NOPARENT N - Hum - Pl | Pron + Pers + 3Sg
     IF (1w S:3SgNH - DO:Ad LINK NONE c >NSUBJ)
        (NOT c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
} ;

# Copula
# егьи амшә акәын
WITH NOPARENT N - Hum - Pl      # subject
     | Pron + Pers + 3Sg | Pron + NH | Pron + Dem + Sg
     IF (2 IO:3SgNH + Cop)       # copula
        (1 Noun - EPOSTP)       # predicative
        (NEGATE 2 (*) LINK c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
} ;

LIST PlNoun = "а́-жәлар" ;

# exclude copula, because there word order should be S Pred Cop?
# Ацәқәа икеицоз иара шракәыз издыруамызт
WITH NOPARENT N + Pl | Pron + Pers + 3Pl | PlNoun
     IF (1w S:3Pl LINK NONE c >NSUBJ)
        (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Урҭқәа гәанаҭеит Абгахәыҷы
WITH NOPARENT N - Hum | Pron + Dem | Pron + Indef
     IF (1 DO:3)
        (1 DO:Ad)
        (NONE c >OBJ)
        (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N - Hum - Pl
     IF (1 RO:3SgNH)
        (1 (*) LINK NONE c >OBJ:RO)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >OBJ:RO (*) ;
} ;

WITH NOPARENT N - Hum - Pl | Pron + Pers + 3SgNH | Pron + Pers + 3Sg |
     Num + NH # акы́
     IF (1w IO:3SgNH LINK NONE c >IOBJ)
        (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# hum argument

WITH NOPARENT N + Hum - Pl - F | Pron + Pers + 3SgM | Pron + H
     IF (1w S:3SgM LINK NONE c >NSUBJ)
        (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl + F | Pron + Pers + 3SgF
     IF (1w S:3SgF LINK NONE c >NSUBJ)
        (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgF | Pron + Pers + 3SgM | Pron + H
     IF (1w DO:3SgH LINK NONE c >OBJ)
        (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl - F | Pron + Pers + 3SgM | Pron + H
     IF (1w IO:3SgM + ("а́кә-заа-ра") LINK NONE c >IOBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >XCOMP (*) ;
} ;

WITH NOPARENT N + Hum - Pl - F | Pron + Pers + 3SgM | Pron + H
     IF (1w IO:3SgM LINK NONE c >IOBJ)
        (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl + F | Pron + Pers + 3SgF
     IF (1w IO:3SgF LINK NONE c >IOBJ)
        (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl - F | Pron + Pers + 3SgM | Pron + H
     IF (1w RO:3SgM LINK NONE c >OBJ:RO)
        (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl + F | Pron + Pers + 3SgF
     IF (1w RO:3SgF LINK NONE c >OBJ:RO)
        (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl - F | Pron + Pers + 3SgM | Pron + H
     IF (1w LO:3SgM LINK NONE c >OBJ:LO)
        (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl + F | Pron + Pers + 3SgF
     IF (1w LO:3SgF LINK NONE c >OBJ:LO)
        (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N - Hum - Pl | Rel - QUEST
     IF (1w LO:NonHum3Sg LINK NONE c >OBJ:LO)
        (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl - F | Pron + Pers + 3SgM | Pron + Pers + 3Sg | Pron + H
     IF (1w PO:3SgM LINK NONE c >OBJ:PO)
        (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl + F | Pron + Pers + 3SgF | Pron + Pers + 3Sg
     IF (1w PO:3SgF LINK NONE c >OBJ:PO)
        (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N - Hum - Pl - PP - Advb
  IF (1w PO:3SgNH LINK NONE c >OBJ:PO)
     (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Pl - PP - Advb | NumPfx - PP - Advb
  IF (1w PO:3Pl LINK NONE c >OBJ:PO)
     (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT VN
  IF (1* ("а-ца-ра́") BARRIER CLB OR V)
     (NOT p (*)) {
   MAP >XCOMP (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

SECTION

WITH ("ҳәа́") + Quote
  IF (-1 V OR Noun)
     (1 ("акгьы́") + Pron + Neg)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >MARK (*) ;     
} ;

# мал ҳәа акгьы имамызт
WITH Noun
  IF (2 ("акгьы́") + Pron + Neg)
     (c Quote + >MARK)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NMOD (*) ;     
} ;

# ??
WITH V
  IF (2 ("акгьы́") + Pron + Neg)
     (c Quote + >MARK)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ADVMOD (*) ;     
} ;

# 1/2 Pron + S

# prelim
WITH Pron + Pers + 1Sg
  IF (1* VERB + Cop + IO:1Sg BARRIER CLBc)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >XCOMP (*) IF (p (*)) ;
} ;

WITH Pron + Pers + 1Sg
  IF (1* VERB + S:1Sg BARRIER CLBc)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
} ;

WITH Pron + Pers + 2SgM
  IF (1* VERB + S:2SgM BARRIER CLBc)
     (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2Sg
  IF (1* Impv + S:2Sg BARRIER CLBc)
     (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgF
  IF (1* VERB + S:2SgF BARRIER CLBc)
     (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 1Pl
  IF (1* VERB + S:1Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2Pl
  IF (1* VERB + S:2Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Pron + DO

WITH Pron + Pers + 1Sg
  IF (1* VERB + DO:1Sg BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgM
  IF (1* VERB + DO:2SgM BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgF
  IF (1* VERB + DO:2SgF BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 1Pl
  IF (1* VERB + DO:1Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2Pl
  IF (1* VERB + DO:2Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Pron + IO

WITH Pron + Pers + 1Sg
  IF (1* VERB + IO:1Sg BARRIER CLBc)
     (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgM
  IF (1* VERB + IO:2SgM BARRIER CLBc)
     (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgF
  IF (1* VERB + IO:2SgF BARRIER CLBc)
     (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 1Pl
  IF (1* VERB + IO:1Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2Pl
  IF (1* VERB + IO:2Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Pron + LO

WITH Pron + Pers + 1Sg
  IF (1* VERB + LO:1Sg BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgM
  IF (1* VERB + LO:2SgM BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgF
  IF (1* VERB + LO:2SgF BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 1Pl
  IF (1* VERB + LO:1Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2Pl
  IF (1* VERB + LO:2Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Pron + RO

WITH Pron + Pers + 1Sg
  IF (1* VERB + RO:1Sg BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgM
  IF (1* VERB + RO:2SgM BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgF
  IF (1* VERB + RO:2SgF BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 1Pl
  IF (1* VERB + RO:1Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2Pl
  IF (1* VERB + RO:2Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Pron + PO

WITH Pron + Pers + 1Sg
  IF (1* VERB + PO:1Sg BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgM
  IF (1* VERB + PO:2SgM BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2SgF
  IF (1* VERB + PO:2SgF BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 1Pl
  IF (1* VERB + PO:1Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Pron + Pers + 2Pl
  IF (1* VERB + PO:2Pl BARRIER CLBc)
     (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;


# rel + Cop is cleft
#WITH Rel - QUEST
#     IF (1**w Cop BARRIER BOP LINK NONE c >CCOMP:RELCL)
#        (NOT p (*)) {
#   MAP >CCOMP:RELCL (*) ;
#   SETPARENT (*) TO (jC1 (*)) ;
#} ;

# either trans. S (or Cop),…
WITH N - H - Pl - Coord | Rel - QUEST | Pron + Pers + 3Sg | VN
     IF (1**w S:3SgNH - Abs BARRIER BOP LINK NONE c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*));
} ;

WITH NOPARENT Rel - QUEST
   IF (-1* Noun BARRIER CLBc | V | Cop)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ACL:RELCL (*) IF (p (*)) ;
};

WITH N + H - Pl - Coord | Pron + Pers + 3SgM | Pron + Pers + 3Sg | Prop + Anthr + M | Adj
     IF (1**w S:3SgM - Abs BARRIER BOP LINK NONE c >NSUBJ)
        (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# somehow add fem nouns; those need morph tag
WITH Pron + Pers + 3SgF | Pron + Pers + 3Sg | Prop + Anthr + F
     IF (1**w S:3SgF - Abs BARRIER BOP LINK NONE c >NSUBJ)
        (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# or non-adjacent intr. S
WITH N - H - Pl | N + Pl | Rel - QUEST | Pron + Pers + 3Sg | VN | Num + Card | Pron + Quant
     IF (2**w S:3 - S:Ad - Abs BARRIER BOP LINK NONE c >NSUBJ)
        (NEGATE c >CASE)
        (NOT 1 BOP)
        (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Rel - QUEST - PP
     IF (2**w S:3 - S:Ad - Abs BARRIER BOP LINK NONE c >NSUBJ)
        (NEGATE c >CASE)
        (NOT 1 BOP)
        (NOT p (*)) {
   MAP >CSUBJ  (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Hum - Pl | Pron + Pers + 3SgM | Pron + Pers + 3SgF | Pron + Pers + 3Sg | Pron + Dem | Adj - PP
     IF (1**w S:3SgH - Abs BARRIER BOP LINK NONE c >NSUBJ)
        (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

#>
#WITH N + Pl | Pron + Quant
#     IF (1**w CopNounFin BARRIER Comma LINK 1 >COP + S:3Pl)
#        (NOT p (*)) {
#   MAP >NSUBJ (*) ;
#   SETPARENT (*) TO (jC1 (*)) ;
#} ;

WITH N + Pl | Pron + Quant | Pron + Pers + 3Pl
     IF (1**w S:3Pl - Abs BARRIER Comma LINK NONE c >NSUBJ)
        (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# DO

# @@@@
WITH NOPARENT N - H - Pl - PP - Advb | VN - PP - Advb
  IF (2**w DO:3 - DO:Ad BARRIER BOP LINK NONE c >OBJ OR >CCOMP:OBJ)
     (NOT 1 BOP)
     (NOT 1 ("ҳәа́") OR ("уҳәа́"))
     (NOT p (*)) {
  MAP >OBJ (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + NH - PP - Advb | N + Pl - PP - Advb
  IF (2**w DO:3 - DO:Ad BARRIER BOP LINK NONE c >OBJ OR >CCOMP:OBJ)
     (NOT 1 BOP)
     (NOT 1 ("ҳәа́") OR ("уҳәа́"))
     (NOT p (*)) {
  MAP >OBJ (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + H - Pl - PP - Advb
  IF (1*w DO:3SgH - DO:Ad BARRIER BOP LINK NONE c >OBJ OR >CCOMP:OBJ)
     (NOT 1 BOP)
     (NOT p (*)) {
  MAP >OBJ (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# LO

WITH NOPARENT N - H - Pl - PP - Advb
  IF (1**w LO:NonHum3Sg BARRIER BOP LINK NONE c >OBJ:LO)
     (NOT p (*)) {
  MAP >OBJ:LO (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Rel - QUEST - PP - Advb
  IF (1**w LO:NonHum3Sg BARRIER BOP LINK NONE c >OBJ:LO)
     (NOT p (*)) {
  MAP >CCOMP:LO (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + H - PP - Advb
  IF (1**w LO:3SgM BARRIER BOP LINK NONE c >OBJ:LO)
     (NOT p (*)) {
  MAP >OBJ:LO (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + H | Prop + F
  IF (1**w LO:3SgF BARRIER BOP LINK NONE c >OBJ:LO)
     (NOT p (*)) {
  MAP >OBJ:LO (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Pl | N + Coord | PlNoun - PP
  IF (1**w LO:3Pl BARRIER BOP LINK NONE c >OBJ:LO)
     (NOT p (*)) {
  MAP >OBJ:LO (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;


# RO

WITH NOPARENT N + H
  IF (1**w RO:3SgM BARRIER BOP LINK NONE c >OBJ:RO)
     (NOT p (*)) {
  MAP >OBJ:RO (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# IO

WITH NOPARENT N - Hum - Pl | Pron + Pers + 3SgNH | Pron + Pers + 3Sg
  IF (1**w IO:3SgNH BARRIER BOP LINK NONE c >IOBJ)
     (NOT p (*)) {
  MAP >IOBJ (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Pl | N + Coord | Pron + Quant
  IF (1**w IO:3Pl + Cop BARRIER Comma LINK NONE c >XCOMP)
     (NOT p (*)) {
  MAP >XCOMP (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Pl | N + Coord | Pron + Quant
  IF (1**w IO:3Pl BARRIER Comma LINK NONE c >IOBJ)
     (NOT p (*)) {
  MAP >IOBJ (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N - Hum - Pl | Pron + Pers + 3SgNH | Pron + Pers + 3Sg
  IF (1**w RO:3SgNH BARRIER BOP LINK NONE c >OBJ:RO)
     (NOT p (*)) {
  MAP >OBJ:RO (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# Зегьы срыцәшәо адунеи сануп.
WITH NOPARENT N + Pl | N + Coord | ("зегьы́")
  IF (1**w RO:3Pl BARRIER Comma LINK NONE c >OBJ:RO)
     (NOT p (*)) {
  MAP >OBJ:RO (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N + Hum - Pl | Pron + Pers + 3Sg - PP
  IF (1**w IO:3SgM BARRIER Comma OR Colon LINK NONE c >IOBJ)
     (NEGATE c >CASE)
     (NOT p (*)) {
  MAP >IOBJ (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT N - Hum - Pl | Pron + Pers + 3SgM | Pron + Pers + 3Sg | Anthr + M | Adj - PP
  IF (1**w Poss:3SgM + V BARRIER BOP LINK NONE c >OBJ:POSS)
     (NOT p (*)) {
  MAP >OBJ:POSS (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;




# hum argument

#SETPARENT N + Hum - Pl
#	IF (NEGATE p (*))
#	TO (1* AM:Hum3Sg ) ;

WITH NOPARENT Pron + Pers + 3Pl | N + Pl | N + Coord
   IF (1* Poss:3Pl - PP BARRIER V | CLBc)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# Rel argument
WITH NOPARENT Rel - QUEST - PP
   IF (1* S:3 BARRIER CLBc)
      (NOT p (*)) {
   MAP >CSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Rel - QUEST - PP
   IF (1* S:3SgM BARRIER CLBc)
      (NOT p (*)) {
   MAP >CSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Rel - QUEST - PP
   IF (2*w DO:3 - DO:Ad BARRIER CLBc LINK NOT c >OBJ)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CCOMP:OBJ (*) ;
};

WITH NOPARENT Rel - QUEST - PP
   IF (1* RO:3SgNH BARRIER CLBc)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CCOMP:RO (*) ;
};

WITH N
  IF (1* Cop BARRIER CLBc)
     (NOT p (*)) {
  MAP >XCOMP (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# …

#WITH NOPARENT Rel - QUEST
#   IF (1* AM:NonHum3Sg BARRIER CLBc)
#      (NOT p (*)) {
#   MAP >ACL:RELCL (*) ;
#   SETPARENT (*) TO (jC1 (*)) ;
#};

# attach nonfinite verb with relative dependent to following noun
# зда ҳхәарҭам ача
WITH NOPARENT NonFin - Abs - Rel - QUEST
   IF (1* Noun BARRIER CLBc)
      (c >ADVMOD + Poss:Rel)
      (NOT p (*)) {
   MAP >ACL:RELCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT NonFin - Abs - Rel - QUEST
   IF (-1* Comma BARRIER V LINK -1* Noun BARRIER CLBc | V)
      (c >NSUBJ + Poss:Rel) # extend to other rels
      (NOT p (*)) {
   MAP >ACL:RELCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};


WITH NOPARENT Rel - QUEST
   IF (-1 Cop)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CSUBJ (*) ;
};

WITH NOPARENT Rel - QUEST
   IF (-1 AM:NonHum3Sg)
      (NOT p (*)) {
   MAP >ACL:RELCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};


# Poss
WITH NOPARENT Pron + Pers + 1Sg
   IF (1 Poss:1Sg - PP)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgM
   IF (1 Poss:2SgM - PP)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgF
   IF (1 Poss:2SgF - PP)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 1Pl
   IF (1 Poss:1Pl - PP)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2Pl
   IF (1 Poss:2Pl - PP)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 3SgM
   IF (1 Poss:3SgM - PP)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 3SgF
   IF (1 Poss:3SgF - PP)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 3Pl
   IF (1 Poss:3Pl - PP)
      (NOT p (*)) {
   MAP >NMOD:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};


## arg following V

# 1/2 Pers S

WITH NOPARENT Pron + Pers + 1Sg
   IF (-1*w S:1Sg OR Cop BARRIER Comma LINK NONE c >NSUBJ)
      (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgM
   IF (-1*w S:2SgM OR Cop BARRIER Comma LINK NONE c >NSUBJ)
      (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgF
   IF (-1*w S:2SgF BARRIER Comma LINK NONE c >NSUBJ)
      (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 1Pl
   IF (-1*w S:1Pl BARRIER Comma | V | Pred LINK NONE c >NSUBJ)
      (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# шәҽаанышәкыл шәҩыџьагьы!
WITH NOPARENT Pron + Pers + 2Pl | Num + H + Card + Poss:2Pl
   IF (-1*w S:2Pl BARRIER Comma LINK NONE c >NSUBJ)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
};

# 1/2 Pers DO

WITH NOPARENT Pron + Pers + 1Sg
   IF (-1*w DO:1Sg BARRIER Comma LINK NONE c >OBJ)
      (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgM
   IF (-1*w DO:2SgM BARRIER Comma LINK NONE c >OBJ)
      (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgF
   IF (-1*w DO:2SgF BARRIER Comma LINK NONE c >OBJ)
      (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 1Pl
   IF (-1*w DO:1Pl BARRIER Comma LINK NONE c >OBJ)
      (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2Pl
   IF (-1*w DO:2Pl BARRIER Comma LINK NONE c >OBJ)
      (NOT p (*)) {
   MAP >OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# 1/2 Pers IO

WITH NOPARENT Pron + Pers + 1Sg
   IF (-1*w IO:1Sg BARRIER Comma LINK NONE c >IOBJ)
      (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgM
   IF (-1*w IO:2SgM BARRIER Comma LINK NONE c >IOBJ)
      (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgF
   IF (-1*w IO:2SgF BARRIER Comma LINK NONE c >IOBJ)
      (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 1Pl
   IF (-1*w IO:1Pl BARRIER Comma LINK NONE c >IOBJ)
      (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2Pl
   IF (-1*w IO:2Pl BARRIER Comma LINK NONE c >IOBJ)
      (NOT p (*)) {
   MAP >IOBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# 1/2 Pers LO

WITH NOPARENT Pron + Pers + 1Sg
   IF (-1*w LO:1Sg BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgM
   IF (-1*w LO:2SgM BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgF
   IF (-1*w LO:2SgF BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 1Pl
   IF (-1*w LO:1Pl BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2Pl
   IF (-1*w LO:2Pl BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# 1/2 Pers RO

WITH NOPARENT Pron + Pers + 1Sg
   IF (-1*w RO:1Sg BARRIER Comma LINK NONE c >OBJ:RO)
      (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgM
   IF (-1*w RO:2SgM BARRIER Comma LINK NONE c >OBJ:RO)
      (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgF
   IF (-1*w RO:2SgF BARRIER Comma LINK NONE c >OBJ:RO)
      (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 1Pl
   IF (-1*w RO:1Pl BARRIER Comma LINK NONE c >OBJ:RO)
      (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2Pl
   IF (-1*w RO:2Pl BARRIER Comma LINK NONE c >OBJ:RO)
      (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# 1/2 Pers PO

WITH NOPARENT Pron + Pers + 1Sg
   IF (-1*w PO:1Sg BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgM
   IF (-1*w PO:2SgM BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2SgF
   IF (-1*w PO:2SgF BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 1Pl
   IF (-1*w PO:1Pl BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Pron + Pers + 2Pl
   IF (-1*w PO:2Pl BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};


WITH NOPARENT Rel - QUEST
   IF (-1*w S:NonHum3Sg - S:Ad BARRIER Comma | Colon LINK NONE c >NSUBJ)
      (NEGATE c >CASE) # obs: not NOT!
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CSUBJ (*) ;
};

WITH NOPARENT N - Hum - Pl | Rel - QUEST | Pron + Pers + 3SgNH | Pron + Pers + 3Sg
   IF (-1*w S:NonHum3Sg - S:Ad BARRIER Comma | Colon LINK NONE c >NSUBJ)
      (NEGATE c >CASE) # obs: not NOT!
      (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N + Hum - Pl | Prop + Anthr - PP
   IF (-1*w S:3SgH BARRIER Comma LINK NONE c >NSUBJ)
      (NEGATE c >CASE) # obs: not NOT!
      (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# уи ихьӡын Иоанн; S:3 agrees with the name, in this construction: C1 is C2’s name, see Yan.
WITH NOPARENT Prop + Anthr - PP
   IF (-1*w ("а́-хьӡ-заа-ра") + S:3 - S:Ad BARRIER Comma LINK NONE c >NSUBJ)
      (NEGATE c >CASE) # obs: not NOT!
      (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# S:Rel: a S:Rel is more likely to be Hum; should be made dependent on verb
# Мшыбзиа! – иҳәеит инеиз. (Not sure if this is Rel)
WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgM | S:Rel
   IF (-1*w S:3SgM BARRIER Comma LINK NONE c >NSUBJ)
      (NEGATE c >CASE) # more rules need this!
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) ;
};

WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgF | S:Rel
   IF (-1*w S:3SgF BARRIER Comma LINK NONE c >NSUBJ)
      (NEGATE c >CASE) # more rules need this!
      (NOT p (*)) {
   MAP >NSUBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

LIST S:Pl = S:3 S:3Pl ;

WITH NOPARENT N + Pl | Pron + Pers + 3Pl | N + Coord
   IF (-1*w S:Pl - S:Ad BARRIER Comma | Colon LINK NONE c >NSUBJ)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) ;
};

WITH  NOPARENT N - Hum - Pl | N + Pl | Rel - QUEST | Pron + Pers + 3SgNH
   IF (-1*w DO:3 - DO:Ad BARRIER Comma | Colon LINK NONE c >OBJ)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >OBJ (*) IF (p (*));
};

WITH NOPARENT N - Hum - Pl | Pron + Pers + 3SgNH
   IF (-1*w IO:3SgNH BARRIER BOP LINK NONE c >IOBJ)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >IOBJ (*) ;
};

WITH NOPARENT N - Hum - Pl | Pron + Pers + 3SgNH
   IF (-1*w RO:3SgNH BARRIER Comma LINK NONE c >OBJ:RO)
      (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# Аха ҳаицәыхьча аҩсҭаа
WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgM
   IF (-1*w RO:3SgM BARRIER Comma LINK NONE c >OBJ:RO)
      (NOT p (*)) {
   MAP >OBJ:RO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgM
   IF (-1*w LO:3SgM BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgF | Prop + F
   IF (-1*w LO:3SgF BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N - Hum - Pl | Pron + Pers + 3SgNH
   IF (-1*w LO:NonHum3Sg BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N + Pl | Pron + Pers + 3Pl
   IF (-1*w LO:3Pl BARRIER Comma LINK NONE c >OBJ:LO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgM
   IF (-1*w PO:3SgM BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgF
   IF (-1*w PO:3SgF BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:LO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N - Hum - Pl | Pron + Pers + 3SgNH
   IF (-1*w PO:3SgNH BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N + Pl | Pron + Pers + 3Pl
   IF (-1*w PO:3Pl BARRIER Comma LINK NONE c >OBJ:PO)
      (NOT p (*)) {
   MAP >OBJ:PO (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT N + Hum - Pl | Pron + Pers + 3SgM
   IF (-1*w VERB + Poss:3SgM BARRIER Comma LINK NONE c >OBJ:POSS)
      (NOT p (*)) {
   MAP >OBJ:POSS (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};


# more of those
MAP >DET TARGET Pron + Pers + 2SgM
    IF (p Noun + Poss:2SgM) ;

MAP >PREDLINK TARGET Rel
    IF (p ("а́-кә-заа-ра")) ;

MAP >OBJ TARGET Noun
    IF (p DO:Ad)
       (1 DO:Ad) ;


# no Comma barrier

# more of them
WITH N + Hum - Pl | Rel - QUEST
     IF (1**w S:3SgH - Abs BARRIER Punct - Comma LINK NONE c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
} ;

WITH N - Hum - Pl | N + Pl | Pron + Pers + 3Pl
     IF (2**w S:3 - S:Ad - Abs BARRIER Punct - Comma LINK NONE c >NSUBJ OR >CSUBJ)
        (NOT c ("зны") + >ADVMOD)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
} ;

WITH Rel - QUEST - PP
     IF (2**w S:3 - S:Ad - Abs BARRIER Punct - Comma LINK NONE c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CSUBJ (*) IF (p (*)) ;
} ;

WITH N - Hum - Pl | Pron + Dem
     IF (1**w S:3SgNH - S:Ad - Abs BARRIER Punct - Comma LINK NONE c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
} ;

WITH Rel - QUEST
     IF (1**w S:3SgNH - S:Ad - Abs BARRIER Punct - Comma LINK NONE c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CSUBJ (*) IF (p (*)) ;
} ;


# Даннеи , уигьы « бзиала уаабеит » ҳәа наиаҳәаны , амцаҿы диртәеит . 

WITH N + Hum - Pl | Pron + Dem
     IF (1**w DO:3SgH - Abs BARRIER Punct - Comma LINK NONE c >OBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >OBJ (*) IF (p (*)) ;
} ;

WITH N + Hum - Pl | Pron + Dem
     IF (1**w S:3SgM - Abs BARRIER Punct - Comma LINK NONE c >NSUBJ)
        (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) IF (p (*)) ;
} ;


WITH EPOSTP
  IF (1* V)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >ADVMOD (*) ;
} ;

# specify verbs that can take a place obl
# Аҧсны дынхон Базала зыхьӡыз нхаҩык.
WITH Place
  IF (0* V - Abs)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >OBL (*) IF (p (*)) ;
} ;

# Жәамш – Италиа жәҩан аҵаҟа; not sure
WITH ("а́-мш") + NumPfx
     IF (1**w V | Noun LINK NOT p (*))
        (NOT p (*)) {
     MAP >ADVMOD (*) ;
     SETPARENT (*) TO (jC1 (*)) ;
} ;

SET SubjCompV = ("аҳа-ра́") ; # and more

SETPARENT V + How
	IF (NEGATE p (*))
	TO (-1* SubjCompV + S:3) ;

# ??
MAP >COMP TARGET V + How
    IF (p SubjCompV + S:3) ;

# H Sg referenced by S:3

# … аҳәара иаҿын ажьақәа реиҳабы
WITH NOPARENT H + Sg
   IF (-1*w S:3 - S:Ad BARRIER Comma | Colon LINK NONE c >NSUBJ)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) ;
};



SECTION



LIST LQuote = "<“>" "<«>" ;
LIST RQuote = "<”>" "<»>" ;

#WITH LQuote
#     IF (1 (*) LINK pp VMain BARRIER RQuote)
#        (NOT p (*)) {
#     SETPARENT (*) TO (jC1 (*)) ;
#     MAP >PUNCT (*) ;
#} ;


WITH Dash
     IF (-1 (*) - BOS) # LINK -1* VMain)
        (NOT -1 Colon)
        (NOT p (*)) {
     SETPARENT (*) TO (jC1 (*)) ;
     MAP >PUNCT (*) IF (p (*)) ;
} ;

# V » – ҳәа # doesnt work! « » is parenthesis!
WITH Dash
     IF (-1 Quote + Right)
        (-2 (*))
        (NOT p (*)) {
     SETPARENT (*) TO (jC1 (*)) ;
     MAP >PUNCT (*) IF (p (*)) ;
} ;

WITH Dash
     IF (1 (*) - ("ҳәа́"))
        (-1 BOS OR Colon)
        (NOT p (*)) {
     SETPARENT (*) TO (jC1 (*)) ;
     MAP >PUNCT (*) IF (p (*)) ;
} ;

WITH LQuote # | Dash
     IF (1 (*))
        (NOT p (*)) {
     MAP >PUNCT (*) ;
     SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH RQuote | Quote - Prt
     IF (-1 (*)) (NOT p (*)) {
     MAP >PUNCT (*) ;
     SETPARENT (*) TO (jC1 (*)) ;
} ;

SECTION

# relaxed rules

WITH NOPARENT N
   IF (-1*w S:3SgNH BARRIER Comma | Colon LINK NONE c >NSUBJ)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NSUBJ (*) ;
} ;

WITH ("ҳәа́") + Quote
  IF (-1* VMain)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >MARK (*) ;
} ;

# if no verb found try something else (extend!)
WITH ("ҳәа́") + Quote
  IF (-1* Pred)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >MARK (*) ;
} ;

# this must in a section without PARENTHESES! remove same rules below!

WITH VMain
  IF (1* RQuote LINK 1w ("ҳәа́"))
     (NOT p (*)) {
  SETCHILD  (*) TO (jC1 (*)) ;
} ;

# V » – ҳәа
WITH VMain
  IF (1* RQuote LINK 1w Dash)
     (NOT p (*)) {
  SETCHILD  (*) TO (jC1 (*)) ;
} ;

MAP >PUNCT Dash ;

# V » – ҳәа
WITH VMain
  IF (1* RQuote LINK 1 Dash LINK 1w ("ҳәа́"))
     (NOT p (*)) {
  SETCHILD  (*) TO (jC1 (*)) ;
} ;

MAP >MARK ("ҳәа́") ;



SECTION

# Уахьыржьо сгәы иалоуп
WITH NOPARENT Where
  IF (1*w ("а́-ла-заа-ра") + S:3 LINK c ("а-гәы́") + >OBJ:LO)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CSUBJ (*) ;
};

WITH NOPARENT Where
  IF (1 Noun)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# сҿамҳандаз ҳәа икылҧш-кылӡырҩуа
WITH NOPARENT Opt
  IF (1 ("ҳәа́") LINK 1* VMain)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

WITH NOPARENT Conj-I | Conj-II
  IF (1 ("а́-ҟа·ла-ра") + S:Ad)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CSUBJ (*) ;
};


# атәы + VSaying
WITH (*)
  IF (1 ("а-тәы́") + PP + Poss:3SgNH LINK 1 VSaying)
     (NOT p (*)) {
  MAP >CCOMP:QUOTE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH VMain
  IF (1* RQuote LINK 1 ("ҳәа́") LINK 1* VSaying)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) ;
} ;

# attach conjunctional verb to adjacent verb

# either as CCOMP
WITH NOPARENT CONJIPF
  IF (1 V + DO:Ad)
     (NOT p (*)) {
   MAP >CCOMP:OBJ (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# more of those…

# or as ADVCL, if not argument
WITH NOPARENT CONJIPF
  IF (1 V - Abs)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT AsIf
  IF (1 V - Abs)
     (NOT p (*)) {
   MAP >ADVCL:COMPAR (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# attach conjunctional verb to next main verb

# Ус ишнеиуаз ҳәыгәрак инықәгылеит.
WITH NOPARENT CONJIPF
  IF (1* VMain BARRIER V) # | CLBc)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# otherwise, might also attach to Abs

WITH NOPARENT CONJIPF
  IF (1* V BARRIER CLBc)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT How - Q
  IF (-1*w ("а-ҳәа-ра́") - Abs LINK NOT c >OBJ) # more verbs of saying?
     (NOT p (*)) {
   MAP >CCOMP:QUOTE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT CONJIPF
  IF (-1* V - Abs BARRIER CLB OR Comma)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# or with comma

WITH NOPARENT CONJIPF
  IF (1* Comma OR Dash LINK 1* VMain - VSaying)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# Аҵысҕра ахьынаҧшуаз иаагәанаҭеит, шәарыцаҩык ила иманы дшааиуаз.
# or to preceding verb
WITH NOPARENT CONJIPF
  IF (-1* VMain BARRIER V - Abs)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};

# ??
WITH NOPARENT Abs
  IF (1 Abs - Connect | Cop BARRIER Connect | Comma)
     (NOT p (*)) {
   MAP >ADVCL:CONV (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

#WITH NOPARENT Abs
#  IF (1* VMain - Abs - Connect | Cop BARRIER Connect) #  - PastIndef)
#     (NOT p (*)) {
#   MAP >ADVCL:CONV (*) ;
#   SETPARENT (*) TO (jC1 (*)) ;
#} ;

# иаахҿаны амхы ласҵар,
WITH NOPARENT Abs
  IF (1* V - Abs - Rel - Connect BARRIER CLB | Connect)
     (NOT p (*)) {
   MAP >ADVCL:CONV (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT V + Rel
  IF (1*w VERB + IO:3SgNH BARRIER CLB LINK NONE c >IOBJ)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >CCOMP:IOBJ (*) ;
} ;

WITH NOPARENT Interj
  IF (0* VSaying)
     (NEGATE p (*)) {
   MAP >CCOMP:QUOTE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Interj
  IF (0* VERB)
     (NEGATE p (*)) {
   MAP >DISCOURSE (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

# Discourse particle шҧа

WITH ("шҧа́")
  IF (-1 (*))
     (NOT p (*)) {
  MAP >DISCOURSE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT TempNoun
   IF (1* VERB OR VN BARRIER CLBc)
      (NOT p (*)) {
   MAP >OBL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT ("а́-шқәс")
   IF (1* VerbVN - >XCOMP:LO BARRIER CLB)
      (c ("зны") + >ADVMOD)
      (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >OBL (*) ;
} ;


WITH NOPARENT Cj + Coord | Cj + Sub
  IF (1* VMain)
     (NOT p (*)) {
   MAP >CC (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH NOPARENT Abs
  IF (-1* V - Abs - NonFin - Rel - ConjIPf BARRIER CLB)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >ADVCL:CONV (*) IF (p (*)) ;
} ;

WITH Comma
  IF (-1 (*))
     (NOT p (*)) {
  MAP >PUNCT (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Punct - Comma - Dash
  IF (-1* VMain) #> - Cop | Cop - V | CopNounFin)
     (NOT p (*)) {
  MAP >PUNCT (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# if there is no VMain
WITH Punct - Comma - Dash
  IF (-1* Interj | N | V) # add more
     (NOT p (*)) {
  MAP >PUNCT (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;


SETPARENT IntMark IF (NEGATE p (*)) TO (-1 Pron + Int) ;

# conditional phrase
WITH Conj-I OR Conj-II
  IF (1*  VMain - VSaying)
     (NOT p (*)) {
  MAP >ADVCL:COND (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

WITH Conj-I OR Conj-II
  IF (-1*  VMain - VSaying)
     (NOT p (*)) {
  MAP >ADVCL:COND (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# cleft sentence
# Cop (Focus) + Rel (given Topic)

# Det er en semantisk subjektegenskap å være gitt i konteksten og bli tilskrevet en egenskap. (Helge)

# амла уаганы аҧсроуп иузыҧшу
# Афароуп сара сзызку
WITH Rel - Q
  IF (-1* Cop BARRIER Comma) # | V)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CSUBJ (*) ;
} ;

# pseudo cleft sentence
# Rel + Cop (Focus)

# Изтәу сара соуп
#WITH Rel - Q
#  IF (1* Cop BARRIER CLBc | V) #> LINK p (*))
#     (NOT p (*)) {
#  MAP >CCOMP:PRED (*) ;
#  SETPARENT (*) TO (jC1 (*)) ;
#} ;

WITH N
  IF (1* Cop BARRIER CLBc | V)
     (NOT p (*)) {
  MAP >XCOMP (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;


SET DO:Ad:ҿ = DO:Ad | DO:ҿ ;

# quote phrase
WITH VERB - PastIndef
  IF (2w VSaying + DO:Ad LINK NEGATE c >OBJ OR >CCOMP:QUOTE)
     (c Prt + Quote)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) IF (p (*)) ; # was >CONJ
} ;



# syndetic coordination; tense needed?
WITH $$TENSE - VSaying - ("а́зҵаа-ра") - ("а-ҵаа-ра́") - ("а́ила·цәажәа-ра") - ("а́а·ҧхьа-ра")
         - ("а́-ла·га-ра") # - COP
         - Punct - PastIndef
  IF (-1* VMain + $$TENSE - PastIndef
      BARRIER Quote + Left | Colon | Semicolon) # don’t go out of quote
     (NOT -1 ("а́а·ҧхьа-ра")) # add similar verbs, type ааҧҳара даҿын
     (c >CC)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CONJ (*) IF (p (*)) ; # was >CONJ
} ;





# tr verbs of saying
WITH VMain
  IF (1** Dash OR Comma OR Quote + Right BARRIER Quote + Left OR VMain
      LINK 1w VSaying + DO:Ad LINK NEGATE c >OBJ OR >CCOMP:QUOTE)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) IF (p (*));
} ;

WITH VMain
  IF (1** Dash OR Comma OR Quote + Right BARRIER Quote + Left OR VMain
      LINK 1w VSaying + DO:ҿ LINK NEGATE c >OBJ | >CCOMP:QUOTE)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >ADVCL:QUOTE (*) IF (p (*));
} ;

# intr verbs of saying
WITH VMain
  IF (1** Dash OR Comma OR Quote + Right BARRIER Quote + Left OR VMain
      LINK 1w ("а-ҵаа-ра́") OR ("а́-быб-ра"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >ADVCL:QUOTE (*) IF (p (*));
} ;


# мап зкыз рхы хышәсала ҳәа рыдиҵеит
WITH VMain
  IF (2w VSaying + DO:Ad:ҿ LINK NEGATE c >OBJ OR >CCOMP:QUOTE)
     (1 ("ҳәа́"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) IF (p (*));
} ;

WITH VMain
  IF (1** Comma BARRIER Quote + Left | VMain
      LINK 1 Dash
      LINK 1w VSaying + DO:Ad:ҿ LINK NOT c >OBJ)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) IF (p (*));
} ;

WITH VMain
  IF (1** Punct BARRIER Quote + Left
      LINK 1 RQuote
      LINK 1w VSaying + DO:3 LINK NOT c >OBJ)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) IF (p (*));
} ;

# … иҵааит: – … Vmain

WITH VMain
  IF (-1* Dash LINK -1 Colon LINK -1* ("а-ҵаа-ра́") + Fin BARRIER CLBc | VMain)
     (NOT p (*)) {
  MAP >CCOMP:QUOTE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# Quote to the right

# Ауаагьы ирҳәоит, ауаҩы игу азы уихымччан ҳәа.
WITH VMain
  IF (-1** Comma LINK -1w VSaying + DO:3 LINK NEGATE c >OBJ | >CCOMP:QUOTE)
     (1 ("ҳәа́"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) ;
} ;

# иҳәеит: « …
WITH VMain
  IF (-1** LQuote LINK -1 Colon LINK -1w VSaying + DO:3 LINK NOT c >OBJ)
     (NEGATE 1* VMain BARRIER RQuote) # make sure only last VMain is matched
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) ;
} ;

WITH ("ҳәа́") + Quote
  IF (-1 V | Noun)
     (1 ("а́-ҧхьаӡа-ра"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >MARK (*) ;
} ;

WITH ("ҳәа́") + Quote
  IF (-1* VMain)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >MARK (*) ;
} ;


# the rest, except verb of saying, since these take (conjoined) sentence(s) as complement

# coordination of PastIndef and Aor
WITH PastIndef
  IF (1* Aor - VSaying - ("а́зҵаа-ра") - ("а-ҵаа-ра́") - ("а́ила·цәажәа-ра") - ("а́а·ҧхьа-ра")
         # - ("а́-ла·га-ра")
         - Cnv # ?
         - Punct 
      BARRIER Quote + Left | Colon | Semicolon) # don’t go out of quote
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >ADVCL:SEQ (*) IF (p (*)) ;
} ;

WITH VERB - PastIndef
  IF (1* VMain + $$TENSE - PastIndef)
     (c Prt + Quote)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >ADVCL:QUOTE (*) IF (p (*)) ; # was >CONJ
} ;

# asyndetic coordination of finite verbs with equal tense
WITH $$TENSE - VSaying - ("а́зҵаа-ра") - ("а-ҵаа-ра́") - ("а́ила·цәажәа-ра") - ("а́а·ҧхьа-ра")
         - ("а́-ла·га-ра") # - COP
         - Punct - PastIndef
  IF (1* VMain + $$TENSE - PastIndef # was -1 ! same below
      BARRIER Quote + Left | Colon | Semicolon) # don’t go out of quote
     (NOT -1 ("а́а·ҧхьа-ра")) # add similar verbs, type ааҧҳара даҿын
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >PARATAXIS (*) IF (p (*)) ; # was >CONJ
} ;


# syndetic coordination ?????? rework!
WITH VERB - VSaying - ("а́зҵаа-ра") - ("а-ҵаа-ра́") - ("а́ила·цәажәа-ра") - ("а́а·ҧхьа-ра")
         - ("а́-ла·га-ра")
         - Punct - PastIndef
  IF (-1*w VMain - PastIndef BARRIER Quote + Left LINK c >CC) # don’t go out of quote # was 1*w
     (NOT -1 ("а́а·ҧхьа-ра")) # add similar verbs, type ааҧҳара даҿын
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CONJ (*) IF (p (*)) ;
} ;

WITH VERB - VSaying - ("а́зҵаа-ра") - ("а-ҵаа-ра́") - ("а́ила·цәажәа-ра") - ("а́а·ҧхьа-ра")
         - ("а́-ла·га-ра")
         - Punct - PastIndef - ConjIPf
  IF (1* VMain - PastIndef BARRIER Quote + Left) # don’t go out of quote
     (NOT -1 ("а́а·ҧхьа-ра")) # add similar verbs, type ааҧҳара даҿын
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >PARATAXIS (*) IF (p (*)) ;
} ;

# was:
#WITH VERB - VSaying - ("а́зҵаа-ра") - ("а-ҵаа-ра́") - ("а́ила·цәажәа-ра") - ("а́а·ҧхьа-ра")
#         - ("а́-ла·га-ра")
#         - Punct - PastIndef - ConjIPf
#  IF (1* VMain - PastIndef BARRIER Quote + Left) # don’t go out of quote
#     (NOT -1 ("а́а·ҧхьа-ра")) # add similar verbs, type ааҧҳара даҿын
#     (NOT p (*)) {
#  SETPARENT (*) TO (jC1 (*)) ;
#  MAP >PARATAXIS (*) IF (p (*)) ;
#} ;


WITH NonFin - Rel - QUEST
  IF (1 ("аҳа-ра́") + S:Ad)
     (NOT p (*)) {
  MAP >CSUBJ (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;


# but conjoin if verb of saying has nominal >OBJ
WITH VSaying
  IF (-1* VMain)
     (c >OBJ)
     (NOT -1 ("а́шәа"))
     (NOT p (*)) {
  MAP >CONJ (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;


WITH VMain
  IF (1**w ("а-хәы́ц-ра") LINK -1 Prt + Quote)
     (NOT p (*)) {
  MAP >CCOMP:QUOTE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# add -1 Dash version, or delete Adv cohort at -1 of w
WITH VMain
  IF (1**w ("а-хәы́ц-ра") | ("а-ҟрым-ҿры́м-ра") 
      LINK -2 Dash LINK -1 Punct)
     (NOT p (*)) {
  MAP >CCOMP:QUOTE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

# сара соуп ! – абас аҳәара иалагеит
WITH VMain
  IF (1**w ("а́-ла·га-ра") # BARRIER V
      LINK -1 ("а-ҳәа-ра́") | ("а́-хәаа-ра") | ("а́зҵаа-ра")
      LINK -1* Dash LINK -1 Punct)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) ;
} ;

# диазҵаауа далагеит : уабаҟаз , уабаныз ҳәа (doesn’t work), gives >parataxis
WITH VMain | ConjIPf + Q
  IF (-1* Colon
      LINK -1w ("а́-ла·га-ра") # BARRIER V
      LINK -1 ("а-ҳәа-ра́") | ("а́-хәаа-ра") | ("а́зҵаа-ра"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CCOMP:QUOTE (*) ;
} ;


# Арахь уабацо, аҧсуа ? – дҵааит аҩсҭаа.
WITH VMain
  IF (1**w ("а-ҵаа-ра́") | ("а-ҟрым-ҿры́м-ра") LINK -1 Dash LINK -1 Punct)
     (NOT p (*)) {
  MAP >ADVCL:QUOTE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

 
# complement of verb of saying

# Doesn’t always seem to work!?: Сыкаҭа уналатәа, – ҳәа ааҧхьара иаҿын.
# similar: иразҵааит
WITH NOPARENT VMain
  IF (1* # Dash OR Comma LINK 1
          ("ҳәа́") LINK 1 ("а́зҵаа-ра") | ("а-ҵаа-ра́") | ("а́ила·цәажәа-ра") | ("а́а·ҧхьа-ра"))
     (NOT p (*)) {
  MAP >CCOMP:QUOTE (*) ;
  SETPARENT (*) TO (jC1 (*)) ;
} ;

PARENTHESES = ("<«>" "<»>") ;

WITH NOPARENT VMain + $$TENSE
  IF (1**w VMain + $$TENSE - PastIndef BARRIER Colon | Semicolon LINK NONE p >CONJ) # >PARATAXIS)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >PARATAXIS # was >CONJ
      (*) IF (p (*)) ;
} ;

# but parataxis if sentences are divided by ‘:’ or ‘;’ or unequal tense
WITH NOPARENT VMain
  IF (1**w VMain - PastIndef LINK NONE p >PARATAXIS)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >PARATAXIS (*) IF (p (*)) ;
} ;

# this time without comma barrier; see above
WITH NOPARENT CONJIPF
  IF (1* VMain BARRIER V)
     (NOT p (*)) {
   MAP >ADVCL (*) ;
   SETPARENT (*) TO (jC1 (*)) ;
};


WITH NOPARENT N + Hum - F
  IF (1* Poss:3SgM BARRIER V | Noun)
     (NOT p (*)) {
   SETPARENT (*) TO (jC1 (*)) ;
   MAP >NMOD:POSS (*) ;
};


# fix copula
#SECTION

#SETPARENT (*)
#  IF (p Cop)
#  TO (p (*) LINK c >XCOMP) ;

#WITH Cop
#  IF (c >XCOMP) {
#  SETPARENT ALLOWLOOP (*) TO (jC1 (*)) ;
#  # SETPARENT (jC1 (*)) TO (p (*)) ;
#} ;

#WITH >XCOMP
#  IF (c (*)) {
#  SETCHILD ALLOWLOOP (*) TO (p (*)) ;
#} ;

#SETCHILD ALLOWLOOP >XCOMP
#  TO (p (*)) ;


SECTION

# ҳәа, doesnt work when in VMain in PARENTHESES
WITH ("ҳәа́") # Prt + Quote
  IF (-1* VMain)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >MARK (*) ;
} ;

# doesnt work any more??
# this overcomes the problem: rule has to be anchored inside PARENTHESES
WITH VMain
  IF (1* RQuote LINK 1w ("ҳәа́"))
     (NOT p (*)) {
  SETCHILD  (*) TO (jC1 (*)) ;
} ;

# V » – ҳәа
WITH VMain
  IF (1* RQuote LINK 1w Dash)
     (NOT p (*)) {
  SETCHILD  (*) TO (jC1 (*)) ;
} ;

MAP >PUNCT Dash ;

# V » – ҳәа
WITH VMain
  IF (1* RQuote LINK 1 Dash LINK 1w ("ҳәа́"))
     (NOT p (*)) {
  SETCHILD  (*) TO (jC1 (*)) ;
} ;

MAP >MARK ("ҳәа́") ;

# аашьаҩцәа ҳәа иҟаз зегьы
WITH ("ҳәа́") OR ("уҳәа́") # Prt + Quote
  IF (-1 N | V)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >MARK (*) ;
} ;

WITH N
  IF (2 ("а́-ҟа-заа-ра") + Rel)
     (1 ("ҳәа́"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >XCOMP (*) ; # can this be right?
} ;

# Риарҭа, ртәарҭа, рыфатә уҳәа акы
WITH N | V
  IF (2 ("акы́"))
     (1 ("ҳәа́") OR ("уҳәа́"))
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >NMOD:QUOTE (*) ;
} ;

WITH N
  IF (-1 Comma LINK -1 N)
     (NOT p (*)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP >CONJ (*) ;
} ;


MAP >ROOT TARGET (*) - Punct
    IF (NONE p (*)) # has no parent
    ;

# punctuation still without label, e.g. attached to noun
# Акыр иаҧсоу ахәыҷқәа!
MAP >PUNCT Punct ;

# Attach unattached nodes to >ROOT. They will get >ROOT label, difficult to change.
# But these will have to be edited anyway.
SETPARENT (*)
  IF (NONE p (*))
  TO (1* >ROOT) ; # LINK NONE (p (*))) ;

SETPARENT (*)
  IF (NONE p (*))
  TO (-1* >ROOT) ; # LINK NONE (p (*))) ;

SECTION

MAP >?? TARGET (*) ; # rest


REMOVE (*) - RELS ;

# SECTION

# fix >CONJ attachment

SETPARENT >CONJ
  IF (p >CONJ)
  TO (p (*) LINK p (*)) ;

SETPARENT >PARATAXIS
  IF (p >PARATAXIS | >CONJ)
  TO (p (*) LINK p (*)) ;

SECTION # iterate this

SETPARENT >CONJ
  IF (p >CONJ)
  TO (p (*) LINK p (*)) ;

SETPARENT >PARATAXIS
  IF (p >PARATAXIS)
  TO (p (*) LINK p (*)) ;

SECTION

SETPARENT >CONJ
  IF (p >CONJ)
  TO (p (*) LINK p (*)) ;

SECTION

# fix balanced quotes
SETCHILD (*)
  IF (rc* RQuote)
  TO (lc* LQuote) ;

SETCHILD (*)
  IF (lc* LQuote)
  TO (rc* RQuote) ;

SETCHILD >CCOMP:QUOTE
  IF (NEGATE lc Dash)
  TO (lc* Dash) ;

SETCHILD (*)
  IF (rc* Dash)
  TO (lc* Dash) ;

SETCHILD (*)
  IF (lc* Dash)
  TO (rc* Dash) ;

# fix dash attached to punct

# Иахьатәи ҳамш итҟәацны ицоит, – иҳәеит инеиз.
SETCHILD (*)
  IF (rc Punct LINK 1 Dash) # (lc* Punct LINK 1 Dash)
  TO (rc* Dash) ;

# fix commas
SETCHILD (*)
  IF (NEGATE rc Punct)
  TO (rc* Comma) ;

END